
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Pessoa
 * 
 */
export type Pessoa = $Result.DefaultSelection<Prisma.$PessoaPayload>
/**
 * Model Encontrista
 * 
 */
export type Encontrista = $Result.DefaultSelection<Prisma.$EncontristaPayload>
/**
 * Model Encontreiro
 * 
 */
export type Encontreiro = $Result.DefaultSelection<Prisma.$EncontreiroPayload>
/**
 * Model Encontro
 * 
 */
export type Encontro = $Result.DefaultSelection<Prisma.$EncontroPayload>
/**
 * Model Circulo
 * 
 */
export type Circulo = $Result.DefaultSelection<Prisma.$CirculoPayload>
/**
 * Model Endereco
 * 
 */
export type Endereco = $Result.DefaultSelection<Prisma.$EnderecoPayload>
/**
 * Model Local
 * 
 */
export type Local = $Result.DefaultSelection<Prisma.$LocalPayload>
/**
 * Model Carro
 * 
 */
export type Carro = $Result.DefaultSelection<Prisma.$CarroPayload>
/**
 * Model CarroEncontro
 * 
 */
export type CarroEncontro = $Result.DefaultSelection<Prisma.$CarroEncontroPayload>
/**
 * Model ResponsavelExterna
 * 
 */
export type ResponsavelExterna = $Result.DefaultSelection<Prisma.$ResponsavelExternaPayload>
/**
 * Model Carta
 * 
 */
export type Carta = $Result.DefaultSelection<Prisma.$CartaPayload>
/**
 * Model ListaPreferencia
 * 
 */
export type ListaPreferencia = $Result.DefaultSelection<Prisma.$ListaPreferenciaPayload>
/**
 * Model EquipeEncontro
 * 
 */
export type EquipeEncontro = $Result.DefaultSelection<Prisma.$EquipeEncontroPayload>
/**
 * Model EquipeMontagem
 * 
 */
export type EquipeMontagem = $Result.DefaultSelection<Prisma.$EquipeMontagemPayload>
/**
 * Model DomainStatus
 * 
 */
export type DomainStatus = $Result.DefaultSelection<Prisma.$DomainStatusPayload>
/**
 * Model DomainReligiao
 * 
 */
export type DomainReligiao = $Result.DefaultSelection<Prisma.$DomainReligiaoPayload>
/**
 * Model DomainBairroEncontro
 * 
 */
export type DomainBairroEncontro = $Result.DefaultSelection<Prisma.$DomainBairroEncontroPayload>
/**
 * Model DomainMoraCom
 * 
 */
export type DomainMoraCom = $Result.DefaultSelection<Prisma.$DomainMoraComPayload>
/**
 * Model DomainStatusPais
 * 
 */
export type DomainStatusPais = $Result.DefaultSelection<Prisma.$DomainStatusPaisPayload>
/**
 * Model DomainTamanhoCamisa
 * 
 */
export type DomainTamanhoCamisa = $Result.DefaultSelection<Prisma.$DomainTamanhoCamisaPayload>
/**
 * Model DomainCorCirculo
 * 
 */
export type DomainCorCirculo = $Result.DefaultSelection<Prisma.$DomainCorCirculoPayload>
/**
 * Model DomainDisponibilidade
 * 
 */
export type DomainDisponibilidade = $Result.DefaultSelection<Prisma.$DomainDisponibilidadePayload>
/**
 * Model DomainEquipes
 * 
 */
export type DomainEquipes = $Result.DefaultSelection<Prisma.$DomainEquipesPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Value_Status: {
  confirmado: 'confirmado',
  confirmado_sem_sexta: 'confirmado_sem_sexta',
  desistiu: 'desistiu',
  ligar: 'ligar',
  lista_espera: 'lista_espera',
  nao_atende: 'nao_atende',
  prox_encontro: 'prox_encontro',
  vai_pensar: 'vai_pensar',
  delete: 'delete'
};

export type Value_Status = (typeof Value_Status)[keyof typeof Value_Status]


export const Value_Religiao: {
  catolica: 'catolica',
  evangelica: 'evangelica',
  espirita: 'espirita',
  matriz_africana: 'matriz_africana',
  judaica: 'judaica',
  nao_tenho: 'nao_tenho',
  outra: 'outra'
};

export type Value_Religiao = (typeof Value_Religiao)[keyof typeof Value_Religiao]


export const Value_MoraCom: {
  sozinho: 'sozinho',
  conjuge: 'conjuge',
  familiar: 'familiar',
  amigos: 'amigos'
};

export type Value_MoraCom = (typeof Value_MoraCom)[keyof typeof Value_MoraCom]


export const Value_StatusPais: {
  sim: 'sim',
  nao: 'nao',
  na: 'na'
};

export type Value_StatusPais = (typeof Value_StatusPais)[keyof typeof Value_StatusPais]


export const Value_TamanhoCamisa: {
  p: 'p',
  m: 'm',
  g: 'g',
  gg: 'gg',
  xgg: 'xgg',
  outro: 'outro'
};

export type Value_TamanhoCamisa = (typeof Value_TamanhoCamisa)[keyof typeof Value_TamanhoCamisa]


export const Role: {
  ADMIN: 'ADMIN',
  DIRIGENTE: 'DIRIGENTE',
  ENCONTREIRO: 'ENCONTREIRO',
  COORDENADOR: 'COORDENADOR',
  EXTERNA: 'EXTERNA',
  SECRETARIA: 'SECRETARIA',
  ENCONTRISTA: 'ENCONTRISTA',
  TIOEXTERNA: 'TIOEXTERNA',
  TIOSECRETO: 'TIOSECRETO'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Value_Disponibilidade: {
  INDISPONIVEL: 'INDISPONIVEL',
  MUITO_BAIXA: 'MUITO_BAIXA',
  BAIXA: 'BAIXA',
  MEDIA: 'MEDIA',
  ALTA: 'ALTA',
  MUITO_ALTA: 'MUITO_ALTA',
  NAO_PREENCHEU: 'NAO_PREENCHEU'
};

export type Value_Disponibilidade = (typeof Value_Disponibilidade)[keyof typeof Value_Disponibilidade]


export const StatusEncontreiro: {
  ATIVO: 'ATIVO',
  CONVIDADO_ESPECIAL: 'CONVIDADO_ESPECIAL',
  INATIVO: 'INATIVO'
};

export type StatusEncontreiro = (typeof StatusEncontreiro)[keyof typeof StatusEncontreiro]

}

export type Value_Status = $Enums.Value_Status

export const Value_Status: typeof $Enums.Value_Status

export type Value_Religiao = $Enums.Value_Religiao

export const Value_Religiao: typeof $Enums.Value_Religiao

export type Value_MoraCom = $Enums.Value_MoraCom

export const Value_MoraCom: typeof $Enums.Value_MoraCom

export type Value_StatusPais = $Enums.Value_StatusPais

export const Value_StatusPais: typeof $Enums.Value_StatusPais

export type Value_TamanhoCamisa = $Enums.Value_TamanhoCamisa

export const Value_TamanhoCamisa: typeof $Enums.Value_TamanhoCamisa

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Value_Disponibilidade = $Enums.Value_Disponibilidade

export const Value_Disponibilidade: typeof $Enums.Value_Disponibilidade

export type StatusEncontreiro = $Enums.StatusEncontreiro

export const StatusEncontreiro: typeof $Enums.StatusEncontreiro

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Pessoas
 * const pessoas = await prisma.pessoa.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Pessoas
   * const pessoas = await prisma.pessoa.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.pessoa`: Exposes CRUD operations for the **Pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.PessoaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encontrista`: Exposes CRUD operations for the **Encontrista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encontristas
    * const encontristas = await prisma.encontrista.findMany()
    * ```
    */
  get encontrista(): Prisma.EncontristaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encontreiro`: Exposes CRUD operations for the **Encontreiro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encontreiros
    * const encontreiros = await prisma.encontreiro.findMany()
    * ```
    */
  get encontreiro(): Prisma.EncontreiroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encontro`: Exposes CRUD operations for the **Encontro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encontros
    * const encontros = await prisma.encontro.findMany()
    * ```
    */
  get encontro(): Prisma.EncontroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.circulo`: Exposes CRUD operations for the **Circulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Circulos
    * const circulos = await prisma.circulo.findMany()
    * ```
    */
  get circulo(): Prisma.CirculoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **Endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.EnderecoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.local`: Exposes CRUD operations for the **Local** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locals
    * const locals = await prisma.local.findMany()
    * ```
    */
  get local(): Prisma.LocalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carro`: Exposes CRUD operations for the **Carro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carros
    * const carros = await prisma.carro.findMany()
    * ```
    */
  get carro(): Prisma.CarroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carroEncontro`: Exposes CRUD operations for the **CarroEncontro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarroEncontros
    * const carroEncontros = await prisma.carroEncontro.findMany()
    * ```
    */
  get carroEncontro(): Prisma.CarroEncontroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.responsavelExterna`: Exposes CRUD operations for the **ResponsavelExterna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponsavelExternas
    * const responsavelExternas = await prisma.responsavelExterna.findMany()
    * ```
    */
  get responsavelExterna(): Prisma.ResponsavelExternaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.carta`: Exposes CRUD operations for the **Carta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cartas
    * const cartas = await prisma.carta.findMany()
    * ```
    */
  get carta(): Prisma.CartaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listaPreferencia`: Exposes CRUD operations for the **ListaPreferencia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListaPreferencias
    * const listaPreferencias = await prisma.listaPreferencia.findMany()
    * ```
    */
  get listaPreferencia(): Prisma.ListaPreferenciaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipeEncontro`: Exposes CRUD operations for the **EquipeEncontro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipeEncontros
    * const equipeEncontros = await prisma.equipeEncontro.findMany()
    * ```
    */
  get equipeEncontro(): Prisma.EquipeEncontroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipeMontagem`: Exposes CRUD operations for the **EquipeMontagem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipeMontagems
    * const equipeMontagems = await prisma.equipeMontagem.findMany()
    * ```
    */
  get equipeMontagem(): Prisma.EquipeMontagemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainStatus`: Exposes CRUD operations for the **DomainStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainStatuses
    * const domainStatuses = await prisma.domainStatus.findMany()
    * ```
    */
  get domainStatus(): Prisma.DomainStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainReligiao`: Exposes CRUD operations for the **DomainReligiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainReligiaos
    * const domainReligiaos = await prisma.domainReligiao.findMany()
    * ```
    */
  get domainReligiao(): Prisma.DomainReligiaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainBairroEncontro`: Exposes CRUD operations for the **DomainBairroEncontro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainBairroEncontros
    * const domainBairroEncontros = await prisma.domainBairroEncontro.findMany()
    * ```
    */
  get domainBairroEncontro(): Prisma.DomainBairroEncontroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainMoraCom`: Exposes CRUD operations for the **DomainMoraCom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainMoraComs
    * const domainMoraComs = await prisma.domainMoraCom.findMany()
    * ```
    */
  get domainMoraCom(): Prisma.DomainMoraComDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainStatusPais`: Exposes CRUD operations for the **DomainStatusPais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainStatusPais
    * const domainStatusPais = await prisma.domainStatusPais.findMany()
    * ```
    */
  get domainStatusPais(): Prisma.DomainStatusPaisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainTamanhoCamisa`: Exposes CRUD operations for the **DomainTamanhoCamisa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainTamanhoCamisas
    * const domainTamanhoCamisas = await prisma.domainTamanhoCamisa.findMany()
    * ```
    */
  get domainTamanhoCamisa(): Prisma.DomainTamanhoCamisaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainCorCirculo`: Exposes CRUD operations for the **DomainCorCirculo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainCorCirculos
    * const domainCorCirculos = await prisma.domainCorCirculo.findMany()
    * ```
    */
  get domainCorCirculo(): Prisma.DomainCorCirculoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainDisponibilidade`: Exposes CRUD operations for the **DomainDisponibilidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainDisponibilidades
    * const domainDisponibilidades = await prisma.domainDisponibilidade.findMany()
    * ```
    */
  get domainDisponibilidade(): Prisma.DomainDisponibilidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainEquipes`: Exposes CRUD operations for the **DomainEquipes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainEquipes
    * const domainEquipes = await prisma.domainEquipes.findMany()
    * ```
    */
  get domainEquipes(): Prisma.DomainEquipesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Pessoa: 'Pessoa',
    Encontrista: 'Encontrista',
    Encontreiro: 'Encontreiro',
    Encontro: 'Encontro',
    Circulo: 'Circulo',
    Endereco: 'Endereco',
    Local: 'Local',
    Carro: 'Carro',
    CarroEncontro: 'CarroEncontro',
    ResponsavelExterna: 'ResponsavelExterna',
    Carta: 'Carta',
    ListaPreferencia: 'ListaPreferencia',
    EquipeEncontro: 'EquipeEncontro',
    EquipeMontagem: 'EquipeMontagem',
    DomainStatus: 'DomainStatus',
    DomainReligiao: 'DomainReligiao',
    DomainBairroEncontro: 'DomainBairroEncontro',
    DomainMoraCom: 'DomainMoraCom',
    DomainStatusPais: 'DomainStatusPais',
    DomainTamanhoCamisa: 'DomainTamanhoCamisa',
    DomainCorCirculo: 'DomainCorCirculo',
    DomainDisponibilidade: 'DomainDisponibilidade',
    DomainEquipes: 'DomainEquipes',
    Account: 'Account',
    Session: 'Session'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "pessoa" | "encontrista" | "encontreiro" | "encontro" | "circulo" | "endereco" | "local" | "carro" | "carroEncontro" | "responsavelExterna" | "carta" | "listaPreferencia" | "equipeEncontro" | "equipeMontagem" | "domainStatus" | "domainReligiao" | "domainBairroEncontro" | "domainMoraCom" | "domainStatusPais" | "domainTamanhoCamisa" | "domainCorCirculo" | "domainDisponibilidade" | "domainEquipes" | "account" | "session"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Pessoa: {
        payload: Prisma.$PessoaPayload<ExtArgs>
        fields: Prisma.PessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          findFirst: {
            args: Prisma.PessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          findMany: {
            args: Prisma.PessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>[]
          }
          create: {
            args: Prisma.PessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          createMany: {
            args: Prisma.PessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PessoaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>[]
          }
          delete: {
            args: Prisma.PessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          update: {
            args: Prisma.PessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          deleteMany: {
            args: Prisma.PessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PessoaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>[]
          }
          upsert: {
            args: Prisma.PessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PessoaPayload>
          }
          aggregate: {
            args: Prisma.PessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoa>
          }
          groupBy: {
            args: Prisma.PessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCountAggregateOutputType> | number
          }
        }
      }
      Encontrista: {
        payload: Prisma.$EncontristaPayload<ExtArgs>
        fields: Prisma.EncontristaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncontristaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncontristaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          findFirst: {
            args: Prisma.EncontristaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncontristaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          findMany: {
            args: Prisma.EncontristaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>[]
          }
          create: {
            args: Prisma.EncontristaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          createMany: {
            args: Prisma.EncontristaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncontristaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>[]
          }
          delete: {
            args: Prisma.EncontristaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          update: {
            args: Prisma.EncontristaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          deleteMany: {
            args: Prisma.EncontristaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncontristaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncontristaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>[]
          }
          upsert: {
            args: Prisma.EncontristaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontristaPayload>
          }
          aggregate: {
            args: Prisma.EncontristaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncontrista>
          }
          groupBy: {
            args: Prisma.EncontristaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncontristaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncontristaCountArgs<ExtArgs>
            result: $Utils.Optional<EncontristaCountAggregateOutputType> | number
          }
        }
      }
      Encontreiro: {
        payload: Prisma.$EncontreiroPayload<ExtArgs>
        fields: Prisma.EncontreiroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncontreiroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncontreiroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          findFirst: {
            args: Prisma.EncontreiroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncontreiroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          findMany: {
            args: Prisma.EncontreiroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>[]
          }
          create: {
            args: Prisma.EncontreiroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          createMany: {
            args: Prisma.EncontreiroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncontreiroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>[]
          }
          delete: {
            args: Prisma.EncontreiroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          update: {
            args: Prisma.EncontreiroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          deleteMany: {
            args: Prisma.EncontreiroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncontreiroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncontreiroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>[]
          }
          upsert: {
            args: Prisma.EncontreiroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontreiroPayload>
          }
          aggregate: {
            args: Prisma.EncontreiroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncontreiro>
          }
          groupBy: {
            args: Prisma.EncontreiroGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncontreiroGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncontreiroCountArgs<ExtArgs>
            result: $Utils.Optional<EncontreiroCountAggregateOutputType> | number
          }
        }
      }
      Encontro: {
        payload: Prisma.$EncontroPayload<ExtArgs>
        fields: Prisma.EncontroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncontroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncontroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          findFirst: {
            args: Prisma.EncontroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncontroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          findMany: {
            args: Prisma.EncontroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>[]
          }
          create: {
            args: Prisma.EncontroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          createMany: {
            args: Prisma.EncontroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncontroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>[]
          }
          delete: {
            args: Prisma.EncontroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          update: {
            args: Prisma.EncontroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          deleteMany: {
            args: Prisma.EncontroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncontroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncontroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>[]
          }
          upsert: {
            args: Prisma.EncontroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncontroPayload>
          }
          aggregate: {
            args: Prisma.EncontroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncontro>
          }
          groupBy: {
            args: Prisma.EncontroGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncontroGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncontroCountArgs<ExtArgs>
            result: $Utils.Optional<EncontroCountAggregateOutputType> | number
          }
        }
      }
      Circulo: {
        payload: Prisma.$CirculoPayload<ExtArgs>
        fields: Prisma.CirculoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CirculoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CirculoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          findFirst: {
            args: Prisma.CirculoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CirculoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          findMany: {
            args: Prisma.CirculoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>[]
          }
          create: {
            args: Prisma.CirculoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          createMany: {
            args: Prisma.CirculoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CirculoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>[]
          }
          delete: {
            args: Prisma.CirculoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          update: {
            args: Prisma.CirculoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          deleteMany: {
            args: Prisma.CirculoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CirculoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CirculoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>[]
          }
          upsert: {
            args: Prisma.CirculoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CirculoPayload>
          }
          aggregate: {
            args: Prisma.CirculoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCirculo>
          }
          groupBy: {
            args: Prisma.CirculoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CirculoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CirculoCountArgs<ExtArgs>
            result: $Utils.Optional<CirculoCountAggregateOutputType> | number
          }
        }
      }
      Endereco: {
        payload: Prisma.$EnderecoPayload<ExtArgs>
        fields: Prisma.EnderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findFirst: {
            args: Prisma.EnderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          findMany: {
            args: Prisma.EnderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          create: {
            args: Prisma.EnderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          createMany: {
            args: Prisma.EnderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnderecoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          delete: {
            args: Prisma.EnderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          update: {
            args: Prisma.EnderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          deleteMany: {
            args: Prisma.EnderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnderecoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>[]
          }
          upsert: {
            args: Prisma.EnderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.EnderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnderecoCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      Local: {
        payload: Prisma.$LocalPayload<ExtArgs>
        fields: Prisma.LocalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          findFirst: {
            args: Prisma.LocalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          findMany: {
            args: Prisma.LocalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          create: {
            args: Prisma.LocalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          createMany: {
            args: Prisma.LocalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          delete: {
            args: Prisma.LocalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          update: {
            args: Prisma.LocalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          deleteMany: {
            args: Prisma.LocalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          upsert: {
            args: Prisma.LocalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          aggregate: {
            args: Prisma.LocalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocal>
          }
          groupBy: {
            args: Prisma.LocalGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalCountArgs<ExtArgs>
            result: $Utils.Optional<LocalCountAggregateOutputType> | number
          }
        }
      }
      Carro: {
        payload: Prisma.$CarroPayload<ExtArgs>
        fields: Prisma.CarroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          findFirst: {
            args: Prisma.CarroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          findMany: {
            args: Prisma.CarroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>[]
          }
          create: {
            args: Prisma.CarroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          createMany: {
            args: Prisma.CarroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>[]
          }
          delete: {
            args: Prisma.CarroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          update: {
            args: Prisma.CarroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          deleteMany: {
            args: Prisma.CarroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>[]
          }
          upsert: {
            args: Prisma.CarroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroPayload>
          }
          aggregate: {
            args: Prisma.CarroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarro>
          }
          groupBy: {
            args: Prisma.CarroGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarroGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarroCountArgs<ExtArgs>
            result: $Utils.Optional<CarroCountAggregateOutputType> | number
          }
        }
      }
      CarroEncontro: {
        payload: Prisma.$CarroEncontroPayload<ExtArgs>
        fields: Prisma.CarroEncontroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarroEncontroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarroEncontroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          findFirst: {
            args: Prisma.CarroEncontroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarroEncontroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          findMany: {
            args: Prisma.CarroEncontroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>[]
          }
          create: {
            args: Prisma.CarroEncontroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          createMany: {
            args: Prisma.CarroEncontroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarroEncontroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>[]
          }
          delete: {
            args: Prisma.CarroEncontroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          update: {
            args: Prisma.CarroEncontroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          deleteMany: {
            args: Prisma.CarroEncontroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarroEncontroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CarroEncontroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>[]
          }
          upsert: {
            args: Prisma.CarroEncontroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarroEncontroPayload>
          }
          aggregate: {
            args: Prisma.CarroEncontroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarroEncontro>
          }
          groupBy: {
            args: Prisma.CarroEncontroGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarroEncontroGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarroEncontroCountArgs<ExtArgs>
            result: $Utils.Optional<CarroEncontroCountAggregateOutputType> | number
          }
        }
      }
      ResponsavelExterna: {
        payload: Prisma.$ResponsavelExternaPayload<ExtArgs>
        fields: Prisma.ResponsavelExternaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponsavelExternaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponsavelExternaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          findFirst: {
            args: Prisma.ResponsavelExternaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponsavelExternaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          findMany: {
            args: Prisma.ResponsavelExternaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>[]
          }
          create: {
            args: Prisma.ResponsavelExternaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          createMany: {
            args: Prisma.ResponsavelExternaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponsavelExternaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>[]
          }
          delete: {
            args: Prisma.ResponsavelExternaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          update: {
            args: Prisma.ResponsavelExternaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          deleteMany: {
            args: Prisma.ResponsavelExternaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponsavelExternaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResponsavelExternaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>[]
          }
          upsert: {
            args: Prisma.ResponsavelExternaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsavelExternaPayload>
          }
          aggregate: {
            args: Prisma.ResponsavelExternaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsavelExterna>
          }
          groupBy: {
            args: Prisma.ResponsavelExternaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponsavelExternaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponsavelExternaCountArgs<ExtArgs>
            result: $Utils.Optional<ResponsavelExternaCountAggregateOutputType> | number
          }
        }
      }
      Carta: {
        payload: Prisma.$CartaPayload<ExtArgs>
        fields: Prisma.CartaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          findFirst: {
            args: Prisma.CartaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          findMany: {
            args: Prisma.CartaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>[]
          }
          create: {
            args: Prisma.CartaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          createMany: {
            args: Prisma.CartaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>[]
          }
          delete: {
            args: Prisma.CartaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          update: {
            args: Prisma.CartaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          deleteMany: {
            args: Prisma.CartaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>[]
          }
          upsert: {
            args: Prisma.CartaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartaPayload>
          }
          aggregate: {
            args: Prisma.CartaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarta>
          }
          groupBy: {
            args: Prisma.CartaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartaCountArgs<ExtArgs>
            result: $Utils.Optional<CartaCountAggregateOutputType> | number
          }
        }
      }
      ListaPreferencia: {
        payload: Prisma.$ListaPreferenciaPayload<ExtArgs>
        fields: Prisma.ListaPreferenciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListaPreferenciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListaPreferenciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          findFirst: {
            args: Prisma.ListaPreferenciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListaPreferenciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          findMany: {
            args: Prisma.ListaPreferenciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>[]
          }
          create: {
            args: Prisma.ListaPreferenciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          createMany: {
            args: Prisma.ListaPreferenciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListaPreferenciaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>[]
          }
          delete: {
            args: Prisma.ListaPreferenciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          update: {
            args: Prisma.ListaPreferenciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          deleteMany: {
            args: Prisma.ListaPreferenciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListaPreferenciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListaPreferenciaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>[]
          }
          upsert: {
            args: Prisma.ListaPreferenciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListaPreferenciaPayload>
          }
          aggregate: {
            args: Prisma.ListaPreferenciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListaPreferencia>
          }
          groupBy: {
            args: Prisma.ListaPreferenciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListaPreferenciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListaPreferenciaCountArgs<ExtArgs>
            result: $Utils.Optional<ListaPreferenciaCountAggregateOutputType> | number
          }
        }
      }
      EquipeEncontro: {
        payload: Prisma.$EquipeEncontroPayload<ExtArgs>
        fields: Prisma.EquipeEncontroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipeEncontroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipeEncontroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          findFirst: {
            args: Prisma.EquipeEncontroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipeEncontroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          findMany: {
            args: Prisma.EquipeEncontroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>[]
          }
          create: {
            args: Prisma.EquipeEncontroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          createMany: {
            args: Prisma.EquipeEncontroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipeEncontroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>[]
          }
          delete: {
            args: Prisma.EquipeEncontroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          update: {
            args: Prisma.EquipeEncontroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          deleteMany: {
            args: Prisma.EquipeEncontroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipeEncontroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipeEncontroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>[]
          }
          upsert: {
            args: Prisma.EquipeEncontroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeEncontroPayload>
          }
          aggregate: {
            args: Prisma.EquipeEncontroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipeEncontro>
          }
          groupBy: {
            args: Prisma.EquipeEncontroGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipeEncontroGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipeEncontroCountArgs<ExtArgs>
            result: $Utils.Optional<EquipeEncontroCountAggregateOutputType> | number
          }
        }
      }
      EquipeMontagem: {
        payload: Prisma.$EquipeMontagemPayload<ExtArgs>
        fields: Prisma.EquipeMontagemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipeMontagemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipeMontagemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          findFirst: {
            args: Prisma.EquipeMontagemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipeMontagemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          findMany: {
            args: Prisma.EquipeMontagemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>[]
          }
          create: {
            args: Prisma.EquipeMontagemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          createMany: {
            args: Prisma.EquipeMontagemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipeMontagemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>[]
          }
          delete: {
            args: Prisma.EquipeMontagemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          update: {
            args: Prisma.EquipeMontagemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          deleteMany: {
            args: Prisma.EquipeMontagemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipeMontagemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipeMontagemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>[]
          }
          upsert: {
            args: Prisma.EquipeMontagemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipeMontagemPayload>
          }
          aggregate: {
            args: Prisma.EquipeMontagemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipeMontagem>
          }
          groupBy: {
            args: Prisma.EquipeMontagemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipeMontagemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipeMontagemCountArgs<ExtArgs>
            result: $Utils.Optional<EquipeMontagemCountAggregateOutputType> | number
          }
        }
      }
      DomainStatus: {
        payload: Prisma.$DomainStatusPayload<ExtArgs>
        fields: Prisma.DomainStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          findFirst: {
            args: Prisma.DomainStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          findMany: {
            args: Prisma.DomainStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>[]
          }
          create: {
            args: Prisma.DomainStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          createMany: {
            args: Prisma.DomainStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>[]
          }
          delete: {
            args: Prisma.DomainStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          update: {
            args: Prisma.DomainStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          deleteMany: {
            args: Prisma.DomainStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>[]
          }
          upsert: {
            args: Prisma.DomainStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPayload>
          }
          aggregate: {
            args: Prisma.DomainStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainStatus>
          }
          groupBy: {
            args: Prisma.DomainStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainStatusCountArgs<ExtArgs>
            result: $Utils.Optional<DomainStatusCountAggregateOutputType> | number
          }
        }
      }
      DomainReligiao: {
        payload: Prisma.$DomainReligiaoPayload<ExtArgs>
        fields: Prisma.DomainReligiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainReligiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainReligiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          findFirst: {
            args: Prisma.DomainReligiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainReligiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          findMany: {
            args: Prisma.DomainReligiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>[]
          }
          create: {
            args: Prisma.DomainReligiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          createMany: {
            args: Prisma.DomainReligiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainReligiaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>[]
          }
          delete: {
            args: Prisma.DomainReligiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          update: {
            args: Prisma.DomainReligiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          deleteMany: {
            args: Prisma.DomainReligiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainReligiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainReligiaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>[]
          }
          upsert: {
            args: Prisma.DomainReligiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReligiaoPayload>
          }
          aggregate: {
            args: Prisma.DomainReligiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainReligiao>
          }
          groupBy: {
            args: Prisma.DomainReligiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainReligiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainReligiaoCountArgs<ExtArgs>
            result: $Utils.Optional<DomainReligiaoCountAggregateOutputType> | number
          }
        }
      }
      DomainBairroEncontro: {
        payload: Prisma.$DomainBairroEncontroPayload<ExtArgs>
        fields: Prisma.DomainBairroEncontroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainBairroEncontroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainBairroEncontroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          findFirst: {
            args: Prisma.DomainBairroEncontroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainBairroEncontroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          findMany: {
            args: Prisma.DomainBairroEncontroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>[]
          }
          create: {
            args: Prisma.DomainBairroEncontroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          createMany: {
            args: Prisma.DomainBairroEncontroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainBairroEncontroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>[]
          }
          delete: {
            args: Prisma.DomainBairroEncontroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          update: {
            args: Prisma.DomainBairroEncontroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          deleteMany: {
            args: Prisma.DomainBairroEncontroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainBairroEncontroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainBairroEncontroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>[]
          }
          upsert: {
            args: Prisma.DomainBairroEncontroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBairroEncontroPayload>
          }
          aggregate: {
            args: Prisma.DomainBairroEncontroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainBairroEncontro>
          }
          groupBy: {
            args: Prisma.DomainBairroEncontroGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainBairroEncontroGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainBairroEncontroCountArgs<ExtArgs>
            result: $Utils.Optional<DomainBairroEncontroCountAggregateOutputType> | number
          }
        }
      }
      DomainMoraCom: {
        payload: Prisma.$DomainMoraComPayload<ExtArgs>
        fields: Prisma.DomainMoraComFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainMoraComFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainMoraComFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          findFirst: {
            args: Prisma.DomainMoraComFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainMoraComFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          findMany: {
            args: Prisma.DomainMoraComFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>[]
          }
          create: {
            args: Prisma.DomainMoraComCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          createMany: {
            args: Prisma.DomainMoraComCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainMoraComCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>[]
          }
          delete: {
            args: Prisma.DomainMoraComDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          update: {
            args: Prisma.DomainMoraComUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          deleteMany: {
            args: Prisma.DomainMoraComDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainMoraComUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainMoraComUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>[]
          }
          upsert: {
            args: Prisma.DomainMoraComUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainMoraComPayload>
          }
          aggregate: {
            args: Prisma.DomainMoraComAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainMoraCom>
          }
          groupBy: {
            args: Prisma.DomainMoraComGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainMoraComGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainMoraComCountArgs<ExtArgs>
            result: $Utils.Optional<DomainMoraComCountAggregateOutputType> | number
          }
        }
      }
      DomainStatusPais: {
        payload: Prisma.$DomainStatusPaisPayload<ExtArgs>
        fields: Prisma.DomainStatusPaisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainStatusPaisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainStatusPaisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          findFirst: {
            args: Prisma.DomainStatusPaisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainStatusPaisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          findMany: {
            args: Prisma.DomainStatusPaisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>[]
          }
          create: {
            args: Prisma.DomainStatusPaisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          createMany: {
            args: Prisma.DomainStatusPaisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainStatusPaisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>[]
          }
          delete: {
            args: Prisma.DomainStatusPaisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          update: {
            args: Prisma.DomainStatusPaisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          deleteMany: {
            args: Prisma.DomainStatusPaisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainStatusPaisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainStatusPaisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>[]
          }
          upsert: {
            args: Prisma.DomainStatusPaisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainStatusPaisPayload>
          }
          aggregate: {
            args: Prisma.DomainStatusPaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainStatusPais>
          }
          groupBy: {
            args: Prisma.DomainStatusPaisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainStatusPaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainStatusPaisCountArgs<ExtArgs>
            result: $Utils.Optional<DomainStatusPaisCountAggregateOutputType> | number
          }
        }
      }
      DomainTamanhoCamisa: {
        payload: Prisma.$DomainTamanhoCamisaPayload<ExtArgs>
        fields: Prisma.DomainTamanhoCamisaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainTamanhoCamisaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainTamanhoCamisaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          findFirst: {
            args: Prisma.DomainTamanhoCamisaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainTamanhoCamisaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          findMany: {
            args: Prisma.DomainTamanhoCamisaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>[]
          }
          create: {
            args: Prisma.DomainTamanhoCamisaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          createMany: {
            args: Prisma.DomainTamanhoCamisaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainTamanhoCamisaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>[]
          }
          delete: {
            args: Prisma.DomainTamanhoCamisaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          update: {
            args: Prisma.DomainTamanhoCamisaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          deleteMany: {
            args: Prisma.DomainTamanhoCamisaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainTamanhoCamisaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainTamanhoCamisaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>[]
          }
          upsert: {
            args: Prisma.DomainTamanhoCamisaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainTamanhoCamisaPayload>
          }
          aggregate: {
            args: Prisma.DomainTamanhoCamisaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainTamanhoCamisa>
          }
          groupBy: {
            args: Prisma.DomainTamanhoCamisaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainTamanhoCamisaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainTamanhoCamisaCountArgs<ExtArgs>
            result: $Utils.Optional<DomainTamanhoCamisaCountAggregateOutputType> | number
          }
        }
      }
      DomainCorCirculo: {
        payload: Prisma.$DomainCorCirculoPayload<ExtArgs>
        fields: Prisma.DomainCorCirculoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainCorCirculoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainCorCirculoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          findFirst: {
            args: Prisma.DomainCorCirculoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainCorCirculoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          findMany: {
            args: Prisma.DomainCorCirculoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>[]
          }
          create: {
            args: Prisma.DomainCorCirculoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          createMany: {
            args: Prisma.DomainCorCirculoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainCorCirculoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>[]
          }
          delete: {
            args: Prisma.DomainCorCirculoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          update: {
            args: Prisma.DomainCorCirculoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          deleteMany: {
            args: Prisma.DomainCorCirculoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainCorCirculoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainCorCirculoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>[]
          }
          upsert: {
            args: Prisma.DomainCorCirculoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainCorCirculoPayload>
          }
          aggregate: {
            args: Prisma.DomainCorCirculoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainCorCirculo>
          }
          groupBy: {
            args: Prisma.DomainCorCirculoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainCorCirculoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainCorCirculoCountArgs<ExtArgs>
            result: $Utils.Optional<DomainCorCirculoCountAggregateOutputType> | number
          }
        }
      }
      DomainDisponibilidade: {
        payload: Prisma.$DomainDisponibilidadePayload<ExtArgs>
        fields: Prisma.DomainDisponibilidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainDisponibilidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainDisponibilidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          findFirst: {
            args: Prisma.DomainDisponibilidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainDisponibilidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          findMany: {
            args: Prisma.DomainDisponibilidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>[]
          }
          create: {
            args: Prisma.DomainDisponibilidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          createMany: {
            args: Prisma.DomainDisponibilidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainDisponibilidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>[]
          }
          delete: {
            args: Prisma.DomainDisponibilidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          update: {
            args: Prisma.DomainDisponibilidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          deleteMany: {
            args: Prisma.DomainDisponibilidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainDisponibilidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainDisponibilidadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>[]
          }
          upsert: {
            args: Prisma.DomainDisponibilidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainDisponibilidadePayload>
          }
          aggregate: {
            args: Prisma.DomainDisponibilidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainDisponibilidade>
          }
          groupBy: {
            args: Prisma.DomainDisponibilidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainDisponibilidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainDisponibilidadeCountArgs<ExtArgs>
            result: $Utils.Optional<DomainDisponibilidadeCountAggregateOutputType> | number
          }
        }
      }
      DomainEquipes: {
        payload: Prisma.$DomainEquipesPayload<ExtArgs>
        fields: Prisma.DomainEquipesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainEquipesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainEquipesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          findFirst: {
            args: Prisma.DomainEquipesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainEquipesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          findMany: {
            args: Prisma.DomainEquipesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>[]
          }
          create: {
            args: Prisma.DomainEquipesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          createMany: {
            args: Prisma.DomainEquipesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainEquipesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>[]
          }
          delete: {
            args: Prisma.DomainEquipesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          update: {
            args: Prisma.DomainEquipesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          deleteMany: {
            args: Prisma.DomainEquipesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainEquipesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainEquipesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>[]
          }
          upsert: {
            args: Prisma.DomainEquipesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainEquipesPayload>
          }
          aggregate: {
            args: Prisma.DomainEquipesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainEquipes>
          }
          groupBy: {
            args: Prisma.DomainEquipesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainEquipesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainEquipesCountArgs<ExtArgs>
            result: $Utils.Optional<DomainEquipesCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    pessoa?: PessoaOmit
    encontrista?: EncontristaOmit
    encontreiro?: EncontreiroOmit
    encontro?: EncontroOmit
    circulo?: CirculoOmit
    endereco?: EnderecoOmit
    local?: LocalOmit
    carro?: CarroOmit
    carroEncontro?: CarroEncontroOmit
    responsavelExterna?: ResponsavelExternaOmit
    carta?: CartaOmit
    listaPreferencia?: ListaPreferenciaOmit
    equipeEncontro?: EquipeEncontroOmit
    equipeMontagem?: EquipeMontagemOmit
    domainStatus?: DomainStatusOmit
    domainReligiao?: DomainReligiaoOmit
    domainBairroEncontro?: DomainBairroEncontroOmit
    domainMoraCom?: DomainMoraComOmit
    domainStatusPais?: DomainStatusPaisOmit
    domainTamanhoCamisa?: DomainTamanhoCamisaOmit
    domainCorCirculo?: DomainCorCirculoOmit
    domainDisponibilidade?: DomainDisponibilidadeOmit
    domainEquipes?: DomainEquipesOmit
    account?: AccountOmit
    session?: SessionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PessoaCountOutputType
   */

  export type PessoaCountOutputType = {
    accounts: number
    pessoaCarona: number
    pessoaMotorista: number
    cartasDigitais: number
    sessions: number
  }

  export type PessoaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | PessoaCountOutputTypeCountAccountsArgs
    pessoaCarona?: boolean | PessoaCountOutputTypeCountPessoaCaronaArgs
    pessoaMotorista?: boolean | PessoaCountOutputTypeCountPessoaMotoristaArgs
    cartasDigitais?: boolean | PessoaCountOutputTypeCountCartasDigitaisArgs
    sessions?: boolean | PessoaCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountPessoaCaronaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountPessoaMotoristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountCartasDigitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartaWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type EncontreiroCountOutputType
   */

  export type EncontreiroCountOutputType = {
    responsavelCarroExterna: number
    equipeEncontro: number
    listaPreferencias: number
    responsavelExterna: number
  }

  export type EncontreiroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsavelCarroExterna?: boolean | EncontreiroCountOutputTypeCountResponsavelCarroExternaArgs
    equipeEncontro?: boolean | EncontreiroCountOutputTypeCountEquipeEncontroArgs
    listaPreferencias?: boolean | EncontreiroCountOutputTypeCountListaPreferenciasArgs
    responsavelExterna?: boolean | EncontreiroCountOutputTypeCountResponsavelExternaArgs
  }

  // Custom InputTypes
  /**
   * EncontreiroCountOutputType without action
   */
  export type EncontreiroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncontreiroCountOutputType
     */
    select?: EncontreiroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncontreiroCountOutputType without action
   */
  export type EncontreiroCountOutputTypeCountResponsavelCarroExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroEncontroWhereInput
  }

  /**
   * EncontreiroCountOutputType without action
   */
  export type EncontreiroCountOutputTypeCountEquipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeEncontroWhereInput
  }

  /**
   * EncontreiroCountOutputType without action
   */
  export type EncontreiroCountOutputTypeCountListaPreferenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListaPreferenciaWhereInput
  }

  /**
   * EncontreiroCountOutputType without action
   */
  export type EncontreiroCountOutputTypeCountResponsavelExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsavelExternaWhereInput
  }


  /**
   * Count Type EncontroCountOutputType
   */

  export type EncontroCountOutputType = {
    carroEncontro: number
    circulo: number
    encontreiro: number
    EquipeEncontro: number
    ResponsavelExterna: number
  }

  export type EncontroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carroEncontro?: boolean | EncontroCountOutputTypeCountCarroEncontroArgs
    circulo?: boolean | EncontroCountOutputTypeCountCirculoArgs
    encontreiro?: boolean | EncontroCountOutputTypeCountEncontreiroArgs
    EquipeEncontro?: boolean | EncontroCountOutputTypeCountEquipeEncontroArgs
    ResponsavelExterna?: boolean | EncontroCountOutputTypeCountResponsavelExternaArgs
  }

  // Custom InputTypes
  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncontroCountOutputType
     */
    select?: EncontroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeCountCarroEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroEncontroWhereInput
  }

  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeCountCirculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CirculoWhereInput
  }

  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeCountEncontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontreiroWhereInput
  }

  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeCountEquipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeEncontroWhereInput
  }

  /**
   * EncontroCountOutputType without action
   */
  export type EncontroCountOutputTypeCountResponsavelExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsavelExternaWhereInput
  }


  /**
   * Count Type CirculoCountOutputType
   */

  export type CirculoCountOutputType = {
    encontreiro: number
  }

  export type CirculoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | CirculoCountOutputTypeCountEncontreiroArgs
  }

  // Custom InputTypes
  /**
   * CirculoCountOutputType without action
   */
  export type CirculoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CirculoCountOutputType
     */
    select?: CirculoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CirculoCountOutputType without action
   */
  export type CirculoCountOutputTypeCountEncontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontreiroWhereInput
  }


  /**
   * Count Type EnderecoCountOutputType
   */

  export type EnderecoCountOutputType = {
    Encontrista: number
    local: number
    pessoa: number
  }

  export type EnderecoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Encontrista?: boolean | EnderecoCountOutputTypeCountEncontristaArgs
    local?: boolean | EnderecoCountOutputTypeCountLocalArgs
    pessoa?: boolean | EnderecoCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoCountOutputType
     */
    select?: EnderecoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountLocalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaWhereInput
  }


  /**
   * Count Type LocalCountOutputType
   */

  export type LocalCountOutputType = {
    encontro: number
  }

  export type LocalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontro?: boolean | LocalCountOutputTypeCountEncontroArgs
  }

  // Custom InputTypes
  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalCountOutputType
     */
    select?: LocalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeCountEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontroWhereInput
  }


  /**
   * Count Type CarroCountOutputType
   */

  export type CarroCountOutputType = {
    carroEncontro: number
  }

  export type CarroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carroEncontro?: boolean | CarroCountOutputTypeCountCarroEncontroArgs
  }

  // Custom InputTypes
  /**
   * CarroCountOutputType without action
   */
  export type CarroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroCountOutputType
     */
    select?: CarroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarroCountOutputType without action
   */
  export type CarroCountOutputTypeCountCarroEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroEncontroWhereInput
  }


  /**
   * Count Type CarroEncontroCountOutputType
   */

  export type CarroEncontroCountOutputType = {
    encontrista: number
  }

  export type CarroEncontroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | CarroEncontroCountOutputTypeCountEncontristaArgs
  }

  // Custom InputTypes
  /**
   * CarroEncontroCountOutputType without action
   */
  export type CarroEncontroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontroCountOutputType
     */
    select?: CarroEncontroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarroEncontroCountOutputType without action
   */
  export type CarroEncontroCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }


  /**
   * Count Type DomainStatusCountOutputType
   */

  export type DomainStatusCountOutputType = {
    encontrista: number
  }

  export type DomainStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainStatusCountOutputTypeCountEncontristaArgs
  }

  // Custom InputTypes
  /**
   * DomainStatusCountOutputType without action
   */
  export type DomainStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusCountOutputType
     */
    select?: DomainStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainStatusCountOutputType without action
   */
  export type DomainStatusCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }


  /**
   * Count Type DomainReligiaoCountOutputType
   */

  export type DomainReligiaoCountOutputType = {
    encontrista: number
  }

  export type DomainReligiaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainReligiaoCountOutputTypeCountEncontristaArgs
  }

  // Custom InputTypes
  /**
   * DomainReligiaoCountOutputType without action
   */
  export type DomainReligiaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiaoCountOutputType
     */
    select?: DomainReligiaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainReligiaoCountOutputType without action
   */
  export type DomainReligiaoCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }


  /**
   * Count Type DomainMoraComCountOutputType
   */

  export type DomainMoraComCountOutputType = {
    encontrista: number
  }

  export type DomainMoraComCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainMoraComCountOutputTypeCountEncontristaArgs
  }

  // Custom InputTypes
  /**
   * DomainMoraComCountOutputType without action
   */
  export type DomainMoraComCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraComCountOutputType
     */
    select?: DomainMoraComCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainMoraComCountOutputType without action
   */
  export type DomainMoraComCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }


  /**
   * Count Type DomainStatusPaisCountOutputType
   */

  export type DomainStatusPaisCountOutputType = {
    encontrista: number
  }

  export type DomainStatusPaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainStatusPaisCountOutputTypeCountEncontristaArgs
  }

  // Custom InputTypes
  /**
   * DomainStatusPaisCountOutputType without action
   */
  export type DomainStatusPaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPaisCountOutputType
     */
    select?: DomainStatusPaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainStatusPaisCountOutputType without action
   */
  export type DomainStatusPaisCountOutputTypeCountEncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
  }


  /**
   * Count Type DomainTamanhoCamisaCountOutputType
   */

  export type DomainTamanhoCamisaCountOutputType = {
    encontreiro: number
  }

  export type DomainTamanhoCamisaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | DomainTamanhoCamisaCountOutputTypeCountEncontreiroArgs
  }

  // Custom InputTypes
  /**
   * DomainTamanhoCamisaCountOutputType without action
   */
  export type DomainTamanhoCamisaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisaCountOutputType
     */
    select?: DomainTamanhoCamisaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainTamanhoCamisaCountOutputType without action
   */
  export type DomainTamanhoCamisaCountOutputTypeCountEncontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontreiroWhereInput
  }


  /**
   * Count Type DomainCorCirculoCountOutputType
   */

  export type DomainCorCirculoCountOutputType = {
    circulo: number
  }

  export type DomainCorCirculoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circulo?: boolean | DomainCorCirculoCountOutputTypeCountCirculoArgs
  }

  // Custom InputTypes
  /**
   * DomainCorCirculoCountOutputType without action
   */
  export type DomainCorCirculoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculoCountOutputType
     */
    select?: DomainCorCirculoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainCorCirculoCountOutputType without action
   */
  export type DomainCorCirculoCountOutputTypeCountCirculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CirculoWhereInput
  }


  /**
   * Count Type DomainDisponibilidadeCountOutputType
   */

  export type DomainDisponibilidadeCountOutputType = {
    encontreiro: number
  }

  export type DomainDisponibilidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | DomainDisponibilidadeCountOutputTypeCountEncontreiroArgs
  }

  // Custom InputTypes
  /**
   * DomainDisponibilidadeCountOutputType without action
   */
  export type DomainDisponibilidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidadeCountOutputType
     */
    select?: DomainDisponibilidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainDisponibilidadeCountOutputType without action
   */
  export type DomainDisponibilidadeCountOutputTypeCountEncontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontreiroWhereInput
  }


  /**
   * Count Type DomainEquipesCountOutputType
   */

  export type DomainEquipesCountOutputType = {
    EquipeEncontro: number
    EquipeMontagem: number
    ListaPreferencia: number
  }

  export type DomainEquipesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EquipeEncontro?: boolean | DomainEquipesCountOutputTypeCountEquipeEncontroArgs
    EquipeMontagem?: boolean | DomainEquipesCountOutputTypeCountEquipeMontagemArgs
    ListaPreferencia?: boolean | DomainEquipesCountOutputTypeCountListaPreferenciaArgs
  }

  // Custom InputTypes
  /**
   * DomainEquipesCountOutputType without action
   */
  export type DomainEquipesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipesCountOutputType
     */
    select?: DomainEquipesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainEquipesCountOutputType without action
   */
  export type DomainEquipesCountOutputTypeCountEquipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeEncontroWhereInput
  }

  /**
   * DomainEquipesCountOutputType without action
   */
  export type DomainEquipesCountOutputTypeCountEquipeMontagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeMontagemWhereInput
  }

  /**
   * DomainEquipesCountOutputType without action
   */
  export type DomainEquipesCountOutputTypeCountListaPreferenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListaPreferenciaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Pessoa
   */

  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    enderecoNumero: number | null
  }

  export type PessoaSumAggregateOutputType = {
    enderecoNumero: number | null
  }

  export type PessoaMinAggregateOutputType = {
    id: string | null
    nome: string | null
    sobrenome: string | null
    celular: string | null
    telefone: string | null
    email: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    enderecoCep: string | null
    enderecoNumero: number | null
    avatarUrl: string | null
    password: string | null
    changePassword: boolean | null
    apelido: string | null
    role: $Enums.Role | null
    slug: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    sobrenome: string | null
    celular: string | null
    telefone: string | null
    email: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    enderecoCep: string | null
    enderecoNumero: number | null
    avatarUrl: string | null
    password: string | null
    changePassword: boolean | null
    apelido: string | null
    role: $Enums.Role | null
    slug: string | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    sobrenome: number
    celular: number
    telefone: number
    email: number
    createdAt: number
    modifiedAt: number
    enderecoCep: number
    enderecoNumero: number
    avatarUrl: number
    password: number
    changePassword: number
    apelido: number
    role: number
    slug: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    enderecoNumero?: true
  }

  export type PessoaSumAggregateInputType = {
    enderecoNumero?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    celular?: true
    telefone?: true
    email?: true
    createdAt?: true
    modifiedAt?: true
    enderecoCep?: true
    enderecoNumero?: true
    avatarUrl?: true
    password?: true
    changePassword?: true
    apelido?: true
    role?: true
    slug?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    celular?: true
    telefone?: true
    email?: true
    createdAt?: true
    modifiedAt?: true
    enderecoCep?: true
    enderecoNumero?: true
    avatarUrl?: true
    password?: true
    changePassword?: true
    apelido?: true
    role?: true
    slug?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    celular?: true
    telefone?: true
    email?: true
    createdAt?: true
    modifiedAt?: true
    enderecoCep?: true
    enderecoNumero?: true
    avatarUrl?: true
    password?: true
    changePassword?: true
    apelido?: true
    role?: true
    slug?: true
    _all?: true
  }

  export type PessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pessoa to aggregate.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PessoaWhereInput
    orderBy?: PessoaOrderByWithAggregationInput | PessoaOrderByWithAggregationInput[]
    by: PessoaScalarFieldEnum[] | PessoaScalarFieldEnum
    having?: PessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }

  export type PessoaGroupByOutputType = {
    id: string
    nome: string
    sobrenome: string
    celular: string
    telefone: string | null
    email: string
    createdAt: Date
    modifiedAt: Date
    enderecoCep: string
    enderecoNumero: number | null
    avatarUrl: string | null
    password: string | null
    changePassword: boolean
    apelido: string | null
    role: $Enums.Role
    slug: string
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type PessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    celular?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    enderecoCep?: boolean
    enderecoNumero?: boolean
    avatarUrl?: boolean
    password?: boolean
    changePassword?: boolean
    apelido?: boolean
    role?: boolean
    slug?: boolean
    accounts?: boolean | Pessoa$accountsArgs<ExtArgs>
    pessoaCarona?: boolean | Pessoa$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | Pessoa$pessoaMotoristaArgs<ExtArgs>
    cartasDigitais?: boolean | Pessoa$cartasDigitaisArgs<ExtArgs>
    tioAparenteCirculo?: boolean | Pessoa$tioAparenteCirculoArgs<ExtArgs>
    tioSecretoCirculo?: boolean | Pessoa$tioSecretoCirculoArgs<ExtArgs>
    encontreiro?: boolean | Pessoa$encontreiroArgs<ExtArgs>
    encontrista?: boolean | Pessoa$encontristaArgs<ExtArgs>
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    sessions?: boolean | Pessoa$sessionsArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type PessoaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    celular?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    enderecoCep?: boolean
    enderecoNumero?: boolean
    avatarUrl?: boolean
    password?: boolean
    changePassword?: boolean
    apelido?: boolean
    role?: boolean
    slug?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type PessoaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    celular?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    enderecoCep?: boolean
    enderecoNumero?: boolean
    avatarUrl?: boolean
    password?: boolean
    changePassword?: boolean
    apelido?: boolean
    role?: boolean
    slug?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type PessoaSelectScalar = {
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    celular?: boolean
    telefone?: boolean
    email?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    enderecoCep?: boolean
    enderecoNumero?: boolean
    avatarUrl?: boolean
    password?: boolean
    changePassword?: boolean
    apelido?: boolean
    role?: boolean
    slug?: boolean
  }

  export type PessoaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "sobrenome" | "celular" | "telefone" | "email" | "createdAt" | "modifiedAt" | "enderecoCep" | "enderecoNumero" | "avatarUrl" | "password" | "changePassword" | "apelido" | "role" | "slug", ExtArgs["result"]["pessoa"]>
  export type PessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Pessoa$accountsArgs<ExtArgs>
    pessoaCarona?: boolean | Pessoa$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | Pessoa$pessoaMotoristaArgs<ExtArgs>
    cartasDigitais?: boolean | Pessoa$cartasDigitaisArgs<ExtArgs>
    tioAparenteCirculo?: boolean | Pessoa$tioAparenteCirculoArgs<ExtArgs>
    tioSecretoCirculo?: boolean | Pessoa$tioSecretoCirculoArgs<ExtArgs>
    encontreiro?: boolean | Pessoa$encontreiroArgs<ExtArgs>
    encontrista?: boolean | Pessoa$encontristaArgs<ExtArgs>
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    sessions?: boolean | Pessoa$sessionsArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PessoaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }
  export type PessoaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }

  export type $PessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pessoa"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      pessoaCarona: Prisma.$CarroPayload<ExtArgs>[]
      pessoaMotorista: Prisma.$CarroPayload<ExtArgs>[]
      cartasDigitais: Prisma.$CartaPayload<ExtArgs>[]
      tioAparenteCirculo: Prisma.$CirculoPayload<ExtArgs> | null
      tioSecretoCirculo: Prisma.$CirculoPayload<ExtArgs> | null
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs> | null
      encontrista: Prisma.$EncontristaPayload<ExtArgs> | null
      endereco: Prisma.$EnderecoPayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      sobrenome: string
      celular: string
      telefone: string | null
      email: string
      createdAt: Date
      modifiedAt: Date
      enderecoCep: string
      enderecoNumero: number | null
      avatarUrl: string | null
      password: string | null
      changePassword: boolean
      apelido: string | null
      role: $Enums.Role
      slug: string
    }, ExtArgs["result"]["pessoa"]>
    composites: {}
  }

  type PessoaGetPayload<S extends boolean | null | undefined | PessoaDefaultArgs> = $Result.GetResult<Prisma.$PessoaPayload, S>

  type PessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PessoaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface PessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pessoa'], meta: { name: 'Pessoa' } }
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {PessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PessoaFindUniqueArgs>(args: SelectSubset<T, PessoaFindUniqueArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pessoa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, PessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PessoaFindFirstArgs>(args?: SelectSubset<T, PessoaFindFirstArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, PessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PessoaFindManyArgs>(args?: SelectSubset<T, PessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pessoa.
     * @param {PessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
     */
    create<T extends PessoaCreateArgs>(args: SelectSubset<T, PessoaCreateArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pessoas.
     * @param {PessoaCreateManyArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PessoaCreateManyArgs>(args?: SelectSubset<T, PessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pessoas and returns the data saved in the database.
     * @param {PessoaCreateManyAndReturnArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pessoas and only return the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PessoaCreateManyAndReturnArgs>(args?: SelectSubset<T, PessoaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pessoa.
     * @param {PessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
     */
    delete<T extends PessoaDeleteArgs>(args: SelectSubset<T, PessoaDeleteArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pessoa.
     * @param {PessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PessoaUpdateArgs>(args: SelectSubset<T, PessoaUpdateArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pessoas.
     * @param {PessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PessoaDeleteManyArgs>(args?: SelectSubset<T, PessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PessoaUpdateManyArgs>(args: SelectSubset<T, PessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas and returns the data updated in the database.
     * @param {PessoaUpdateManyAndReturnArgs} args - Arguments to update many Pessoas.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pessoas and only return the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PessoaUpdateManyAndReturnArgs>(args: SelectSubset<T, PessoaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pessoa.
     * @param {PessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
     */
    upsert<T extends PessoaUpsertArgs>(args: SelectSubset<T, PessoaUpsertArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends PessoaCountArgs>(
      args?: Subset<T, PessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pessoa model
   */
  readonly fields: PessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends Pessoa$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoaCarona<T extends Pessoa$pessoaCaronaArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$pessoaCaronaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoaMotorista<T extends Pessoa$pessoaMotoristaArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$pessoaMotoristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartasDigitais<T extends Pessoa$cartasDigitaisArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$cartasDigitaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tioAparenteCirculo<T extends Pessoa$tioAparenteCirculoArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$tioAparenteCirculoArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tioSecretoCirculo<T extends Pessoa$tioSecretoCirculoArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$tioSecretoCirculoArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encontreiro<T extends Pessoa$encontreiroArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$encontreiroArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encontrista<T extends Pessoa$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$encontristaArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Pessoa$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Pessoa$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pessoa model
   */
  interface PessoaFieldRefs {
    readonly id: FieldRef<"Pessoa", 'String'>
    readonly nome: FieldRef<"Pessoa", 'String'>
    readonly sobrenome: FieldRef<"Pessoa", 'String'>
    readonly celular: FieldRef<"Pessoa", 'String'>
    readonly telefone: FieldRef<"Pessoa", 'String'>
    readonly email: FieldRef<"Pessoa", 'String'>
    readonly createdAt: FieldRef<"Pessoa", 'DateTime'>
    readonly modifiedAt: FieldRef<"Pessoa", 'DateTime'>
    readonly enderecoCep: FieldRef<"Pessoa", 'String'>
    readonly enderecoNumero: FieldRef<"Pessoa", 'Int'>
    readonly avatarUrl: FieldRef<"Pessoa", 'String'>
    readonly password: FieldRef<"Pessoa", 'String'>
    readonly changePassword: FieldRef<"Pessoa", 'Boolean'>
    readonly apelido: FieldRef<"Pessoa", 'String'>
    readonly role: FieldRef<"Pessoa", 'Role'>
    readonly slug: FieldRef<"Pessoa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pessoa findUnique
   */
  export type PessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findUniqueOrThrow
   */
  export type PessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa findFirst
   */
  export type PessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa findFirstOrThrow
   */
  export type PessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoa to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa findMany
   */
  export type PessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter, which Pessoas to fetch.
     */
    where?: PessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pessoas to fetch.
     */
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pessoas.
     */
    cursor?: PessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pessoas.
     */
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Pessoa create
   */
  export type PessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pessoa.
     */
    data: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
  }

  /**
   * Pessoa createMany
   */
  export type PessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pessoas.
     */
    data: PessoaCreateManyInput | PessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pessoa createManyAndReturn
   */
  export type PessoaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * The data used to create many Pessoas.
     */
    data: PessoaCreateManyInput | PessoaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pessoa update
   */
  export type PessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pessoa.
     */
    data: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
    /**
     * Choose, which Pessoa to update.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa updateMany
   */
  export type PessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pessoas.
     */
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyInput>
    /**
     * Filter which Pessoas to update
     */
    where?: PessoaWhereInput
    /**
     * Limit how many Pessoas to update.
     */
    limit?: number
  }

  /**
   * Pessoa updateManyAndReturn
   */
  export type PessoaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * The data used to update Pessoas.
     */
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyInput>
    /**
     * Filter which Pessoas to update
     */
    where?: PessoaWhereInput
    /**
     * Limit how many Pessoas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pessoa upsert
   */
  export type PessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pessoa to update in case it exists.
     */
    where: PessoaWhereUniqueInput
    /**
     * In case the Pessoa found by the `where` argument doesn't exist, create a new Pessoa with this data.
     */
    create: XOR<PessoaCreateInput, PessoaUncheckedCreateInput>
    /**
     * In case the Pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PessoaUpdateInput, PessoaUncheckedUpdateInput>
  }

  /**
   * Pessoa delete
   */
  export type PessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    /**
     * Filter which Pessoa to delete.
     */
    where: PessoaWhereUniqueInput
  }

  /**
   * Pessoa deleteMany
   */
  export type PessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pessoas to delete
     */
    where?: PessoaWhereInput
    /**
     * Limit how many Pessoas to delete.
     */
    limit?: number
  }

  /**
   * Pessoa.accounts
   */
  export type Pessoa$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Pessoa.pessoaCarona
   */
  export type Pessoa$pessoaCaronaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    where?: CarroWhereInput
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    cursor?: CarroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarroScalarFieldEnum | CarroScalarFieldEnum[]
  }

  /**
   * Pessoa.pessoaMotorista
   */
  export type Pessoa$pessoaMotoristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    where?: CarroWhereInput
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    cursor?: CarroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarroScalarFieldEnum | CarroScalarFieldEnum[]
  }

  /**
   * Pessoa.cartasDigitais
   */
  export type Pessoa$cartasDigitaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    where?: CartaWhereInput
    orderBy?: CartaOrderByWithRelationInput | CartaOrderByWithRelationInput[]
    cursor?: CartaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartaScalarFieldEnum | CartaScalarFieldEnum[]
  }

  /**
   * Pessoa.tioAparenteCirculo
   */
  export type Pessoa$tioAparenteCirculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    where?: CirculoWhereInput
  }

  /**
   * Pessoa.tioSecretoCirculo
   */
  export type Pessoa$tioSecretoCirculoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    where?: CirculoWhereInput
  }

  /**
   * Pessoa.encontreiro
   */
  export type Pessoa$encontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
  }

  /**
   * Pessoa.encontrista
   */
  export type Pessoa$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
  }

  /**
   * Pessoa.sessions
   */
  export type Pessoa$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Pessoa without action
   */
  export type PessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
  }


  /**
   * Model Encontrista
   */

  export type AggregateEncontrista = {
    _count: EncontristaCountAggregateOutputType | null
    _avg: EncontristaAvgAggregateOutputType | null
    _sum: EncontristaSumAggregateOutputType | null
    _min: EncontristaMinAggregateOutputType | null
    _max: EncontristaMaxAggregateOutputType | null
  }

  export type EncontristaAvgAggregateOutputType = {
    endNumero: number | null
    cartasFisicas: number | null
    endNumEncontro: number | null
  }

  export type EncontristaSumAggregateOutputType = {
    endNumero: number | null
    cartasFisicas: number | null
    endNumEncontro: number | null
  }

  export type EncontristaMinAggregateOutputType = {
    idPessoa: string | null
    endComplemento: string | null
    movimentoAnterior: string | null
    observacao: string | null
    nomeContato1: string | null
    telContato1: string | null
    parentescoContato1: string | null
    nomeContato2: string | null
    telContato2: string | null
    parentescoContato2: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    indicadoPorApelido: string | null
    indicadoPorEmail: string | null
    indicadoPorNome: string | null
    indicadoPorTel: string | null
    isAutofill: boolean | null
    idStatus: $Enums.Value_Status | null
    idReligiao: $Enums.Value_Religiao | null
    idMoracom: $Enums.Value_MoraCom | null
    idStatusPais: $Enums.Value_StatusPais | null
    endNumero: number | null
    cartasFisicas: number | null
    idCarroEncontro: string | null
    cepEncontro: string | null
    endComplementoEncontro: string | null
    endNumEncontro: number | null
    obsExternaConhecidos: string | null
    obsExternaLocalizacao: string | null
    obsExternaOutros: string | null
    obsExternaSaude: string | null
    cartasOk: boolean | null
    generosaOk: boolean | null
    familiaOk: boolean | null
  }

  export type EncontristaMaxAggregateOutputType = {
    idPessoa: string | null
    endComplemento: string | null
    movimentoAnterior: string | null
    observacao: string | null
    nomeContato1: string | null
    telContato1: string | null
    parentescoContato1: string | null
    nomeContato2: string | null
    telContato2: string | null
    parentescoContato2: string | null
    createdAt: Date | null
    modifiedAt: Date | null
    indicadoPorApelido: string | null
    indicadoPorEmail: string | null
    indicadoPorNome: string | null
    indicadoPorTel: string | null
    isAutofill: boolean | null
    idStatus: $Enums.Value_Status | null
    idReligiao: $Enums.Value_Religiao | null
    idMoracom: $Enums.Value_MoraCom | null
    idStatusPais: $Enums.Value_StatusPais | null
    endNumero: number | null
    cartasFisicas: number | null
    idCarroEncontro: string | null
    cepEncontro: string | null
    endComplementoEncontro: string | null
    endNumEncontro: number | null
    obsExternaConhecidos: string | null
    obsExternaLocalizacao: string | null
    obsExternaOutros: string | null
    obsExternaSaude: string | null
    cartasOk: boolean | null
    generosaOk: boolean | null
    familiaOk: boolean | null
  }

  export type EncontristaCountAggregateOutputType = {
    idPessoa: number
    endComplemento: number
    movimentoAnterior: number
    observacao: number
    nomeContato1: number
    telContato1: number
    parentescoContato1: number
    nomeContato2: number
    telContato2: number
    parentescoContato2: number
    createdAt: number
    modifiedAt: number
    indicadoPorApelido: number
    indicadoPorEmail: number
    indicadoPorNome: number
    indicadoPorTel: number
    isAutofill: number
    idStatus: number
    idReligiao: number
    idMoracom: number
    idStatusPais: number
    endNumero: number
    cartasFisicas: number
    idCarroEncontro: number
    cepEncontro: number
    endComplementoEncontro: number
    endNumEncontro: number
    obsExternaConhecidos: number
    obsExternaLocalizacao: number
    obsExternaOutros: number
    obsExternaSaude: number
    cartasOk: number
    generosaOk: number
    familiaOk: number
    _all: number
  }


  export type EncontristaAvgAggregateInputType = {
    endNumero?: true
    cartasFisicas?: true
    endNumEncontro?: true
  }

  export type EncontristaSumAggregateInputType = {
    endNumero?: true
    cartasFisicas?: true
    endNumEncontro?: true
  }

  export type EncontristaMinAggregateInputType = {
    idPessoa?: true
    endComplemento?: true
    movimentoAnterior?: true
    observacao?: true
    nomeContato1?: true
    telContato1?: true
    parentescoContato1?: true
    nomeContato2?: true
    telContato2?: true
    parentescoContato2?: true
    createdAt?: true
    modifiedAt?: true
    indicadoPorApelido?: true
    indicadoPorEmail?: true
    indicadoPorNome?: true
    indicadoPorTel?: true
    isAutofill?: true
    idStatus?: true
    idReligiao?: true
    idMoracom?: true
    idStatusPais?: true
    endNumero?: true
    cartasFisicas?: true
    idCarroEncontro?: true
    cepEncontro?: true
    endComplementoEncontro?: true
    endNumEncontro?: true
    obsExternaConhecidos?: true
    obsExternaLocalizacao?: true
    obsExternaOutros?: true
    obsExternaSaude?: true
    cartasOk?: true
    generosaOk?: true
    familiaOk?: true
  }

  export type EncontristaMaxAggregateInputType = {
    idPessoa?: true
    endComplemento?: true
    movimentoAnterior?: true
    observacao?: true
    nomeContato1?: true
    telContato1?: true
    parentescoContato1?: true
    nomeContato2?: true
    telContato2?: true
    parentescoContato2?: true
    createdAt?: true
    modifiedAt?: true
    indicadoPorApelido?: true
    indicadoPorEmail?: true
    indicadoPorNome?: true
    indicadoPorTel?: true
    isAutofill?: true
    idStatus?: true
    idReligiao?: true
    idMoracom?: true
    idStatusPais?: true
    endNumero?: true
    cartasFisicas?: true
    idCarroEncontro?: true
    cepEncontro?: true
    endComplementoEncontro?: true
    endNumEncontro?: true
    obsExternaConhecidos?: true
    obsExternaLocalizacao?: true
    obsExternaOutros?: true
    obsExternaSaude?: true
    cartasOk?: true
    generosaOk?: true
    familiaOk?: true
  }

  export type EncontristaCountAggregateInputType = {
    idPessoa?: true
    endComplemento?: true
    movimentoAnterior?: true
    observacao?: true
    nomeContato1?: true
    telContato1?: true
    parentescoContato1?: true
    nomeContato2?: true
    telContato2?: true
    parentescoContato2?: true
    createdAt?: true
    modifiedAt?: true
    indicadoPorApelido?: true
    indicadoPorEmail?: true
    indicadoPorNome?: true
    indicadoPorTel?: true
    isAutofill?: true
    idStatus?: true
    idReligiao?: true
    idMoracom?: true
    idStatusPais?: true
    endNumero?: true
    cartasFisicas?: true
    idCarroEncontro?: true
    cepEncontro?: true
    endComplementoEncontro?: true
    endNumEncontro?: true
    obsExternaConhecidos?: true
    obsExternaLocalizacao?: true
    obsExternaOutros?: true
    obsExternaSaude?: true
    cartasOk?: true
    generosaOk?: true
    familiaOk?: true
    _all?: true
  }

  export type EncontristaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontrista to aggregate.
     */
    where?: EncontristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontristas to fetch.
     */
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncontristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encontristas
    **/
    _count?: true | EncontristaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncontristaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncontristaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncontristaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncontristaMaxAggregateInputType
  }

  export type GetEncontristaAggregateType<T extends EncontristaAggregateArgs> = {
        [P in keyof T & keyof AggregateEncontrista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncontrista[P]>
      : GetScalarType<T[P], AggregateEncontrista[P]>
  }




  export type EncontristaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithAggregationInput | EncontristaOrderByWithAggregationInput[]
    by: EncontristaScalarFieldEnum[] | EncontristaScalarFieldEnum
    having?: EncontristaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncontristaCountAggregateInputType | true
    _avg?: EncontristaAvgAggregateInputType
    _sum?: EncontristaSumAggregateInputType
    _min?: EncontristaMinAggregateInputType
    _max?: EncontristaMaxAggregateInputType
  }

  export type EncontristaGroupByOutputType = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior: string | null
    observacao: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2: string | null
    telContato2: string | null
    parentescoContato2: string | null
    createdAt: Date
    modifiedAt: Date
    indicadoPorApelido: string | null
    indicadoPorEmail: string | null
    indicadoPorNome: string | null
    indicadoPorTel: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas: number
    idCarroEncontro: string | null
    cepEncontro: string | null
    endComplementoEncontro: string | null
    endNumEncontro: number | null
    obsExternaConhecidos: string | null
    obsExternaLocalizacao: string | null
    obsExternaOutros: string | null
    obsExternaSaude: string | null
    cartasOk: boolean
    generosaOk: boolean
    familiaOk: boolean
    _count: EncontristaCountAggregateOutputType | null
    _avg: EncontristaAvgAggregateOutputType | null
    _sum: EncontristaSumAggregateOutputType | null
    _min: EncontristaMinAggregateOutputType | null
    _max: EncontristaMaxAggregateOutputType | null
  }

  type GetEncontristaGroupByPayload<T extends EncontristaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncontristaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncontristaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncontristaGroupByOutputType[P]>
            : GetScalarType<T[P], EncontristaGroupByOutputType[P]>
        }
      >
    >


  export type EncontristaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    endComplemento?: boolean
    movimentoAnterior?: boolean
    observacao?: boolean
    nomeContato1?: boolean
    telContato1?: boolean
    parentescoContato1?: boolean
    nomeContato2?: boolean
    telContato2?: boolean
    parentescoContato2?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    indicadoPorApelido?: boolean
    indicadoPorEmail?: boolean
    indicadoPorNome?: boolean
    indicadoPorTel?: boolean
    isAutofill?: boolean
    idStatus?: boolean
    idReligiao?: boolean
    idMoracom?: boolean
    idStatusPais?: boolean
    endNumero?: boolean
    cartasFisicas?: boolean
    idCarroEncontro?: boolean
    cepEncontro?: boolean
    endComplementoEncontro?: boolean
    endNumEncontro?: boolean
    obsExternaConhecidos?: boolean
    obsExternaLocalizacao?: boolean
    obsExternaOutros?: boolean
    obsExternaSaude?: boolean
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
    responsavelExterna?: boolean | Encontrista$responsavelExternaArgs<ExtArgs>
  }, ExtArgs["result"]["encontrista"]>

  export type EncontristaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    endComplemento?: boolean
    movimentoAnterior?: boolean
    observacao?: boolean
    nomeContato1?: boolean
    telContato1?: boolean
    parentescoContato1?: boolean
    nomeContato2?: boolean
    telContato2?: boolean
    parentescoContato2?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    indicadoPorApelido?: boolean
    indicadoPorEmail?: boolean
    indicadoPorNome?: boolean
    indicadoPorTel?: boolean
    isAutofill?: boolean
    idStatus?: boolean
    idReligiao?: boolean
    idMoracom?: boolean
    idStatusPais?: boolean
    endNumero?: boolean
    cartasFisicas?: boolean
    idCarroEncontro?: boolean
    cepEncontro?: boolean
    endComplementoEncontro?: boolean
    endNumEncontro?: boolean
    obsExternaConhecidos?: boolean
    obsExternaLocalizacao?: boolean
    obsExternaOutros?: boolean
    obsExternaSaude?: boolean
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontrista"]>

  export type EncontristaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    endComplemento?: boolean
    movimentoAnterior?: boolean
    observacao?: boolean
    nomeContato1?: boolean
    telContato1?: boolean
    parentescoContato1?: boolean
    nomeContato2?: boolean
    telContato2?: boolean
    parentescoContato2?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    indicadoPorApelido?: boolean
    indicadoPorEmail?: boolean
    indicadoPorNome?: boolean
    indicadoPorTel?: boolean
    isAutofill?: boolean
    idStatus?: boolean
    idReligiao?: boolean
    idMoracom?: boolean
    idStatusPais?: boolean
    endNumero?: boolean
    cartasFisicas?: boolean
    idCarroEncontro?: boolean
    cepEncontro?: boolean
    endComplementoEncontro?: boolean
    endNumEncontro?: boolean
    obsExternaConhecidos?: boolean
    obsExternaLocalizacao?: boolean
    obsExternaOutros?: boolean
    obsExternaSaude?: boolean
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontrista"]>

  export type EncontristaSelectScalar = {
    idPessoa?: boolean
    endComplemento?: boolean
    movimentoAnterior?: boolean
    observacao?: boolean
    nomeContato1?: boolean
    telContato1?: boolean
    parentescoContato1?: boolean
    nomeContato2?: boolean
    telContato2?: boolean
    parentescoContato2?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    indicadoPorApelido?: boolean
    indicadoPorEmail?: boolean
    indicadoPorNome?: boolean
    indicadoPorTel?: boolean
    isAutofill?: boolean
    idStatus?: boolean
    idReligiao?: boolean
    idMoracom?: boolean
    idStatusPais?: boolean
    endNumero?: boolean
    cartasFisicas?: boolean
    idCarroEncontro?: boolean
    cepEncontro?: boolean
    endComplementoEncontro?: boolean
    endNumEncontro?: boolean
    obsExternaConhecidos?: boolean
    obsExternaLocalizacao?: boolean
    obsExternaOutros?: boolean
    obsExternaSaude?: boolean
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPessoa" | "endComplemento" | "movimentoAnterior" | "observacao" | "nomeContato1" | "telContato1" | "parentescoContato1" | "nomeContato2" | "telContato2" | "parentescoContato2" | "createdAt" | "modifiedAt" | "indicadoPorApelido" | "indicadoPorEmail" | "indicadoPorNome" | "indicadoPorTel" | "isAutofill" | "idStatus" | "idReligiao" | "idMoracom" | "idStatusPais" | "endNumero" | "cartasFisicas" | "idCarroEncontro" | "cepEncontro" | "endComplementoEncontro" | "endNumEncontro" | "obsExternaConhecidos" | "obsExternaLocalizacao" | "obsExternaOutros" | "obsExternaSaude" | "cartasOk" | "generosaOk" | "familiaOk", ExtArgs["result"]["encontrista"]>
  export type EncontristaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
    responsavelExterna?: boolean | Encontrista$responsavelExternaArgs<ExtArgs>
  }
  export type EncontristaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
  }
  export type EncontristaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enderecoEncontro?: boolean | Encontrista$enderecoEncontroArgs<ExtArgs>
    carroEncontro?: boolean | Encontrista$carroEncontroArgs<ExtArgs>
    moraCom?: boolean | DomainMoraComDefaultArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    religiao?: boolean | DomainReligiaoDefaultArgs<ExtArgs>
    statusPais?: boolean | DomainStatusPaisDefaultArgs<ExtArgs>
    status?: boolean | DomainStatusDefaultArgs<ExtArgs>
  }

  export type $EncontristaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encontrista"
    objects: {
      enderecoEncontro: Prisma.$EnderecoPayload<ExtArgs> | null
      carroEncontro: Prisma.$CarroEncontroPayload<ExtArgs> | null
      moraCom: Prisma.$DomainMoraComPayload<ExtArgs>
      pessoa: Prisma.$PessoaPayload<ExtArgs>
      religiao: Prisma.$DomainReligiaoPayload<ExtArgs>
      statusPais: Prisma.$DomainStatusPaisPayload<ExtArgs>
      status: Prisma.$DomainStatusPayload<ExtArgs>
      responsavelExterna: Prisma.$ResponsavelExternaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idPessoa: string
      endComplemento: string
      movimentoAnterior: string | null
      observacao: string | null
      nomeContato1: string
      telContato1: string
      parentescoContato1: string
      nomeContato2: string | null
      telContato2: string | null
      parentescoContato2: string | null
      createdAt: Date
      modifiedAt: Date
      indicadoPorApelido: string | null
      indicadoPorEmail: string | null
      indicadoPorNome: string | null
      indicadoPorTel: string | null
      isAutofill: boolean
      idStatus: $Enums.Value_Status
      idReligiao: $Enums.Value_Religiao
      idMoracom: $Enums.Value_MoraCom
      idStatusPais: $Enums.Value_StatusPais
      endNumero: number
      cartasFisicas: number
      idCarroEncontro: string | null
      cepEncontro: string | null
      endComplementoEncontro: string | null
      endNumEncontro: number | null
      obsExternaConhecidos: string | null
      obsExternaLocalizacao: string | null
      obsExternaOutros: string | null
      obsExternaSaude: string | null
      cartasOk: boolean
      generosaOk: boolean
      familiaOk: boolean
    }, ExtArgs["result"]["encontrista"]>
    composites: {}
  }

  type EncontristaGetPayload<S extends boolean | null | undefined | EncontristaDefaultArgs> = $Result.GetResult<Prisma.$EncontristaPayload, S>

  type EncontristaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncontristaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncontristaCountAggregateInputType | true
    }

  export interface EncontristaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encontrista'], meta: { name: 'Encontrista' } }
    /**
     * Find zero or one Encontrista that matches the filter.
     * @param {EncontristaFindUniqueArgs} args - Arguments to find a Encontrista
     * @example
     * // Get one Encontrista
     * const encontrista = await prisma.encontrista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncontristaFindUniqueArgs>(args: SelectSubset<T, EncontristaFindUniqueArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encontrista that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncontristaFindUniqueOrThrowArgs} args - Arguments to find a Encontrista
     * @example
     * // Get one Encontrista
     * const encontrista = await prisma.encontrista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncontristaFindUniqueOrThrowArgs>(args: SelectSubset<T, EncontristaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontrista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaFindFirstArgs} args - Arguments to find a Encontrista
     * @example
     * // Get one Encontrista
     * const encontrista = await prisma.encontrista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncontristaFindFirstArgs>(args?: SelectSubset<T, EncontristaFindFirstArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontrista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaFindFirstOrThrowArgs} args - Arguments to find a Encontrista
     * @example
     * // Get one Encontrista
     * const encontrista = await prisma.encontrista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncontristaFindFirstOrThrowArgs>(args?: SelectSubset<T, EncontristaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encontristas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encontristas
     * const encontristas = await prisma.encontrista.findMany()
     * 
     * // Get first 10 Encontristas
     * const encontristas = await prisma.encontrista.findMany({ take: 10 })
     * 
     * // Only select the `idPessoa`
     * const encontristaWithIdPessoaOnly = await prisma.encontrista.findMany({ select: { idPessoa: true } })
     * 
     */
    findMany<T extends EncontristaFindManyArgs>(args?: SelectSubset<T, EncontristaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encontrista.
     * @param {EncontristaCreateArgs} args - Arguments to create a Encontrista.
     * @example
     * // Create one Encontrista
     * const Encontrista = await prisma.encontrista.create({
     *   data: {
     *     // ... data to create a Encontrista
     *   }
     * })
     * 
     */
    create<T extends EncontristaCreateArgs>(args: SelectSubset<T, EncontristaCreateArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encontristas.
     * @param {EncontristaCreateManyArgs} args - Arguments to create many Encontristas.
     * @example
     * // Create many Encontristas
     * const encontrista = await prisma.encontrista.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncontristaCreateManyArgs>(args?: SelectSubset<T, EncontristaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encontristas and returns the data saved in the database.
     * @param {EncontristaCreateManyAndReturnArgs} args - Arguments to create many Encontristas.
     * @example
     * // Create many Encontristas
     * const encontrista = await prisma.encontrista.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encontristas and only return the `idPessoa`
     * const encontristaWithIdPessoaOnly = await prisma.encontrista.createManyAndReturn({
     *   select: { idPessoa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncontristaCreateManyAndReturnArgs>(args?: SelectSubset<T, EncontristaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encontrista.
     * @param {EncontristaDeleteArgs} args - Arguments to delete one Encontrista.
     * @example
     * // Delete one Encontrista
     * const Encontrista = await prisma.encontrista.delete({
     *   where: {
     *     // ... filter to delete one Encontrista
     *   }
     * })
     * 
     */
    delete<T extends EncontristaDeleteArgs>(args: SelectSubset<T, EncontristaDeleteArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encontrista.
     * @param {EncontristaUpdateArgs} args - Arguments to update one Encontrista.
     * @example
     * // Update one Encontrista
     * const encontrista = await prisma.encontrista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncontristaUpdateArgs>(args: SelectSubset<T, EncontristaUpdateArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encontristas.
     * @param {EncontristaDeleteManyArgs} args - Arguments to filter Encontristas to delete.
     * @example
     * // Delete a few Encontristas
     * const { count } = await prisma.encontrista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncontristaDeleteManyArgs>(args?: SelectSubset<T, EncontristaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontristas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encontristas
     * const encontrista = await prisma.encontrista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncontristaUpdateManyArgs>(args: SelectSubset<T, EncontristaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontristas and returns the data updated in the database.
     * @param {EncontristaUpdateManyAndReturnArgs} args - Arguments to update many Encontristas.
     * @example
     * // Update many Encontristas
     * const encontrista = await prisma.encontrista.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encontristas and only return the `idPessoa`
     * const encontristaWithIdPessoaOnly = await prisma.encontrista.updateManyAndReturn({
     *   select: { idPessoa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncontristaUpdateManyAndReturnArgs>(args: SelectSubset<T, EncontristaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encontrista.
     * @param {EncontristaUpsertArgs} args - Arguments to update or create a Encontrista.
     * @example
     * // Update or create a Encontrista
     * const encontrista = await prisma.encontrista.upsert({
     *   create: {
     *     // ... data to create a Encontrista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encontrista we want to update
     *   }
     * })
     */
    upsert<T extends EncontristaUpsertArgs>(args: SelectSubset<T, EncontristaUpsertArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encontristas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaCountArgs} args - Arguments to filter Encontristas to count.
     * @example
     * // Count the number of Encontristas
     * const count = await prisma.encontrista.count({
     *   where: {
     *     // ... the filter for the Encontristas we want to count
     *   }
     * })
    **/
    count<T extends EncontristaCountArgs>(
      args?: Subset<T, EncontristaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncontristaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encontrista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncontristaAggregateArgs>(args: Subset<T, EncontristaAggregateArgs>): Prisma.PrismaPromise<GetEncontristaAggregateType<T>>

    /**
     * Group by Encontrista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontristaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncontristaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncontristaGroupByArgs['orderBy'] }
        : { orderBy?: EncontristaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncontristaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncontristaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encontrista model
   */
  readonly fields: EncontristaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encontrista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncontristaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enderecoEncontro<T extends Encontrista$enderecoEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontrista$enderecoEncontroArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    carroEncontro<T extends Encontrista$carroEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontrista$carroEncontroArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    moraCom<T extends DomainMoraComDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainMoraComDefaultArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    religiao<T extends DomainReligiaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainReligiaoDefaultArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    statusPais<T extends DomainStatusPaisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainStatusPaisDefaultArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends DomainStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainStatusDefaultArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responsavelExterna<T extends Encontrista$responsavelExternaArgs<ExtArgs> = {}>(args?: Subset<T, Encontrista$responsavelExternaArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encontrista model
   */
  interface EncontristaFieldRefs {
    readonly idPessoa: FieldRef<"Encontrista", 'String'>
    readonly endComplemento: FieldRef<"Encontrista", 'String'>
    readonly movimentoAnterior: FieldRef<"Encontrista", 'String'>
    readonly observacao: FieldRef<"Encontrista", 'String'>
    readonly nomeContato1: FieldRef<"Encontrista", 'String'>
    readonly telContato1: FieldRef<"Encontrista", 'String'>
    readonly parentescoContato1: FieldRef<"Encontrista", 'String'>
    readonly nomeContato2: FieldRef<"Encontrista", 'String'>
    readonly telContato2: FieldRef<"Encontrista", 'String'>
    readonly parentescoContato2: FieldRef<"Encontrista", 'String'>
    readonly createdAt: FieldRef<"Encontrista", 'DateTime'>
    readonly modifiedAt: FieldRef<"Encontrista", 'DateTime'>
    readonly indicadoPorApelido: FieldRef<"Encontrista", 'String'>
    readonly indicadoPorEmail: FieldRef<"Encontrista", 'String'>
    readonly indicadoPorNome: FieldRef<"Encontrista", 'String'>
    readonly indicadoPorTel: FieldRef<"Encontrista", 'String'>
    readonly isAutofill: FieldRef<"Encontrista", 'Boolean'>
    readonly idStatus: FieldRef<"Encontrista", 'Value_Status'>
    readonly idReligiao: FieldRef<"Encontrista", 'Value_Religiao'>
    readonly idMoracom: FieldRef<"Encontrista", 'Value_MoraCom'>
    readonly idStatusPais: FieldRef<"Encontrista", 'Value_StatusPais'>
    readonly endNumero: FieldRef<"Encontrista", 'Int'>
    readonly cartasFisicas: FieldRef<"Encontrista", 'Int'>
    readonly idCarroEncontro: FieldRef<"Encontrista", 'String'>
    readonly cepEncontro: FieldRef<"Encontrista", 'String'>
    readonly endComplementoEncontro: FieldRef<"Encontrista", 'String'>
    readonly endNumEncontro: FieldRef<"Encontrista", 'Int'>
    readonly obsExternaConhecidos: FieldRef<"Encontrista", 'String'>
    readonly obsExternaLocalizacao: FieldRef<"Encontrista", 'String'>
    readonly obsExternaOutros: FieldRef<"Encontrista", 'String'>
    readonly obsExternaSaude: FieldRef<"Encontrista", 'String'>
    readonly cartasOk: FieldRef<"Encontrista", 'Boolean'>
    readonly generosaOk: FieldRef<"Encontrista", 'Boolean'>
    readonly familiaOk: FieldRef<"Encontrista", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Encontrista findUnique
   */
  export type EncontristaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter, which Encontrista to fetch.
     */
    where: EncontristaWhereUniqueInput
  }

  /**
   * Encontrista findUniqueOrThrow
   */
  export type EncontristaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter, which Encontrista to fetch.
     */
    where: EncontristaWhereUniqueInput
  }

  /**
   * Encontrista findFirst
   */
  export type EncontristaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter, which Encontrista to fetch.
     */
    where?: EncontristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontristas to fetch.
     */
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontristas.
     */
    cursor?: EncontristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontristas.
     */
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * Encontrista findFirstOrThrow
   */
  export type EncontristaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter, which Encontrista to fetch.
     */
    where?: EncontristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontristas to fetch.
     */
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontristas.
     */
    cursor?: EncontristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontristas.
     */
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * Encontrista findMany
   */
  export type EncontristaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter, which Encontristas to fetch.
     */
    where?: EncontristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontristas to fetch.
     */
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encontristas.
     */
    cursor?: EncontristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontristas.
     */
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * Encontrista create
   */
  export type EncontristaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * The data needed to create a Encontrista.
     */
    data: XOR<EncontristaCreateInput, EncontristaUncheckedCreateInput>
  }

  /**
   * Encontrista createMany
   */
  export type EncontristaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encontristas.
     */
    data: EncontristaCreateManyInput | EncontristaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encontrista createManyAndReturn
   */
  export type EncontristaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * The data used to create many Encontristas.
     */
    data: EncontristaCreateManyInput | EncontristaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontrista update
   */
  export type EncontristaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * The data needed to update a Encontrista.
     */
    data: XOR<EncontristaUpdateInput, EncontristaUncheckedUpdateInput>
    /**
     * Choose, which Encontrista to update.
     */
    where: EncontristaWhereUniqueInput
  }

  /**
   * Encontrista updateMany
   */
  export type EncontristaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encontristas.
     */
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyInput>
    /**
     * Filter which Encontristas to update
     */
    where?: EncontristaWhereInput
    /**
     * Limit how many Encontristas to update.
     */
    limit?: number
  }

  /**
   * Encontrista updateManyAndReturn
   */
  export type EncontristaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * The data used to update Encontristas.
     */
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyInput>
    /**
     * Filter which Encontristas to update
     */
    where?: EncontristaWhereInput
    /**
     * Limit how many Encontristas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontrista upsert
   */
  export type EncontristaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * The filter to search for the Encontrista to update in case it exists.
     */
    where: EncontristaWhereUniqueInput
    /**
     * In case the Encontrista found by the `where` argument doesn't exist, create a new Encontrista with this data.
     */
    create: XOR<EncontristaCreateInput, EncontristaUncheckedCreateInput>
    /**
     * In case the Encontrista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncontristaUpdateInput, EncontristaUncheckedUpdateInput>
  }

  /**
   * Encontrista delete
   */
  export type EncontristaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    /**
     * Filter which Encontrista to delete.
     */
    where: EncontristaWhereUniqueInput
  }

  /**
   * Encontrista deleteMany
   */
  export type EncontristaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontristas to delete
     */
    where?: EncontristaWhereInput
    /**
     * Limit how many Encontristas to delete.
     */
    limit?: number
  }

  /**
   * Encontrista.enderecoEncontro
   */
  export type Encontrista$enderecoEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    where?: EnderecoWhereInput
  }

  /**
   * Encontrista.carroEncontro
   */
  export type Encontrista$carroEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    where?: CarroEncontroWhereInput
  }

  /**
   * Encontrista.responsavelExterna
   */
  export type Encontrista$responsavelExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    where?: ResponsavelExternaWhereInput
  }

  /**
   * Encontrista without action
   */
  export type EncontristaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
  }


  /**
   * Model Encontreiro
   */

  export type AggregateEncontreiro = {
    _count: EncontreiroCountAggregateOutputType | null
    _min: EncontreiroMinAggregateOutputType | null
    _max: EncontreiroMaxAggregateOutputType | null
  }

  export type EncontreiroMinAggregateOutputType = {
    idPessoa: string | null
    dataNasc: Date | null
    instagram: string | null
    restricaoAlimentar: string | null
    idEncontro: string | null
    idCirculo: string | null
    idTamanhoCamisa: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade: $Enums.Value_Disponibilidade | null
    obsBanda: string | null
    observacoes: string | null
    statusMontagem: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroMaxAggregateOutputType = {
    idPessoa: string | null
    dataNasc: Date | null
    instagram: string | null
    restricaoAlimentar: string | null
    idEncontro: string | null
    idCirculo: string | null
    idTamanhoCamisa: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade: $Enums.Value_Disponibilidade | null
    obsBanda: string | null
    observacoes: string | null
    statusMontagem: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroCountAggregateOutputType = {
    idPessoa: number
    dataNasc: number
    instagram: number
    restricaoAlimentar: number
    idEncontro: number
    idCirculo: number
    idTamanhoCamisa: number
    idDisponibilidade: number
    obsBanda: number
    observacoes: number
    statusMontagem: number
    _all: number
  }


  export type EncontreiroMinAggregateInputType = {
    idPessoa?: true
    dataNasc?: true
    instagram?: true
    restricaoAlimentar?: true
    idEncontro?: true
    idCirculo?: true
    idTamanhoCamisa?: true
    idDisponibilidade?: true
    obsBanda?: true
    observacoes?: true
    statusMontagem?: true
  }

  export type EncontreiroMaxAggregateInputType = {
    idPessoa?: true
    dataNasc?: true
    instagram?: true
    restricaoAlimentar?: true
    idEncontro?: true
    idCirculo?: true
    idTamanhoCamisa?: true
    idDisponibilidade?: true
    obsBanda?: true
    observacoes?: true
    statusMontagem?: true
  }

  export type EncontreiroCountAggregateInputType = {
    idPessoa?: true
    dataNasc?: true
    instagram?: true
    restricaoAlimentar?: true
    idEncontro?: true
    idCirculo?: true
    idTamanhoCamisa?: true
    idDisponibilidade?: true
    obsBanda?: true
    observacoes?: true
    statusMontagem?: true
    _all?: true
  }

  export type EncontreiroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontreiro to aggregate.
     */
    where?: EncontreiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontreiros to fetch.
     */
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncontreiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontreiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontreiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encontreiros
    **/
    _count?: true | EncontreiroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncontreiroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncontreiroMaxAggregateInputType
  }

  export type GetEncontreiroAggregateType<T extends EncontreiroAggregateArgs> = {
        [P in keyof T & keyof AggregateEncontreiro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncontreiro[P]>
      : GetScalarType<T[P], AggregateEncontreiro[P]>
  }




  export type EncontreiroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontreiroWhereInput
    orderBy?: EncontreiroOrderByWithAggregationInput | EncontreiroOrderByWithAggregationInput[]
    by: EncontreiroScalarFieldEnum[] | EncontreiroScalarFieldEnum
    having?: EncontreiroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncontreiroCountAggregateInputType | true
    _min?: EncontreiroMinAggregateInputType
    _max?: EncontreiroMaxAggregateInputType
  }

  export type EncontreiroGroupByOutputType = {
    idPessoa: string
    dataNasc: Date
    instagram: string | null
    restricaoAlimentar: string | null
    idEncontro: string | null
    idCirculo: string | null
    idTamanhoCamisa: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade: $Enums.Value_Disponibilidade | null
    obsBanda: string | null
    observacoes: string | null
    statusMontagem: $Enums.StatusEncontreiro | null
    _count: EncontreiroCountAggregateOutputType | null
    _min: EncontreiroMinAggregateOutputType | null
    _max: EncontreiroMaxAggregateOutputType | null
  }

  type GetEncontreiroGroupByPayload<T extends EncontreiroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncontreiroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncontreiroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncontreiroGroupByOutputType[P]>
            : GetScalarType<T[P], EncontreiroGroupByOutputType[P]>
        }
      >
    >


  export type EncontreiroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    dataNasc?: boolean
    instagram?: boolean
    restricaoAlimentar?: boolean
    idEncontro?: boolean
    idCirculo?: boolean
    idTamanhoCamisa?: boolean
    idDisponibilidade?: boolean
    obsBanda?: boolean
    observacoes?: boolean
    statusMontagem?: boolean
    responsavelCarroExterna?: boolean | Encontreiro$responsavelCarroExternaArgs<ExtArgs>
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
    equipeEncontro?: boolean | Encontreiro$equipeEncontroArgs<ExtArgs>
    equipeMontagem?: boolean | Encontreiro$equipeMontagemArgs<ExtArgs>
    listaPreferencias?: boolean | Encontreiro$listaPreferenciasArgs<ExtArgs>
    responsavelExterna?: boolean | Encontreiro$responsavelExternaArgs<ExtArgs>
    _count?: boolean | EncontreiroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontreiro"]>

  export type EncontreiroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    dataNasc?: boolean
    instagram?: boolean
    restricaoAlimentar?: boolean
    idEncontro?: boolean
    idCirculo?: boolean
    idTamanhoCamisa?: boolean
    idDisponibilidade?: boolean
    obsBanda?: boolean
    observacoes?: boolean
    statusMontagem?: boolean
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
  }, ExtArgs["result"]["encontreiro"]>

  export type EncontreiroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    dataNasc?: boolean
    instagram?: boolean
    restricaoAlimentar?: boolean
    idEncontro?: boolean
    idCirculo?: boolean
    idTamanhoCamisa?: boolean
    idDisponibilidade?: boolean
    obsBanda?: boolean
    observacoes?: boolean
    statusMontagem?: boolean
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
  }, ExtArgs["result"]["encontreiro"]>

  export type EncontreiroSelectScalar = {
    idPessoa?: boolean
    dataNasc?: boolean
    instagram?: boolean
    restricaoAlimentar?: boolean
    idEncontro?: boolean
    idCirculo?: boolean
    idTamanhoCamisa?: boolean
    idDisponibilidade?: boolean
    obsBanda?: boolean
    observacoes?: boolean
    statusMontagem?: boolean
  }

  export type EncontreiroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPessoa" | "dataNasc" | "instagram" | "restricaoAlimentar" | "idEncontro" | "idCirculo" | "idTamanhoCamisa" | "idDisponibilidade" | "obsBanda" | "observacoes" | "statusMontagem", ExtArgs["result"]["encontreiro"]>
  export type EncontreiroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsavelCarroExterna?: boolean | Encontreiro$responsavelCarroExternaArgs<ExtArgs>
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
    equipeEncontro?: boolean | Encontreiro$equipeEncontroArgs<ExtArgs>
    equipeMontagem?: boolean | Encontreiro$equipeMontagemArgs<ExtArgs>
    listaPreferencias?: boolean | Encontreiro$listaPreferenciasArgs<ExtArgs>
    responsavelExterna?: boolean | Encontreiro$responsavelExternaArgs<ExtArgs>
    _count?: boolean | EncontreiroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncontreiroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
  }
  export type EncontreiroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circulo?: boolean | Encontreiro$circuloArgs<ExtArgs>
    encontro?: boolean | Encontreiro$encontroArgs<ExtArgs>
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
    tamanhoCamisa?: boolean | Encontreiro$tamanhoCamisaArgs<ExtArgs>
    disponibilidade?: boolean | Encontreiro$disponibilidadeArgs<ExtArgs>
  }

  export type $EncontreiroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encontreiro"
    objects: {
      responsavelCarroExterna: Prisma.$CarroEncontroPayload<ExtArgs>[]
      circulo: Prisma.$CirculoPayload<ExtArgs> | null
      encontro: Prisma.$EncontroPayload<ExtArgs> | null
      pessoa: Prisma.$PessoaPayload<ExtArgs>
      tamanhoCamisa: Prisma.$DomainTamanhoCamisaPayload<ExtArgs> | null
      disponibilidade: Prisma.$DomainDisponibilidadePayload<ExtArgs> | null
      equipeEncontro: Prisma.$EquipeEncontroPayload<ExtArgs>[]
      equipeMontagem: Prisma.$EquipeMontagemPayload<ExtArgs> | null
      listaPreferencias: Prisma.$ListaPreferenciaPayload<ExtArgs>[]
      responsavelExterna: Prisma.$ResponsavelExternaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPessoa: string
      dataNasc: Date
      instagram: string | null
      restricaoAlimentar: string | null
      idEncontro: string | null
      idCirculo: string | null
      idTamanhoCamisa: $Enums.Value_TamanhoCamisa | null
      idDisponibilidade: $Enums.Value_Disponibilidade | null
      obsBanda: string | null
      observacoes: string | null
      statusMontagem: $Enums.StatusEncontreiro | null
    }, ExtArgs["result"]["encontreiro"]>
    composites: {}
  }

  type EncontreiroGetPayload<S extends boolean | null | undefined | EncontreiroDefaultArgs> = $Result.GetResult<Prisma.$EncontreiroPayload, S>

  type EncontreiroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncontreiroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncontreiroCountAggregateInputType | true
    }

  export interface EncontreiroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encontreiro'], meta: { name: 'Encontreiro' } }
    /**
     * Find zero or one Encontreiro that matches the filter.
     * @param {EncontreiroFindUniqueArgs} args - Arguments to find a Encontreiro
     * @example
     * // Get one Encontreiro
     * const encontreiro = await prisma.encontreiro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncontreiroFindUniqueArgs>(args: SelectSubset<T, EncontreiroFindUniqueArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encontreiro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncontreiroFindUniqueOrThrowArgs} args - Arguments to find a Encontreiro
     * @example
     * // Get one Encontreiro
     * const encontreiro = await prisma.encontreiro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncontreiroFindUniqueOrThrowArgs>(args: SelectSubset<T, EncontreiroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontreiro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroFindFirstArgs} args - Arguments to find a Encontreiro
     * @example
     * // Get one Encontreiro
     * const encontreiro = await prisma.encontreiro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncontreiroFindFirstArgs>(args?: SelectSubset<T, EncontreiroFindFirstArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontreiro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroFindFirstOrThrowArgs} args - Arguments to find a Encontreiro
     * @example
     * // Get one Encontreiro
     * const encontreiro = await prisma.encontreiro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncontreiroFindFirstOrThrowArgs>(args?: SelectSubset<T, EncontreiroFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encontreiros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encontreiros
     * const encontreiros = await prisma.encontreiro.findMany()
     * 
     * // Get first 10 Encontreiros
     * const encontreiros = await prisma.encontreiro.findMany({ take: 10 })
     * 
     * // Only select the `idPessoa`
     * const encontreiroWithIdPessoaOnly = await prisma.encontreiro.findMany({ select: { idPessoa: true } })
     * 
     */
    findMany<T extends EncontreiroFindManyArgs>(args?: SelectSubset<T, EncontreiroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encontreiro.
     * @param {EncontreiroCreateArgs} args - Arguments to create a Encontreiro.
     * @example
     * // Create one Encontreiro
     * const Encontreiro = await prisma.encontreiro.create({
     *   data: {
     *     // ... data to create a Encontreiro
     *   }
     * })
     * 
     */
    create<T extends EncontreiroCreateArgs>(args: SelectSubset<T, EncontreiroCreateArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encontreiros.
     * @param {EncontreiroCreateManyArgs} args - Arguments to create many Encontreiros.
     * @example
     * // Create many Encontreiros
     * const encontreiro = await prisma.encontreiro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncontreiroCreateManyArgs>(args?: SelectSubset<T, EncontreiroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encontreiros and returns the data saved in the database.
     * @param {EncontreiroCreateManyAndReturnArgs} args - Arguments to create many Encontreiros.
     * @example
     * // Create many Encontreiros
     * const encontreiro = await prisma.encontreiro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encontreiros and only return the `idPessoa`
     * const encontreiroWithIdPessoaOnly = await prisma.encontreiro.createManyAndReturn({
     *   select: { idPessoa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncontreiroCreateManyAndReturnArgs>(args?: SelectSubset<T, EncontreiroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encontreiro.
     * @param {EncontreiroDeleteArgs} args - Arguments to delete one Encontreiro.
     * @example
     * // Delete one Encontreiro
     * const Encontreiro = await prisma.encontreiro.delete({
     *   where: {
     *     // ... filter to delete one Encontreiro
     *   }
     * })
     * 
     */
    delete<T extends EncontreiroDeleteArgs>(args: SelectSubset<T, EncontreiroDeleteArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encontreiro.
     * @param {EncontreiroUpdateArgs} args - Arguments to update one Encontreiro.
     * @example
     * // Update one Encontreiro
     * const encontreiro = await prisma.encontreiro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncontreiroUpdateArgs>(args: SelectSubset<T, EncontreiroUpdateArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encontreiros.
     * @param {EncontreiroDeleteManyArgs} args - Arguments to filter Encontreiros to delete.
     * @example
     * // Delete a few Encontreiros
     * const { count } = await prisma.encontreiro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncontreiroDeleteManyArgs>(args?: SelectSubset<T, EncontreiroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontreiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encontreiros
     * const encontreiro = await prisma.encontreiro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncontreiroUpdateManyArgs>(args: SelectSubset<T, EncontreiroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontreiros and returns the data updated in the database.
     * @param {EncontreiroUpdateManyAndReturnArgs} args - Arguments to update many Encontreiros.
     * @example
     * // Update many Encontreiros
     * const encontreiro = await prisma.encontreiro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encontreiros and only return the `idPessoa`
     * const encontreiroWithIdPessoaOnly = await prisma.encontreiro.updateManyAndReturn({
     *   select: { idPessoa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncontreiroUpdateManyAndReturnArgs>(args: SelectSubset<T, EncontreiroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encontreiro.
     * @param {EncontreiroUpsertArgs} args - Arguments to update or create a Encontreiro.
     * @example
     * // Update or create a Encontreiro
     * const encontreiro = await prisma.encontreiro.upsert({
     *   create: {
     *     // ... data to create a Encontreiro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encontreiro we want to update
     *   }
     * })
     */
    upsert<T extends EncontreiroUpsertArgs>(args: SelectSubset<T, EncontreiroUpsertArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encontreiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroCountArgs} args - Arguments to filter Encontreiros to count.
     * @example
     * // Count the number of Encontreiros
     * const count = await prisma.encontreiro.count({
     *   where: {
     *     // ... the filter for the Encontreiros we want to count
     *   }
     * })
    **/
    count<T extends EncontreiroCountArgs>(
      args?: Subset<T, EncontreiroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncontreiroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encontreiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncontreiroAggregateArgs>(args: Subset<T, EncontreiroAggregateArgs>): Prisma.PrismaPromise<GetEncontreiroAggregateType<T>>

    /**
     * Group by Encontreiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontreiroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncontreiroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncontreiroGroupByArgs['orderBy'] }
        : { orderBy?: EncontreiroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncontreiroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncontreiroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encontreiro model
   */
  readonly fields: EncontreiroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encontreiro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncontreiroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsavelCarroExterna<T extends Encontreiro$responsavelCarroExternaArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$responsavelCarroExternaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    circulo<T extends Encontreiro$circuloArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$circuloArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encontro<T extends Encontreiro$encontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$encontroArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tamanhoCamisa<T extends Encontreiro$tamanhoCamisaArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$tamanhoCamisaArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    disponibilidade<T extends Encontreiro$disponibilidadeArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$disponibilidadeArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipeEncontro<T extends Encontreiro$equipeEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$equipeEncontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipeMontagem<T extends Encontreiro$equipeMontagemArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$equipeMontagemArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    listaPreferencias<T extends Encontreiro$listaPreferenciasArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$listaPreferenciasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responsavelExterna<T extends Encontreiro$responsavelExternaArgs<ExtArgs> = {}>(args?: Subset<T, Encontreiro$responsavelExternaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encontreiro model
   */
  interface EncontreiroFieldRefs {
    readonly idPessoa: FieldRef<"Encontreiro", 'String'>
    readonly dataNasc: FieldRef<"Encontreiro", 'DateTime'>
    readonly instagram: FieldRef<"Encontreiro", 'String'>
    readonly restricaoAlimentar: FieldRef<"Encontreiro", 'String'>
    readonly idEncontro: FieldRef<"Encontreiro", 'String'>
    readonly idCirculo: FieldRef<"Encontreiro", 'String'>
    readonly idTamanhoCamisa: FieldRef<"Encontreiro", 'Value_TamanhoCamisa'>
    readonly idDisponibilidade: FieldRef<"Encontreiro", 'Value_Disponibilidade'>
    readonly obsBanda: FieldRef<"Encontreiro", 'String'>
    readonly observacoes: FieldRef<"Encontreiro", 'String'>
    readonly statusMontagem: FieldRef<"Encontreiro", 'StatusEncontreiro'>
  }
    

  // Custom InputTypes
  /**
   * Encontreiro findUnique
   */
  export type EncontreiroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter, which Encontreiro to fetch.
     */
    where: EncontreiroWhereUniqueInput
  }

  /**
   * Encontreiro findUniqueOrThrow
   */
  export type EncontreiroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter, which Encontreiro to fetch.
     */
    where: EncontreiroWhereUniqueInput
  }

  /**
   * Encontreiro findFirst
   */
  export type EncontreiroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter, which Encontreiro to fetch.
     */
    where?: EncontreiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontreiros to fetch.
     */
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontreiros.
     */
    cursor?: EncontreiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontreiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontreiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontreiros.
     */
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * Encontreiro findFirstOrThrow
   */
  export type EncontreiroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter, which Encontreiro to fetch.
     */
    where?: EncontreiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontreiros to fetch.
     */
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontreiros.
     */
    cursor?: EncontreiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontreiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontreiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontreiros.
     */
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * Encontreiro findMany
   */
  export type EncontreiroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter, which Encontreiros to fetch.
     */
    where?: EncontreiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontreiros to fetch.
     */
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encontreiros.
     */
    cursor?: EncontreiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontreiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontreiros.
     */
    skip?: number
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * Encontreiro create
   */
  export type EncontreiroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * The data needed to create a Encontreiro.
     */
    data: XOR<EncontreiroCreateInput, EncontreiroUncheckedCreateInput>
  }

  /**
   * Encontreiro createMany
   */
  export type EncontreiroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encontreiros.
     */
    data: EncontreiroCreateManyInput | EncontreiroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encontreiro createManyAndReturn
   */
  export type EncontreiroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * The data used to create many Encontreiros.
     */
    data: EncontreiroCreateManyInput | EncontreiroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontreiro update
   */
  export type EncontreiroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * The data needed to update a Encontreiro.
     */
    data: XOR<EncontreiroUpdateInput, EncontreiroUncheckedUpdateInput>
    /**
     * Choose, which Encontreiro to update.
     */
    where: EncontreiroWhereUniqueInput
  }

  /**
   * Encontreiro updateMany
   */
  export type EncontreiroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encontreiros.
     */
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyInput>
    /**
     * Filter which Encontreiros to update
     */
    where?: EncontreiroWhereInput
    /**
     * Limit how many Encontreiros to update.
     */
    limit?: number
  }

  /**
   * Encontreiro updateManyAndReturn
   */
  export type EncontreiroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * The data used to update Encontreiros.
     */
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyInput>
    /**
     * Filter which Encontreiros to update
     */
    where?: EncontreiroWhereInput
    /**
     * Limit how many Encontreiros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontreiro upsert
   */
  export type EncontreiroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * The filter to search for the Encontreiro to update in case it exists.
     */
    where: EncontreiroWhereUniqueInput
    /**
     * In case the Encontreiro found by the `where` argument doesn't exist, create a new Encontreiro with this data.
     */
    create: XOR<EncontreiroCreateInput, EncontreiroUncheckedCreateInput>
    /**
     * In case the Encontreiro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncontreiroUpdateInput, EncontreiroUncheckedUpdateInput>
  }

  /**
   * Encontreiro delete
   */
  export type EncontreiroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    /**
     * Filter which Encontreiro to delete.
     */
    where: EncontreiroWhereUniqueInput
  }

  /**
   * Encontreiro deleteMany
   */
  export type EncontreiroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontreiros to delete
     */
    where?: EncontreiroWhereInput
    /**
     * Limit how many Encontreiros to delete.
     */
    limit?: number
  }

  /**
   * Encontreiro.responsavelCarroExterna
   */
  export type Encontreiro$responsavelCarroExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    where?: CarroEncontroWhereInput
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    cursor?: CarroEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * Encontreiro.circulo
   */
  export type Encontreiro$circuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    where?: CirculoWhereInput
  }

  /**
   * Encontreiro.encontro
   */
  export type Encontreiro$encontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    where?: EncontroWhereInput
  }

  /**
   * Encontreiro.tamanhoCamisa
   */
  export type Encontreiro$tamanhoCamisaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    where?: DomainTamanhoCamisaWhereInput
  }

  /**
   * Encontreiro.disponibilidade
   */
  export type Encontreiro$disponibilidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    where?: DomainDisponibilidadeWhereInput
  }

  /**
   * Encontreiro.equipeEncontro
   */
  export type Encontreiro$equipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    where?: EquipeEncontroWhereInput
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    cursor?: EquipeEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * Encontreiro.equipeMontagem
   */
  export type Encontreiro$equipeMontagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    where?: EquipeMontagemWhereInput
  }

  /**
   * Encontreiro.listaPreferencias
   */
  export type Encontreiro$listaPreferenciasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    where?: ListaPreferenciaWhereInput
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    cursor?: ListaPreferenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListaPreferenciaScalarFieldEnum | ListaPreferenciaScalarFieldEnum[]
  }

  /**
   * Encontreiro.responsavelExterna
   */
  export type Encontreiro$responsavelExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    where?: ResponsavelExternaWhereInput
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    cursor?: ResponsavelExternaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponsavelExternaScalarFieldEnum | ResponsavelExternaScalarFieldEnum[]
  }

  /**
   * Encontreiro without action
   */
  export type EncontreiroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
  }


  /**
   * Model Encontro
   */

  export type AggregateEncontro = {
    _count: EncontroCountAggregateOutputType | null
    _avg: EncontroAvgAggregateOutputType | null
    _sum: EncontroSumAggregateOutputType | null
    _min: EncontroMinAggregateOutputType | null
    _max: EncontroMaxAggregateOutputType | null
  }

  export type EncontroAvgAggregateOutputType = {
    numeroEncontro: number | null
    numeroCirculos: number | null
    ordemCirculos: number | null
  }

  export type EncontroSumAggregateOutputType = {
    numeroEncontro: number | null
    numeroCirculos: number | null
    ordemCirculos: number | null
  }

  export type EncontroMinAggregateOutputType = {
    id: string | null
    numeroEncontro: number | null
    idLocal: string | null
    temaEspiritual: string | null
    temaFantasia: string | null
    numeroCirculos: number | null
    dataInicio: Date | null
    dataTema: Date | null
    createdAt: Date | null
    modifiedAt: Date | null
    ordemCirculos: number | null
    isReceivingCartas: boolean | null
  }

  export type EncontroMaxAggregateOutputType = {
    id: string | null
    numeroEncontro: number | null
    idLocal: string | null
    temaEspiritual: string | null
    temaFantasia: string | null
    numeroCirculos: number | null
    dataInicio: Date | null
    dataTema: Date | null
    createdAt: Date | null
    modifiedAt: Date | null
    ordemCirculos: number | null
    isReceivingCartas: boolean | null
  }

  export type EncontroCountAggregateOutputType = {
    id: number
    numeroEncontro: number
    idLocal: number
    temaEspiritual: number
    temaFantasia: number
    numeroCirculos: number
    dataInicio: number
    dataTema: number
    createdAt: number
    modifiedAt: number
    ordemCirculos: number
    isReceivingCartas: number
    _all: number
  }


  export type EncontroAvgAggregateInputType = {
    numeroEncontro?: true
    numeroCirculos?: true
    ordemCirculos?: true
  }

  export type EncontroSumAggregateInputType = {
    numeroEncontro?: true
    numeroCirculos?: true
    ordemCirculos?: true
  }

  export type EncontroMinAggregateInputType = {
    id?: true
    numeroEncontro?: true
    idLocal?: true
    temaEspiritual?: true
    temaFantasia?: true
    numeroCirculos?: true
    dataInicio?: true
    dataTema?: true
    createdAt?: true
    modifiedAt?: true
    ordemCirculos?: true
    isReceivingCartas?: true
  }

  export type EncontroMaxAggregateInputType = {
    id?: true
    numeroEncontro?: true
    idLocal?: true
    temaEspiritual?: true
    temaFantasia?: true
    numeroCirculos?: true
    dataInicio?: true
    dataTema?: true
    createdAt?: true
    modifiedAt?: true
    ordemCirculos?: true
    isReceivingCartas?: true
  }

  export type EncontroCountAggregateInputType = {
    id?: true
    numeroEncontro?: true
    idLocal?: true
    temaEspiritual?: true
    temaFantasia?: true
    numeroCirculos?: true
    dataInicio?: true
    dataTema?: true
    createdAt?: true
    modifiedAt?: true
    ordemCirculos?: true
    isReceivingCartas?: true
    _all?: true
  }

  export type EncontroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontro to aggregate.
     */
    where?: EncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontros to fetch.
     */
    orderBy?: EncontroOrderByWithRelationInput | EncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encontros
    **/
    _count?: true | EncontroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncontroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncontroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncontroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncontroMaxAggregateInputType
  }

  export type GetEncontroAggregateType<T extends EncontroAggregateArgs> = {
        [P in keyof T & keyof AggregateEncontro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncontro[P]>
      : GetScalarType<T[P], AggregateEncontro[P]>
  }




  export type EncontroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncontroWhereInput
    orderBy?: EncontroOrderByWithAggregationInput | EncontroOrderByWithAggregationInput[]
    by: EncontroScalarFieldEnum[] | EncontroScalarFieldEnum
    having?: EncontroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncontroCountAggregateInputType | true
    _avg?: EncontroAvgAggregateInputType
    _sum?: EncontroSumAggregateInputType
    _min?: EncontroMinAggregateInputType
    _max?: EncontroMaxAggregateInputType
  }

  export type EncontroGroupByOutputType = {
    id: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual: string | null
    temaFantasia: string | null
    numeroCirculos: number
    dataInicio: Date
    dataTema: Date
    createdAt: Date
    modifiedAt: Date
    ordemCirculos: number
    isReceivingCartas: boolean
    _count: EncontroCountAggregateOutputType | null
    _avg: EncontroAvgAggregateOutputType | null
    _sum: EncontroSumAggregateOutputType | null
    _min: EncontroMinAggregateOutputType | null
    _max: EncontroMaxAggregateOutputType | null
  }

  type GetEncontroGroupByPayload<T extends EncontroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncontroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncontroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncontroGroupByOutputType[P]>
            : GetScalarType<T[P], EncontroGroupByOutputType[P]>
        }
      >
    >


  export type EncontroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEncontro?: boolean
    idLocal?: boolean
    temaEspiritual?: boolean
    temaFantasia?: boolean
    numeroCirculos?: boolean
    dataInicio?: boolean
    dataTema?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    ordemCirculos?: boolean
    isReceivingCartas?: boolean
    carroEncontro?: boolean | Encontro$carroEncontroArgs<ExtArgs>
    circulo?: boolean | Encontro$circuloArgs<ExtArgs>
    encontreiro?: boolean | Encontro$encontreiroArgs<ExtArgs>
    local?: boolean | LocalDefaultArgs<ExtArgs>
    EquipeEncontro?: boolean | Encontro$EquipeEncontroArgs<ExtArgs>
    ResponsavelExterna?: boolean | Encontro$ResponsavelExternaArgs<ExtArgs>
    _count?: boolean | EncontroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontro"]>

  export type EncontroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEncontro?: boolean
    idLocal?: boolean
    temaEspiritual?: boolean
    temaFantasia?: boolean
    numeroCirculos?: boolean
    dataInicio?: boolean
    dataTema?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    ordemCirculos?: boolean
    isReceivingCartas?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontro"]>

  export type EncontroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEncontro?: boolean
    idLocal?: boolean
    temaEspiritual?: boolean
    temaFantasia?: boolean
    numeroCirculos?: boolean
    dataInicio?: boolean
    dataTema?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    ordemCirculos?: boolean
    isReceivingCartas?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encontro"]>

  export type EncontroSelectScalar = {
    id?: boolean
    numeroEncontro?: boolean
    idLocal?: boolean
    temaEspiritual?: boolean
    temaFantasia?: boolean
    numeroCirculos?: boolean
    dataInicio?: boolean
    dataTema?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    ordemCirculos?: boolean
    isReceivingCartas?: boolean
  }

  export type EncontroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroEncontro" | "idLocal" | "temaEspiritual" | "temaFantasia" | "numeroCirculos" | "dataInicio" | "dataTema" | "createdAt" | "modifiedAt" | "ordemCirculos" | "isReceivingCartas", ExtArgs["result"]["encontro"]>
  export type EncontroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carroEncontro?: boolean | Encontro$carroEncontroArgs<ExtArgs>
    circulo?: boolean | Encontro$circuloArgs<ExtArgs>
    encontreiro?: boolean | Encontro$encontreiroArgs<ExtArgs>
    local?: boolean | LocalDefaultArgs<ExtArgs>
    EquipeEncontro?: boolean | Encontro$EquipeEncontroArgs<ExtArgs>
    ResponsavelExterna?: boolean | Encontro$ResponsavelExternaArgs<ExtArgs>
    _count?: boolean | EncontroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncontroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }
  export type EncontroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }

  export type $EncontroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encontro"
    objects: {
      carroEncontro: Prisma.$CarroEncontroPayload<ExtArgs>[]
      circulo: Prisma.$CirculoPayload<ExtArgs>[]
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>[]
      local: Prisma.$LocalPayload<ExtArgs>
      EquipeEncontro: Prisma.$EquipeEncontroPayload<ExtArgs>[]
      ResponsavelExterna: Prisma.$ResponsavelExternaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroEncontro: number
      idLocal: string
      temaEspiritual: string | null
      temaFantasia: string | null
      numeroCirculos: number
      dataInicio: Date
      dataTema: Date
      createdAt: Date
      modifiedAt: Date
      ordemCirculos: number
      isReceivingCartas: boolean
    }, ExtArgs["result"]["encontro"]>
    composites: {}
  }

  type EncontroGetPayload<S extends boolean | null | undefined | EncontroDefaultArgs> = $Result.GetResult<Prisma.$EncontroPayload, S>

  type EncontroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncontroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncontroCountAggregateInputType | true
    }

  export interface EncontroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encontro'], meta: { name: 'Encontro' } }
    /**
     * Find zero or one Encontro that matches the filter.
     * @param {EncontroFindUniqueArgs} args - Arguments to find a Encontro
     * @example
     * // Get one Encontro
     * const encontro = await prisma.encontro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncontroFindUniqueArgs>(args: SelectSubset<T, EncontroFindUniqueArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encontro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncontroFindUniqueOrThrowArgs} args - Arguments to find a Encontro
     * @example
     * // Get one Encontro
     * const encontro = await prisma.encontro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncontroFindUniqueOrThrowArgs>(args: SelectSubset<T, EncontroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroFindFirstArgs} args - Arguments to find a Encontro
     * @example
     * // Get one Encontro
     * const encontro = await prisma.encontro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncontroFindFirstArgs>(args?: SelectSubset<T, EncontroFindFirstArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encontro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroFindFirstOrThrowArgs} args - Arguments to find a Encontro
     * @example
     * // Get one Encontro
     * const encontro = await prisma.encontro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncontroFindFirstOrThrowArgs>(args?: SelectSubset<T, EncontroFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encontros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encontros
     * const encontros = await prisma.encontro.findMany()
     * 
     * // Get first 10 Encontros
     * const encontros = await prisma.encontro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encontroWithIdOnly = await prisma.encontro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncontroFindManyArgs>(args?: SelectSubset<T, EncontroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encontro.
     * @param {EncontroCreateArgs} args - Arguments to create a Encontro.
     * @example
     * // Create one Encontro
     * const Encontro = await prisma.encontro.create({
     *   data: {
     *     // ... data to create a Encontro
     *   }
     * })
     * 
     */
    create<T extends EncontroCreateArgs>(args: SelectSubset<T, EncontroCreateArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encontros.
     * @param {EncontroCreateManyArgs} args - Arguments to create many Encontros.
     * @example
     * // Create many Encontros
     * const encontro = await prisma.encontro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncontroCreateManyArgs>(args?: SelectSubset<T, EncontroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encontros and returns the data saved in the database.
     * @param {EncontroCreateManyAndReturnArgs} args - Arguments to create many Encontros.
     * @example
     * // Create many Encontros
     * const encontro = await prisma.encontro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encontros and only return the `id`
     * const encontroWithIdOnly = await prisma.encontro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncontroCreateManyAndReturnArgs>(args?: SelectSubset<T, EncontroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encontro.
     * @param {EncontroDeleteArgs} args - Arguments to delete one Encontro.
     * @example
     * // Delete one Encontro
     * const Encontro = await prisma.encontro.delete({
     *   where: {
     *     // ... filter to delete one Encontro
     *   }
     * })
     * 
     */
    delete<T extends EncontroDeleteArgs>(args: SelectSubset<T, EncontroDeleteArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encontro.
     * @param {EncontroUpdateArgs} args - Arguments to update one Encontro.
     * @example
     * // Update one Encontro
     * const encontro = await prisma.encontro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncontroUpdateArgs>(args: SelectSubset<T, EncontroUpdateArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encontros.
     * @param {EncontroDeleteManyArgs} args - Arguments to filter Encontros to delete.
     * @example
     * // Delete a few Encontros
     * const { count } = await prisma.encontro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncontroDeleteManyArgs>(args?: SelectSubset<T, EncontroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encontros
     * const encontro = await prisma.encontro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncontroUpdateManyArgs>(args: SelectSubset<T, EncontroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encontros and returns the data updated in the database.
     * @param {EncontroUpdateManyAndReturnArgs} args - Arguments to update many Encontros.
     * @example
     * // Update many Encontros
     * const encontro = await prisma.encontro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encontros and only return the `id`
     * const encontroWithIdOnly = await prisma.encontro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncontroUpdateManyAndReturnArgs>(args: SelectSubset<T, EncontroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encontro.
     * @param {EncontroUpsertArgs} args - Arguments to update or create a Encontro.
     * @example
     * // Update or create a Encontro
     * const encontro = await prisma.encontro.upsert({
     *   create: {
     *     // ... data to create a Encontro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encontro we want to update
     *   }
     * })
     */
    upsert<T extends EncontroUpsertArgs>(args: SelectSubset<T, EncontroUpsertArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroCountArgs} args - Arguments to filter Encontros to count.
     * @example
     * // Count the number of Encontros
     * const count = await prisma.encontro.count({
     *   where: {
     *     // ... the filter for the Encontros we want to count
     *   }
     * })
    **/
    count<T extends EncontroCountArgs>(
      args?: Subset<T, EncontroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncontroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncontroAggregateArgs>(args: Subset<T, EncontroAggregateArgs>): Prisma.PrismaPromise<GetEncontroAggregateType<T>>

    /**
     * Group by Encontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncontroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncontroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncontroGroupByArgs['orderBy'] }
        : { orderBy?: EncontroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncontroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncontroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encontro model
   */
  readonly fields: EncontroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encontro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncontroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carroEncontro<T extends Encontro$carroEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontro$carroEncontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    circulo<T extends Encontro$circuloArgs<ExtArgs> = {}>(args?: Subset<T, Encontro$circuloArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encontreiro<T extends Encontro$encontreiroArgs<ExtArgs> = {}>(args?: Subset<T, Encontro$encontreiroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    local<T extends LocalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalDefaultArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    EquipeEncontro<T extends Encontro$EquipeEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Encontro$EquipeEncontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ResponsavelExterna<T extends Encontro$ResponsavelExternaArgs<ExtArgs> = {}>(args?: Subset<T, Encontro$ResponsavelExternaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encontro model
   */
  interface EncontroFieldRefs {
    readonly id: FieldRef<"Encontro", 'String'>
    readonly numeroEncontro: FieldRef<"Encontro", 'Int'>
    readonly idLocal: FieldRef<"Encontro", 'String'>
    readonly temaEspiritual: FieldRef<"Encontro", 'String'>
    readonly temaFantasia: FieldRef<"Encontro", 'String'>
    readonly numeroCirculos: FieldRef<"Encontro", 'Int'>
    readonly dataInicio: FieldRef<"Encontro", 'DateTime'>
    readonly dataTema: FieldRef<"Encontro", 'DateTime'>
    readonly createdAt: FieldRef<"Encontro", 'DateTime'>
    readonly modifiedAt: FieldRef<"Encontro", 'DateTime'>
    readonly ordemCirculos: FieldRef<"Encontro", 'Int'>
    readonly isReceivingCartas: FieldRef<"Encontro", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Encontro findUnique
   */
  export type EncontroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter, which Encontro to fetch.
     */
    where: EncontroWhereUniqueInput
  }

  /**
   * Encontro findUniqueOrThrow
   */
  export type EncontroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter, which Encontro to fetch.
     */
    where: EncontroWhereUniqueInput
  }

  /**
   * Encontro findFirst
   */
  export type EncontroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter, which Encontro to fetch.
     */
    where?: EncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontros to fetch.
     */
    orderBy?: EncontroOrderByWithRelationInput | EncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontros.
     */
    cursor?: EncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontros.
     */
    distinct?: EncontroScalarFieldEnum | EncontroScalarFieldEnum[]
  }

  /**
   * Encontro findFirstOrThrow
   */
  export type EncontroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter, which Encontro to fetch.
     */
    where?: EncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontros to fetch.
     */
    orderBy?: EncontroOrderByWithRelationInput | EncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encontros.
     */
    cursor?: EncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encontros.
     */
    distinct?: EncontroScalarFieldEnum | EncontroScalarFieldEnum[]
  }

  /**
   * Encontro findMany
   */
  export type EncontroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter, which Encontros to fetch.
     */
    where?: EncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encontros to fetch.
     */
    orderBy?: EncontroOrderByWithRelationInput | EncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encontros.
     */
    cursor?: EncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encontros.
     */
    skip?: number
    distinct?: EncontroScalarFieldEnum | EncontroScalarFieldEnum[]
  }

  /**
   * Encontro create
   */
  export type EncontroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * The data needed to create a Encontro.
     */
    data: XOR<EncontroCreateInput, EncontroUncheckedCreateInput>
  }

  /**
   * Encontro createMany
   */
  export type EncontroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encontros.
     */
    data: EncontroCreateManyInput | EncontroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encontro createManyAndReturn
   */
  export type EncontroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * The data used to create many Encontros.
     */
    data: EncontroCreateManyInput | EncontroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontro update
   */
  export type EncontroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * The data needed to update a Encontro.
     */
    data: XOR<EncontroUpdateInput, EncontroUncheckedUpdateInput>
    /**
     * Choose, which Encontro to update.
     */
    where: EncontroWhereUniqueInput
  }

  /**
   * Encontro updateMany
   */
  export type EncontroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encontros.
     */
    data: XOR<EncontroUpdateManyMutationInput, EncontroUncheckedUpdateManyInput>
    /**
     * Filter which Encontros to update
     */
    where?: EncontroWhereInput
    /**
     * Limit how many Encontros to update.
     */
    limit?: number
  }

  /**
   * Encontro updateManyAndReturn
   */
  export type EncontroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * The data used to update Encontros.
     */
    data: XOR<EncontroUpdateManyMutationInput, EncontroUncheckedUpdateManyInput>
    /**
     * Filter which Encontros to update
     */
    where?: EncontroWhereInput
    /**
     * Limit how many Encontros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encontro upsert
   */
  export type EncontroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * The filter to search for the Encontro to update in case it exists.
     */
    where: EncontroWhereUniqueInput
    /**
     * In case the Encontro found by the `where` argument doesn't exist, create a new Encontro with this data.
     */
    create: XOR<EncontroCreateInput, EncontroUncheckedCreateInput>
    /**
     * In case the Encontro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncontroUpdateInput, EncontroUncheckedUpdateInput>
  }

  /**
   * Encontro delete
   */
  export type EncontroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    /**
     * Filter which Encontro to delete.
     */
    where: EncontroWhereUniqueInput
  }

  /**
   * Encontro deleteMany
   */
  export type EncontroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encontros to delete
     */
    where?: EncontroWhereInput
    /**
     * Limit how many Encontros to delete.
     */
    limit?: number
  }

  /**
   * Encontro.carroEncontro
   */
  export type Encontro$carroEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    where?: CarroEncontroWhereInput
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    cursor?: CarroEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * Encontro.circulo
   */
  export type Encontro$circuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    where?: CirculoWhereInput
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    cursor?: CirculoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CirculoScalarFieldEnum | CirculoScalarFieldEnum[]
  }

  /**
   * Encontro.encontreiro
   */
  export type Encontro$encontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    cursor?: EncontreiroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * Encontro.EquipeEncontro
   */
  export type Encontro$EquipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    where?: EquipeEncontroWhereInput
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    cursor?: EquipeEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * Encontro.ResponsavelExterna
   */
  export type Encontro$ResponsavelExternaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    where?: ResponsavelExternaWhereInput
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    cursor?: ResponsavelExternaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponsavelExternaScalarFieldEnum | ResponsavelExternaScalarFieldEnum[]
  }

  /**
   * Encontro without action
   */
  export type EncontroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
  }


  /**
   * Model Circulo
   */

  export type AggregateCirculo = {
    _count: CirculoCountAggregateOutputType | null
    _avg: CirculoAvgAggregateOutputType | null
    _sum: CirculoSumAggregateOutputType | null
    _min: CirculoMinAggregateOutputType | null
    _max: CirculoMaxAggregateOutputType | null
  }

  export type CirculoAvgAggregateOutputType = {
    idCorCirculo: number | null
  }

  export type CirculoSumAggregateOutputType = {
    idCorCirculo: number | null
  }

  export type CirculoMinAggregateOutputType = {
    id: string | null
    idCorCirculo: number | null
    idTioAparente: string | null
    idTioSecreto: string | null
    idEncontro: string | null
    nome: string | null
  }

  export type CirculoMaxAggregateOutputType = {
    id: string | null
    idCorCirculo: number | null
    idTioAparente: string | null
    idTioSecreto: string | null
    idEncontro: string | null
    nome: string | null
  }

  export type CirculoCountAggregateOutputType = {
    id: number
    idCorCirculo: number
    idTioAparente: number
    idTioSecreto: number
    idEncontro: number
    nome: number
    _all: number
  }


  export type CirculoAvgAggregateInputType = {
    idCorCirculo?: true
  }

  export type CirculoSumAggregateInputType = {
    idCorCirculo?: true
  }

  export type CirculoMinAggregateInputType = {
    id?: true
    idCorCirculo?: true
    idTioAparente?: true
    idTioSecreto?: true
    idEncontro?: true
    nome?: true
  }

  export type CirculoMaxAggregateInputType = {
    id?: true
    idCorCirculo?: true
    idTioAparente?: true
    idTioSecreto?: true
    idEncontro?: true
    nome?: true
  }

  export type CirculoCountAggregateInputType = {
    id?: true
    idCorCirculo?: true
    idTioAparente?: true
    idTioSecreto?: true
    idEncontro?: true
    nome?: true
    _all?: true
  }

  export type CirculoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circulo to aggregate.
     */
    where?: CirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulos to fetch.
     */
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Circulos
    **/
    _count?: true | CirculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CirculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CirculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CirculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CirculoMaxAggregateInputType
  }

  export type GetCirculoAggregateType<T extends CirculoAggregateArgs> = {
        [P in keyof T & keyof AggregateCirculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCirculo[P]>
      : GetScalarType<T[P], AggregateCirculo[P]>
  }




  export type CirculoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CirculoWhereInput
    orderBy?: CirculoOrderByWithAggregationInput | CirculoOrderByWithAggregationInput[]
    by: CirculoScalarFieldEnum[] | CirculoScalarFieldEnum
    having?: CirculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CirculoCountAggregateInputType | true
    _avg?: CirculoAvgAggregateInputType
    _sum?: CirculoSumAggregateInputType
    _min?: CirculoMinAggregateInputType
    _max?: CirculoMaxAggregateInputType
  }

  export type CirculoGroupByOutputType = {
    id: string
    idCorCirculo: number
    idTioAparente: string | null
    idTioSecreto: string | null
    idEncontro: string
    nome: string | null
    _count: CirculoCountAggregateOutputType | null
    _avg: CirculoAvgAggregateOutputType | null
    _sum: CirculoSumAggregateOutputType | null
    _min: CirculoMinAggregateOutputType | null
    _max: CirculoMaxAggregateOutputType | null
  }

  type GetCirculoGroupByPayload<T extends CirculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CirculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CirculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CirculoGroupByOutputType[P]>
            : GetScalarType<T[P], CirculoGroupByOutputType[P]>
        }
      >
    >


  export type CirculoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idCorCirculo?: boolean
    idTioAparente?: boolean
    idTioSecreto?: boolean
    idEncontro?: boolean
    nome?: boolean
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
    encontreiro?: boolean | Circulo$encontreiroArgs<ExtArgs>
    _count?: boolean | CirculoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["circulo"]>

  export type CirculoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idCorCirculo?: boolean
    idTioAparente?: boolean
    idTioSecreto?: boolean
    idEncontro?: boolean
    nome?: boolean
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
  }, ExtArgs["result"]["circulo"]>

  export type CirculoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idCorCirculo?: boolean
    idTioAparente?: boolean
    idTioSecreto?: boolean
    idEncontro?: boolean
    nome?: boolean
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
  }, ExtArgs["result"]["circulo"]>

  export type CirculoSelectScalar = {
    id?: boolean
    idCorCirculo?: boolean
    idTioAparente?: boolean
    idTioSecreto?: boolean
    idEncontro?: boolean
    nome?: boolean
  }

  export type CirculoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idCorCirculo" | "idTioAparente" | "idTioSecreto" | "idEncontro" | "nome", ExtArgs["result"]["circulo"]>
  export type CirculoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
    encontreiro?: boolean | Circulo$encontreiroArgs<ExtArgs>
    _count?: boolean | CirculoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CirculoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
  }
  export type CirculoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    corCirculo?: boolean | DomainCorCirculoDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    tioAparente?: boolean | Circulo$tioAparenteArgs<ExtArgs>
    tioSecreto?: boolean | Circulo$tioSecretoArgs<ExtArgs>
  }

  export type $CirculoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Circulo"
    objects: {
      corCirculo: Prisma.$DomainCorCirculoPayload<ExtArgs>
      encontro: Prisma.$EncontroPayload<ExtArgs>
      tioAparente: Prisma.$PessoaPayload<ExtArgs> | null
      tioSecreto: Prisma.$PessoaPayload<ExtArgs> | null
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idCorCirculo: number
      idTioAparente: string | null
      idTioSecreto: string | null
      idEncontro: string
      nome: string | null
    }, ExtArgs["result"]["circulo"]>
    composites: {}
  }

  type CirculoGetPayload<S extends boolean | null | undefined | CirculoDefaultArgs> = $Result.GetResult<Prisma.$CirculoPayload, S>

  type CirculoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CirculoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CirculoCountAggregateInputType | true
    }

  export interface CirculoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Circulo'], meta: { name: 'Circulo' } }
    /**
     * Find zero or one Circulo that matches the filter.
     * @param {CirculoFindUniqueArgs} args - Arguments to find a Circulo
     * @example
     * // Get one Circulo
     * const circulo = await prisma.circulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CirculoFindUniqueArgs>(args: SelectSubset<T, CirculoFindUniqueArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Circulo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CirculoFindUniqueOrThrowArgs} args - Arguments to find a Circulo
     * @example
     * // Get one Circulo
     * const circulo = await prisma.circulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CirculoFindUniqueOrThrowArgs>(args: SelectSubset<T, CirculoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Circulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoFindFirstArgs} args - Arguments to find a Circulo
     * @example
     * // Get one Circulo
     * const circulo = await prisma.circulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CirculoFindFirstArgs>(args?: SelectSubset<T, CirculoFindFirstArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Circulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoFindFirstOrThrowArgs} args - Arguments to find a Circulo
     * @example
     * // Get one Circulo
     * const circulo = await prisma.circulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CirculoFindFirstOrThrowArgs>(args?: SelectSubset<T, CirculoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Circulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Circulos
     * const circulos = await prisma.circulo.findMany()
     * 
     * // Get first 10 Circulos
     * const circulos = await prisma.circulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const circuloWithIdOnly = await prisma.circulo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CirculoFindManyArgs>(args?: SelectSubset<T, CirculoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Circulo.
     * @param {CirculoCreateArgs} args - Arguments to create a Circulo.
     * @example
     * // Create one Circulo
     * const Circulo = await prisma.circulo.create({
     *   data: {
     *     // ... data to create a Circulo
     *   }
     * })
     * 
     */
    create<T extends CirculoCreateArgs>(args: SelectSubset<T, CirculoCreateArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Circulos.
     * @param {CirculoCreateManyArgs} args - Arguments to create many Circulos.
     * @example
     * // Create many Circulos
     * const circulo = await prisma.circulo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CirculoCreateManyArgs>(args?: SelectSubset<T, CirculoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Circulos and returns the data saved in the database.
     * @param {CirculoCreateManyAndReturnArgs} args - Arguments to create many Circulos.
     * @example
     * // Create many Circulos
     * const circulo = await prisma.circulo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Circulos and only return the `id`
     * const circuloWithIdOnly = await prisma.circulo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CirculoCreateManyAndReturnArgs>(args?: SelectSubset<T, CirculoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Circulo.
     * @param {CirculoDeleteArgs} args - Arguments to delete one Circulo.
     * @example
     * // Delete one Circulo
     * const Circulo = await prisma.circulo.delete({
     *   where: {
     *     // ... filter to delete one Circulo
     *   }
     * })
     * 
     */
    delete<T extends CirculoDeleteArgs>(args: SelectSubset<T, CirculoDeleteArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Circulo.
     * @param {CirculoUpdateArgs} args - Arguments to update one Circulo.
     * @example
     * // Update one Circulo
     * const circulo = await prisma.circulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CirculoUpdateArgs>(args: SelectSubset<T, CirculoUpdateArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Circulos.
     * @param {CirculoDeleteManyArgs} args - Arguments to filter Circulos to delete.
     * @example
     * // Delete a few Circulos
     * const { count } = await prisma.circulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CirculoDeleteManyArgs>(args?: SelectSubset<T, CirculoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Circulos
     * const circulo = await prisma.circulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CirculoUpdateManyArgs>(args: SelectSubset<T, CirculoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Circulos and returns the data updated in the database.
     * @param {CirculoUpdateManyAndReturnArgs} args - Arguments to update many Circulos.
     * @example
     * // Update many Circulos
     * const circulo = await prisma.circulo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Circulos and only return the `id`
     * const circuloWithIdOnly = await prisma.circulo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CirculoUpdateManyAndReturnArgs>(args: SelectSubset<T, CirculoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Circulo.
     * @param {CirculoUpsertArgs} args - Arguments to update or create a Circulo.
     * @example
     * // Update or create a Circulo
     * const circulo = await prisma.circulo.upsert({
     *   create: {
     *     // ... data to create a Circulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Circulo we want to update
     *   }
     * })
     */
    upsert<T extends CirculoUpsertArgs>(args: SelectSubset<T, CirculoUpsertArgs<ExtArgs>>): Prisma__CirculoClient<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Circulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoCountArgs} args - Arguments to filter Circulos to count.
     * @example
     * // Count the number of Circulos
     * const count = await prisma.circulo.count({
     *   where: {
     *     // ... the filter for the Circulos we want to count
     *   }
     * })
    **/
    count<T extends CirculoCountArgs>(
      args?: Subset<T, CirculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CirculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Circulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CirculoAggregateArgs>(args: Subset<T, CirculoAggregateArgs>): Prisma.PrismaPromise<GetCirculoAggregateType<T>>

    /**
     * Group by Circulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CirculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CirculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CirculoGroupByArgs['orderBy'] }
        : { orderBy?: CirculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CirculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCirculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Circulo model
   */
  readonly fields: CirculoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Circulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CirculoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    corCirculo<T extends DomainCorCirculoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainCorCirculoDefaultArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encontro<T extends EncontroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontroDefaultArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tioAparente<T extends Circulo$tioAparenteArgs<ExtArgs> = {}>(args?: Subset<T, Circulo$tioAparenteArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tioSecreto<T extends Circulo$tioSecretoArgs<ExtArgs> = {}>(args?: Subset<T, Circulo$tioSecretoArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    encontreiro<T extends Circulo$encontreiroArgs<ExtArgs> = {}>(args?: Subset<T, Circulo$encontreiroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Circulo model
   */
  interface CirculoFieldRefs {
    readonly id: FieldRef<"Circulo", 'String'>
    readonly idCorCirculo: FieldRef<"Circulo", 'Int'>
    readonly idTioAparente: FieldRef<"Circulo", 'String'>
    readonly idTioSecreto: FieldRef<"Circulo", 'String'>
    readonly idEncontro: FieldRef<"Circulo", 'String'>
    readonly nome: FieldRef<"Circulo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Circulo findUnique
   */
  export type CirculoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter, which Circulo to fetch.
     */
    where: CirculoWhereUniqueInput
  }

  /**
   * Circulo findUniqueOrThrow
   */
  export type CirculoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter, which Circulo to fetch.
     */
    where: CirculoWhereUniqueInput
  }

  /**
   * Circulo findFirst
   */
  export type CirculoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter, which Circulo to fetch.
     */
    where?: CirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulos to fetch.
     */
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circulos.
     */
    cursor?: CirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circulos.
     */
    distinct?: CirculoScalarFieldEnum | CirculoScalarFieldEnum[]
  }

  /**
   * Circulo findFirstOrThrow
   */
  export type CirculoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter, which Circulo to fetch.
     */
    where?: CirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulos to fetch.
     */
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Circulos.
     */
    cursor?: CirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Circulos.
     */
    distinct?: CirculoScalarFieldEnum | CirculoScalarFieldEnum[]
  }

  /**
   * Circulo findMany
   */
  export type CirculoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter, which Circulos to fetch.
     */
    where?: CirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Circulos to fetch.
     */
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Circulos.
     */
    cursor?: CirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Circulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Circulos.
     */
    skip?: number
    distinct?: CirculoScalarFieldEnum | CirculoScalarFieldEnum[]
  }

  /**
   * Circulo create
   */
  export type CirculoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * The data needed to create a Circulo.
     */
    data: XOR<CirculoCreateInput, CirculoUncheckedCreateInput>
  }

  /**
   * Circulo createMany
   */
  export type CirculoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Circulos.
     */
    data: CirculoCreateManyInput | CirculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Circulo createManyAndReturn
   */
  export type CirculoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * The data used to create many Circulos.
     */
    data: CirculoCreateManyInput | CirculoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Circulo update
   */
  export type CirculoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * The data needed to update a Circulo.
     */
    data: XOR<CirculoUpdateInput, CirculoUncheckedUpdateInput>
    /**
     * Choose, which Circulo to update.
     */
    where: CirculoWhereUniqueInput
  }

  /**
   * Circulo updateMany
   */
  export type CirculoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Circulos.
     */
    data: XOR<CirculoUpdateManyMutationInput, CirculoUncheckedUpdateManyInput>
    /**
     * Filter which Circulos to update
     */
    where?: CirculoWhereInput
    /**
     * Limit how many Circulos to update.
     */
    limit?: number
  }

  /**
   * Circulo updateManyAndReturn
   */
  export type CirculoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * The data used to update Circulos.
     */
    data: XOR<CirculoUpdateManyMutationInput, CirculoUncheckedUpdateManyInput>
    /**
     * Filter which Circulos to update
     */
    where?: CirculoWhereInput
    /**
     * Limit how many Circulos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Circulo upsert
   */
  export type CirculoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * The filter to search for the Circulo to update in case it exists.
     */
    where: CirculoWhereUniqueInput
    /**
     * In case the Circulo found by the `where` argument doesn't exist, create a new Circulo with this data.
     */
    create: XOR<CirculoCreateInput, CirculoUncheckedCreateInput>
    /**
     * In case the Circulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CirculoUpdateInput, CirculoUncheckedUpdateInput>
  }

  /**
   * Circulo delete
   */
  export type CirculoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    /**
     * Filter which Circulo to delete.
     */
    where: CirculoWhereUniqueInput
  }

  /**
   * Circulo deleteMany
   */
  export type CirculoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Circulos to delete
     */
    where?: CirculoWhereInput
    /**
     * Limit how many Circulos to delete.
     */
    limit?: number
  }

  /**
   * Circulo.tioAparente
   */
  export type Circulo$tioAparenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
  }

  /**
   * Circulo.tioSecreto
   */
  export type Circulo$tioSecretoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
  }

  /**
   * Circulo.encontreiro
   */
  export type Circulo$encontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    cursor?: EncontreiroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * Circulo without action
   */
  export type CirculoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
  }


  /**
   * Model Endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoMinAggregateOutputType = {
    cep: string | null
    estado: string | null
    cidade: string | null
    bairro: string | null
    rua: string | null
    createdAt: Date | null
    modifiedAt: Date | null
  }

  export type EnderecoMaxAggregateOutputType = {
    cep: string | null
    estado: string | null
    cidade: string | null
    bairro: string | null
    rua: string | null
    createdAt: Date | null
    modifiedAt: Date | null
  }

  export type EnderecoCountAggregateOutputType = {
    cep: number
    estado: number
    cidade: number
    bairro: number
    rua: number
    createdAt: number
    modifiedAt: number
    _all: number
  }


  export type EnderecoMinAggregateInputType = {
    cep?: true
    estado?: true
    cidade?: true
    bairro?: true
    rua?: true
    createdAt?: true
    modifiedAt?: true
  }

  export type EnderecoMaxAggregateInputType = {
    cep?: true
    estado?: true
    cidade?: true
    bairro?: true
    rua?: true
    createdAt?: true
    modifiedAt?: true
  }

  export type EnderecoCountAggregateInputType = {
    cep?: true
    estado?: true
    cidade?: true
    bairro?: true
    rua?: true
    createdAt?: true
    modifiedAt?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Endereco to aggregate.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type EnderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnderecoWhereInput
    orderBy?: EnderecoOrderByWithAggregationInput | EnderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: EnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt: Date
    modifiedAt: Date
    _count: EnderecoCountAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends EnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type EnderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cep?: boolean
    estado?: boolean
    cidade?: boolean
    bairro?: boolean
    rua?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
    Encontrista?: boolean | Endereco$EncontristaArgs<ExtArgs>
    local?: boolean | Endereco$localArgs<ExtArgs>
    pessoa?: boolean | Endereco$pessoaArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cep?: boolean
    estado?: boolean
    cidade?: boolean
    bairro?: boolean
    rua?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cep?: boolean
    estado?: boolean
    cidade?: boolean
    bairro?: boolean
    rua?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
  }, ExtArgs["result"]["endereco"]>

  export type EnderecoSelectScalar = {
    cep?: boolean
    estado?: boolean
    cidade?: boolean
    bairro?: boolean
    rua?: boolean
    createdAt?: boolean
    modifiedAt?: boolean
  }

  export type EnderecoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cep" | "estado" | "cidade" | "bairro" | "rua" | "createdAt" | "modifiedAt", ExtArgs["result"]["endereco"]>
  export type EnderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Encontrista?: boolean | Endereco$EncontristaArgs<ExtArgs>
    local?: boolean | Endereco$localArgs<ExtArgs>
    pessoa?: boolean | Endereco$pessoaArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnderecoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EnderecoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EnderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Endereco"
    objects: {
      Encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
      local: Prisma.$LocalPayload<ExtArgs>[]
      pessoa: Prisma.$PessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cep: string
      estado: string
      cidade: string
      bairro: string
      rua: string
      createdAt: Date
      modifiedAt: Date
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }

  type EnderecoGetPayload<S extends boolean | null | undefined | EnderecoDefaultArgs> = $Result.GetResult<Prisma.$EnderecoPayload, S>

  type EnderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnderecoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface EnderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Endereco'], meta: { name: 'Endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {EnderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnderecoFindUniqueArgs>(args: SelectSubset<T, EnderecoFindUniqueArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Endereco that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, EnderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnderecoFindFirstArgs>(args?: SelectSubset<T, EnderecoFindFirstArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, EnderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `cep`
     * const enderecoWithCepOnly = await prisma.endereco.findMany({ select: { cep: true } })
     * 
     */
    findMany<T extends EnderecoFindManyArgs>(args?: SelectSubset<T, EnderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Endereco.
     * @param {EnderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
     */
    create<T extends EnderecoCreateArgs>(args: SelectSubset<T, EnderecoCreateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enderecos.
     * @param {EnderecoCreateManyArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnderecoCreateManyArgs>(args?: SelectSubset<T, EnderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enderecos and returns the data saved in the database.
     * @param {EnderecoCreateManyAndReturnArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enderecos and only return the `cep`
     * const enderecoWithCepOnly = await prisma.endereco.createManyAndReturn({
     *   select: { cep: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnderecoCreateManyAndReturnArgs>(args?: SelectSubset<T, EnderecoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Endereco.
     * @param {EnderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
     */
    delete<T extends EnderecoDeleteArgs>(args: SelectSubset<T, EnderecoDeleteArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Endereco.
     * @param {EnderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnderecoUpdateArgs>(args: SelectSubset<T, EnderecoUpdateArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enderecos.
     * @param {EnderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnderecoDeleteManyArgs>(args?: SelectSubset<T, EnderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnderecoUpdateManyArgs>(args: SelectSubset<T, EnderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos and returns the data updated in the database.
     * @param {EnderecoUpdateManyAndReturnArgs} args - Arguments to update many Enderecos.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enderecos and only return the `cep`
     * const enderecoWithCepOnly = await prisma.endereco.updateManyAndReturn({
     *   select: { cep: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnderecoUpdateManyAndReturnArgs>(args: SelectSubset<T, EnderecoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Endereco.
     * @param {EnderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
     */
    upsert<T extends EnderecoUpsertArgs>(args: SelectSubset<T, EnderecoUpsertArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends EnderecoCountArgs>(
      args?: Subset<T, EnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnderecoGroupByArgs['orderBy'] }
        : { orderBy?: EnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Endereco model
   */
  readonly fields: EnderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Encontrista<T extends Endereco$EncontristaArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$EncontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    local<T extends Endereco$localArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$localArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoa<T extends Endereco$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, Endereco$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Endereco model
   */
  interface EnderecoFieldRefs {
    readonly cep: FieldRef<"Endereco", 'String'>
    readonly estado: FieldRef<"Endereco", 'String'>
    readonly cidade: FieldRef<"Endereco", 'String'>
    readonly bairro: FieldRef<"Endereco", 'String'>
    readonly rua: FieldRef<"Endereco", 'String'>
    readonly createdAt: FieldRef<"Endereco", 'DateTime'>
    readonly modifiedAt: FieldRef<"Endereco", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Endereco findUnique
   */
  export type EnderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findUniqueOrThrow
   */
  export type EnderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco findFirst
   */
  export type EnderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findFirstOrThrow
   */
  export type EnderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Endereco to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco findMany
   */
  export type EnderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter, which Enderecos to fetch.
     */
    where?: EnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enderecos to fetch.
     */
    orderBy?: EnderecoOrderByWithRelationInput | EnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enderecos.
     */
    cursor?: EnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * Endereco create
   */
  export type EnderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a Endereco.
     */
    data: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
  }

  /**
   * Endereco createMany
   */
  export type EnderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endereco createManyAndReturn
   */
  export type EnderecoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to create many Enderecos.
     */
    data: EnderecoCreateManyInput | EnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Endereco update
   */
  export type EnderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a Endereco.
     */
    data: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
    /**
     * Choose, which Endereco to update.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco updateMany
   */
  export type EnderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
  }

  /**
   * Endereco updateManyAndReturn
   */
  export type EnderecoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * The data used to update Enderecos.
     */
    data: XOR<EnderecoUpdateManyMutationInput, EnderecoUncheckedUpdateManyInput>
    /**
     * Filter which Enderecos to update
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to update.
     */
    limit?: number
  }

  /**
   * Endereco upsert
   */
  export type EnderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the Endereco to update in case it exists.
     */
    where: EnderecoWhereUniqueInput
    /**
     * In case the Endereco found by the `where` argument doesn't exist, create a new Endereco with this data.
     */
    create: XOR<EnderecoCreateInput, EnderecoUncheckedCreateInput>
    /**
     * In case the Endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnderecoUpdateInput, EnderecoUncheckedUpdateInput>
  }

  /**
   * Endereco delete
   */
  export type EnderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
    /**
     * Filter which Endereco to delete.
     */
    where: EnderecoWhereUniqueInput
  }

  /**
   * Endereco deleteMany
   */
  export type EnderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enderecos to delete
     */
    where?: EnderecoWhereInput
    /**
     * Limit how many Enderecos to delete.
     */
    limit?: number
  }

  /**
   * Endereco.Encontrista
   */
  export type Endereco$EncontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * Endereco.local
   */
  export type Endereco$localArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    where?: LocalWhereInput
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    cursor?: LocalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Endereco.pessoa
   */
  export type Endereco$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
    orderBy?: PessoaOrderByWithRelationInput | PessoaOrderByWithRelationInput[]
    cursor?: PessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * Endereco without action
   */
  export type EnderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Endereco
     */
    select?: EnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Endereco
     */
    omit?: EnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnderecoInclude<ExtArgs> | null
  }


  /**
   * Model Local
   */

  export type AggregateLocal = {
    _count: LocalCountAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  export type LocalMinAggregateOutputType = {
    id: string | null
    enderecoCep: string | null
    nomeLocal: string | null
    numeroLocal: string | null
  }

  export type LocalMaxAggregateOutputType = {
    id: string | null
    enderecoCep: string | null
    nomeLocal: string | null
    numeroLocal: string | null
  }

  export type LocalCountAggregateOutputType = {
    id: number
    enderecoCep: number
    nomeLocal: number
    numeroLocal: number
    _all: number
  }


  export type LocalMinAggregateInputType = {
    id?: true
    enderecoCep?: true
    nomeLocal?: true
    numeroLocal?: true
  }

  export type LocalMaxAggregateInputType = {
    id?: true
    enderecoCep?: true
    nomeLocal?: true
    numeroLocal?: true
  }

  export type LocalCountAggregateInputType = {
    id?: true
    enderecoCep?: true
    nomeLocal?: true
    numeroLocal?: true
    _all?: true
  }

  export type LocalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Local to aggregate.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locals
    **/
    _count?: true | LocalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalMaxAggregateInputType
  }

  export type GetLocalAggregateType<T extends LocalAggregateArgs> = {
        [P in keyof T & keyof AggregateLocal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocal[P]>
      : GetScalarType<T[P], AggregateLocal[P]>
  }




  export type LocalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalWhereInput
    orderBy?: LocalOrderByWithAggregationInput | LocalOrderByWithAggregationInput[]
    by: LocalScalarFieldEnum[] | LocalScalarFieldEnum
    having?: LocalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalCountAggregateInputType | true
    _min?: LocalMinAggregateInputType
    _max?: LocalMaxAggregateInputType
  }

  export type LocalGroupByOutputType = {
    id: string
    enderecoCep: string
    nomeLocal: string
    numeroLocal: string
    _count: LocalCountAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  type GetLocalGroupByPayload<T extends LocalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalGroupByOutputType[P]>
            : GetScalarType<T[P], LocalGroupByOutputType[P]>
        }
      >
    >


  export type LocalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoCep?: boolean
    nomeLocal?: boolean
    numeroLocal?: boolean
    encontro?: boolean | Local$encontroArgs<ExtArgs>
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    _count?: boolean | LocalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["local"]>

  export type LocalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoCep?: boolean
    nomeLocal?: boolean
    numeroLocal?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["local"]>

  export type LocalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoCep?: boolean
    nomeLocal?: boolean
    numeroLocal?: boolean
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["local"]>

  export type LocalSelectScalar = {
    id?: boolean
    enderecoCep?: boolean
    nomeLocal?: boolean
    numeroLocal?: boolean
  }

  export type LocalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enderecoCep" | "nomeLocal" | "numeroLocal", ExtArgs["result"]["local"]>
  export type LocalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontro?: boolean | Local$encontroArgs<ExtArgs>
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
    _count?: boolean | LocalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }
  export type LocalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | EnderecoDefaultArgs<ExtArgs>
  }

  export type $LocalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Local"
    objects: {
      encontro: Prisma.$EncontroPayload<ExtArgs>[]
      endereco: Prisma.$EnderecoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enderecoCep: string
      nomeLocal: string
      numeroLocal: string
    }, ExtArgs["result"]["local"]>
    composites: {}
  }

  type LocalGetPayload<S extends boolean | null | undefined | LocalDefaultArgs> = $Result.GetResult<Prisma.$LocalPayload, S>

  type LocalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalCountAggregateInputType | true
    }

  export interface LocalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Local'], meta: { name: 'Local' } }
    /**
     * Find zero or one Local that matches the filter.
     * @param {LocalFindUniqueArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalFindUniqueArgs>(args: SelectSubset<T, LocalFindUniqueArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Local that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalFindUniqueOrThrowArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Local that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindFirstArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalFindFirstArgs>(args?: SelectSubset<T, LocalFindFirstArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Local that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindFirstOrThrowArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locals
     * const locals = await prisma.local.findMany()
     * 
     * // Get first 10 Locals
     * const locals = await prisma.local.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localWithIdOnly = await prisma.local.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalFindManyArgs>(args?: SelectSubset<T, LocalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Local.
     * @param {LocalCreateArgs} args - Arguments to create a Local.
     * @example
     * // Create one Local
     * const Local = await prisma.local.create({
     *   data: {
     *     // ... data to create a Local
     *   }
     * })
     * 
     */
    create<T extends LocalCreateArgs>(args: SelectSubset<T, LocalCreateArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locals.
     * @param {LocalCreateManyArgs} args - Arguments to create many Locals.
     * @example
     * // Create many Locals
     * const local = await prisma.local.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalCreateManyArgs>(args?: SelectSubset<T, LocalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locals and returns the data saved in the database.
     * @param {LocalCreateManyAndReturnArgs} args - Arguments to create many Locals.
     * @example
     * // Create many Locals
     * const local = await prisma.local.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locals and only return the `id`
     * const localWithIdOnly = await prisma.local.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Local.
     * @param {LocalDeleteArgs} args - Arguments to delete one Local.
     * @example
     * // Delete one Local
     * const Local = await prisma.local.delete({
     *   where: {
     *     // ... filter to delete one Local
     *   }
     * })
     * 
     */
    delete<T extends LocalDeleteArgs>(args: SelectSubset<T, LocalDeleteArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Local.
     * @param {LocalUpdateArgs} args - Arguments to update one Local.
     * @example
     * // Update one Local
     * const local = await prisma.local.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalUpdateArgs>(args: SelectSubset<T, LocalUpdateArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locals.
     * @param {LocalDeleteManyArgs} args - Arguments to filter Locals to delete.
     * @example
     * // Delete a few Locals
     * const { count } = await prisma.local.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalDeleteManyArgs>(args?: SelectSubset<T, LocalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locals
     * const local = await prisma.local.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalUpdateManyArgs>(args: SelectSubset<T, LocalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locals and returns the data updated in the database.
     * @param {LocalUpdateManyAndReturnArgs} args - Arguments to update many Locals.
     * @example
     * // Update many Locals
     * const local = await prisma.local.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locals and only return the `id`
     * const localWithIdOnly = await prisma.local.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocalUpdateManyAndReturnArgs>(args: SelectSubset<T, LocalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Local.
     * @param {LocalUpsertArgs} args - Arguments to update or create a Local.
     * @example
     * // Update or create a Local
     * const local = await prisma.local.upsert({
     *   create: {
     *     // ... data to create a Local
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Local we want to update
     *   }
     * })
     */
    upsert<T extends LocalUpsertArgs>(args: SelectSubset<T, LocalUpsertArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalCountArgs} args - Arguments to filter Locals to count.
     * @example
     * // Count the number of Locals
     * const count = await prisma.local.count({
     *   where: {
     *     // ... the filter for the Locals we want to count
     *   }
     * })
    **/
    count<T extends LocalCountArgs>(
      args?: Subset<T, LocalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalAggregateArgs>(args: Subset<T, LocalAggregateArgs>): Prisma.PrismaPromise<GetLocalAggregateType<T>>

    /**
     * Group by Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalGroupByArgs['orderBy'] }
        : { orderBy?: LocalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Local model
   */
  readonly fields: LocalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Local.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontro<T extends Local$encontroArgs<ExtArgs> = {}>(args?: Subset<T, Local$encontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    endereco<T extends EnderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnderecoDefaultArgs<ExtArgs>>): Prisma__EnderecoClient<$Result.GetResult<Prisma.$EnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Local model
   */
  interface LocalFieldRefs {
    readonly id: FieldRef<"Local", 'String'>
    readonly enderecoCep: FieldRef<"Local", 'String'>
    readonly nomeLocal: FieldRef<"Local", 'String'>
    readonly numeroLocal: FieldRef<"Local", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Local findUnique
   */
  export type LocalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local findUniqueOrThrow
   */
  export type LocalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local findFirst
   */
  export type LocalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locals.
     */
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local findFirstOrThrow
   */
  export type LocalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locals.
     */
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local findMany
   */
  export type LocalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Locals to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local create
   */
  export type LocalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The data needed to create a Local.
     */
    data: XOR<LocalCreateInput, LocalUncheckedCreateInput>
  }

  /**
   * Local createMany
   */
  export type LocalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locals.
     */
    data: LocalCreateManyInput | LocalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Local createManyAndReturn
   */
  export type LocalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * The data used to create many Locals.
     */
    data: LocalCreateManyInput | LocalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Local update
   */
  export type LocalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The data needed to update a Local.
     */
    data: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
    /**
     * Choose, which Local to update.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local updateMany
   */
  export type LocalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locals.
     */
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyInput>
    /**
     * Filter which Locals to update
     */
    where?: LocalWhereInput
    /**
     * Limit how many Locals to update.
     */
    limit?: number
  }

  /**
   * Local updateManyAndReturn
   */
  export type LocalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * The data used to update Locals.
     */
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyInput>
    /**
     * Filter which Locals to update
     */
    where?: LocalWhereInput
    /**
     * Limit how many Locals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Local upsert
   */
  export type LocalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The filter to search for the Local to update in case it exists.
     */
    where: LocalWhereUniqueInput
    /**
     * In case the Local found by the `where` argument doesn't exist, create a new Local with this data.
     */
    create: XOR<LocalCreateInput, LocalUncheckedCreateInput>
    /**
     * In case the Local was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
  }

  /**
   * Local delete
   */
  export type LocalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter which Local to delete.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local deleteMany
   */
  export type LocalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locals to delete
     */
    where?: LocalWhereInput
    /**
     * Limit how many Locals to delete.
     */
    limit?: number
  }

  /**
   * Local.encontro
   */
  export type Local$encontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontro
     */
    select?: EncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontro
     */
    omit?: EncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontroInclude<ExtArgs> | null
    where?: EncontroWhereInput
    orderBy?: EncontroOrderByWithRelationInput | EncontroOrderByWithRelationInput[]
    cursor?: EncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontroScalarFieldEnum | EncontroScalarFieldEnum[]
  }

  /**
   * Local without action
   */
  export type LocalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
  }


  /**
   * Model Carro
   */

  export type AggregateCarro = {
    _count: CarroCountAggregateOutputType | null
    _avg: CarroAvgAggregateOutputType | null
    _sum: CarroSumAggregateOutputType | null
    _min: CarroMinAggregateOutputType | null
    _max: CarroMaxAggregateOutputType | null
  }

  export type CarroAvgAggregateOutputType = {
    lugaresCarro: number | null
  }

  export type CarroSumAggregateOutputType = {
    lugaresCarro: number | null
  }

  export type CarroMinAggregateOutputType = {
    id: string | null
    idMotorista: string | null
    modeloCarro: string | null
    placaCarro: string | null
    lugaresCarro: number | null
    observacaoMotorista: string | null
    idCarona: string | null
  }

  export type CarroMaxAggregateOutputType = {
    id: string | null
    idMotorista: string | null
    modeloCarro: string | null
    placaCarro: string | null
    lugaresCarro: number | null
    observacaoMotorista: string | null
    idCarona: string | null
  }

  export type CarroCountAggregateOutputType = {
    id: number
    idMotorista: number
    modeloCarro: number
    placaCarro: number
    lugaresCarro: number
    observacaoMotorista: number
    idCarona: number
    _all: number
  }


  export type CarroAvgAggregateInputType = {
    lugaresCarro?: true
  }

  export type CarroSumAggregateInputType = {
    lugaresCarro?: true
  }

  export type CarroMinAggregateInputType = {
    id?: true
    idMotorista?: true
    modeloCarro?: true
    placaCarro?: true
    lugaresCarro?: true
    observacaoMotorista?: true
    idCarona?: true
  }

  export type CarroMaxAggregateInputType = {
    id?: true
    idMotorista?: true
    modeloCarro?: true
    placaCarro?: true
    lugaresCarro?: true
    observacaoMotorista?: true
    idCarona?: true
  }

  export type CarroCountAggregateInputType = {
    id?: true
    idMotorista?: true
    modeloCarro?: true
    placaCarro?: true
    lugaresCarro?: true
    observacaoMotorista?: true
    idCarona?: true
    _all?: true
  }

  export type CarroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carro to aggregate.
     */
    where?: CarroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carros to fetch.
     */
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carros
    **/
    _count?: true | CarroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarroMaxAggregateInputType
  }

  export type GetCarroAggregateType<T extends CarroAggregateArgs> = {
        [P in keyof T & keyof AggregateCarro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarro[P]>
      : GetScalarType<T[P], AggregateCarro[P]>
  }




  export type CarroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroWhereInput
    orderBy?: CarroOrderByWithAggregationInput | CarroOrderByWithAggregationInput[]
    by: CarroScalarFieldEnum[] | CarroScalarFieldEnum
    having?: CarroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarroCountAggregateInputType | true
    _avg?: CarroAvgAggregateInputType
    _sum?: CarroSumAggregateInputType
    _min?: CarroMinAggregateInputType
    _max?: CarroMaxAggregateInputType
  }

  export type CarroGroupByOutputType = {
    id: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona: string | null
    _count: CarroCountAggregateOutputType | null
    _avg: CarroAvgAggregateOutputType | null
    _sum: CarroSumAggregateOutputType | null
    _min: CarroMinAggregateOutputType | null
    _max: CarroMaxAggregateOutputType | null
  }

  type GetCarroGroupByPayload<T extends CarroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarroGroupByOutputType[P]>
            : GetScalarType<T[P], CarroGroupByOutputType[P]>
        }
      >
    >


  export type CarroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idMotorista?: boolean
    modeloCarro?: boolean
    placaCarro?: boolean
    lugaresCarro?: boolean
    observacaoMotorista?: boolean
    idCarona?: boolean
    carroEncontro?: boolean | Carro$carroEncontroArgs<ExtArgs>
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
    _count?: boolean | CarroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carro"]>

  export type CarroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idMotorista?: boolean
    modeloCarro?: boolean
    placaCarro?: boolean
    lugaresCarro?: boolean
    observacaoMotorista?: boolean
    idCarona?: boolean
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carro"]>

  export type CarroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idMotorista?: boolean
    modeloCarro?: boolean
    placaCarro?: boolean
    lugaresCarro?: boolean
    observacaoMotorista?: boolean
    idCarona?: boolean
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carro"]>

  export type CarroSelectScalar = {
    id?: boolean
    idMotorista?: boolean
    modeloCarro?: boolean
    placaCarro?: boolean
    lugaresCarro?: boolean
    observacaoMotorista?: boolean
    idCarona?: boolean
  }

  export type CarroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idMotorista" | "modeloCarro" | "placaCarro" | "lugaresCarro" | "observacaoMotorista" | "idCarona", ExtArgs["result"]["carro"]>
  export type CarroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carroEncontro?: boolean | Carro$carroEncontroArgs<ExtArgs>
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
    _count?: boolean | CarroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type CarroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoaCarona?: boolean | Carro$pessoaCaronaArgs<ExtArgs>
    pessoaMotorista?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $CarroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carro"
    objects: {
      carroEncontro: Prisma.$CarroEncontroPayload<ExtArgs>[]
      pessoaCarona: Prisma.$PessoaPayload<ExtArgs> | null
      pessoaMotorista: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idMotorista: string
      modeloCarro: string
      placaCarro: string
      lugaresCarro: number
      observacaoMotorista: string
      idCarona: string | null
    }, ExtArgs["result"]["carro"]>
    composites: {}
  }

  type CarroGetPayload<S extends boolean | null | undefined | CarroDefaultArgs> = $Result.GetResult<Prisma.$CarroPayload, S>

  type CarroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarroCountAggregateInputType | true
    }

  export interface CarroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carro'], meta: { name: 'Carro' } }
    /**
     * Find zero or one Carro that matches the filter.
     * @param {CarroFindUniqueArgs} args - Arguments to find a Carro
     * @example
     * // Get one Carro
     * const carro = await prisma.carro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarroFindUniqueArgs>(args: SelectSubset<T, CarroFindUniqueArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarroFindUniqueOrThrowArgs} args - Arguments to find a Carro
     * @example
     * // Get one Carro
     * const carro = await prisma.carro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarroFindUniqueOrThrowArgs>(args: SelectSubset<T, CarroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroFindFirstArgs} args - Arguments to find a Carro
     * @example
     * // Get one Carro
     * const carro = await prisma.carro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarroFindFirstArgs>(args?: SelectSubset<T, CarroFindFirstArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroFindFirstOrThrowArgs} args - Arguments to find a Carro
     * @example
     * // Get one Carro
     * const carro = await prisma.carro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarroFindFirstOrThrowArgs>(args?: SelectSubset<T, CarroFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carros
     * const carros = await prisma.carro.findMany()
     * 
     * // Get first 10 Carros
     * const carros = await prisma.carro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carroWithIdOnly = await prisma.carro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarroFindManyArgs>(args?: SelectSubset<T, CarroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carro.
     * @param {CarroCreateArgs} args - Arguments to create a Carro.
     * @example
     * // Create one Carro
     * const Carro = await prisma.carro.create({
     *   data: {
     *     // ... data to create a Carro
     *   }
     * })
     * 
     */
    create<T extends CarroCreateArgs>(args: SelectSubset<T, CarroCreateArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carros.
     * @param {CarroCreateManyArgs} args - Arguments to create many Carros.
     * @example
     * // Create many Carros
     * const carro = await prisma.carro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarroCreateManyArgs>(args?: SelectSubset<T, CarroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carros and returns the data saved in the database.
     * @param {CarroCreateManyAndReturnArgs} args - Arguments to create many Carros.
     * @example
     * // Create many Carros
     * const carro = await prisma.carro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carros and only return the `id`
     * const carroWithIdOnly = await prisma.carro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarroCreateManyAndReturnArgs>(args?: SelectSubset<T, CarroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carro.
     * @param {CarroDeleteArgs} args - Arguments to delete one Carro.
     * @example
     * // Delete one Carro
     * const Carro = await prisma.carro.delete({
     *   where: {
     *     // ... filter to delete one Carro
     *   }
     * })
     * 
     */
    delete<T extends CarroDeleteArgs>(args: SelectSubset<T, CarroDeleteArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carro.
     * @param {CarroUpdateArgs} args - Arguments to update one Carro.
     * @example
     * // Update one Carro
     * const carro = await prisma.carro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarroUpdateArgs>(args: SelectSubset<T, CarroUpdateArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carros.
     * @param {CarroDeleteManyArgs} args - Arguments to filter Carros to delete.
     * @example
     * // Delete a few Carros
     * const { count } = await prisma.carro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarroDeleteManyArgs>(args?: SelectSubset<T, CarroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carros
     * const carro = await prisma.carro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarroUpdateManyArgs>(args: SelectSubset<T, CarroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carros and returns the data updated in the database.
     * @param {CarroUpdateManyAndReturnArgs} args - Arguments to update many Carros.
     * @example
     * // Update many Carros
     * const carro = await prisma.carro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carros and only return the `id`
     * const carroWithIdOnly = await prisma.carro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarroUpdateManyAndReturnArgs>(args: SelectSubset<T, CarroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carro.
     * @param {CarroUpsertArgs} args - Arguments to update or create a Carro.
     * @example
     * // Update or create a Carro
     * const carro = await prisma.carro.upsert({
     *   create: {
     *     // ... data to create a Carro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carro we want to update
     *   }
     * })
     */
    upsert<T extends CarroUpsertArgs>(args: SelectSubset<T, CarroUpsertArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroCountArgs} args - Arguments to filter Carros to count.
     * @example
     * // Count the number of Carros
     * const count = await prisma.carro.count({
     *   where: {
     *     // ... the filter for the Carros we want to count
     *   }
     * })
    **/
    count<T extends CarroCountArgs>(
      args?: Subset<T, CarroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarroAggregateArgs>(args: Subset<T, CarroAggregateArgs>): Prisma.PrismaPromise<GetCarroAggregateType<T>>

    /**
     * Group by Carro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarroGroupByArgs['orderBy'] }
        : { orderBy?: CarroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carro model
   */
  readonly fields: CarroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carroEncontro<T extends Carro$carroEncontroArgs<ExtArgs> = {}>(args?: Subset<T, Carro$carroEncontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoaCarona<T extends Carro$pessoaCaronaArgs<ExtArgs> = {}>(args?: Subset<T, Carro$pessoaCaronaArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pessoaMotorista<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carro model
   */
  interface CarroFieldRefs {
    readonly id: FieldRef<"Carro", 'String'>
    readonly idMotorista: FieldRef<"Carro", 'String'>
    readonly modeloCarro: FieldRef<"Carro", 'String'>
    readonly placaCarro: FieldRef<"Carro", 'String'>
    readonly lugaresCarro: FieldRef<"Carro", 'Int'>
    readonly observacaoMotorista: FieldRef<"Carro", 'String'>
    readonly idCarona: FieldRef<"Carro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Carro findUnique
   */
  export type CarroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter, which Carro to fetch.
     */
    where: CarroWhereUniqueInput
  }

  /**
   * Carro findUniqueOrThrow
   */
  export type CarroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter, which Carro to fetch.
     */
    where: CarroWhereUniqueInput
  }

  /**
   * Carro findFirst
   */
  export type CarroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter, which Carro to fetch.
     */
    where?: CarroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carros to fetch.
     */
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carros.
     */
    cursor?: CarroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carros.
     */
    distinct?: CarroScalarFieldEnum | CarroScalarFieldEnum[]
  }

  /**
   * Carro findFirstOrThrow
   */
  export type CarroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter, which Carro to fetch.
     */
    where?: CarroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carros to fetch.
     */
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carros.
     */
    cursor?: CarroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carros.
     */
    distinct?: CarroScalarFieldEnum | CarroScalarFieldEnum[]
  }

  /**
   * Carro findMany
   */
  export type CarroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter, which Carros to fetch.
     */
    where?: CarroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carros to fetch.
     */
    orderBy?: CarroOrderByWithRelationInput | CarroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carros.
     */
    cursor?: CarroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carros.
     */
    skip?: number
    distinct?: CarroScalarFieldEnum | CarroScalarFieldEnum[]
  }

  /**
   * Carro create
   */
  export type CarroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * The data needed to create a Carro.
     */
    data: XOR<CarroCreateInput, CarroUncheckedCreateInput>
  }

  /**
   * Carro createMany
   */
  export type CarroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carros.
     */
    data: CarroCreateManyInput | CarroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carro createManyAndReturn
   */
  export type CarroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * The data used to create many Carros.
     */
    data: CarroCreateManyInput | CarroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carro update
   */
  export type CarroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * The data needed to update a Carro.
     */
    data: XOR<CarroUpdateInput, CarroUncheckedUpdateInput>
    /**
     * Choose, which Carro to update.
     */
    where: CarroWhereUniqueInput
  }

  /**
   * Carro updateMany
   */
  export type CarroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carros.
     */
    data: XOR<CarroUpdateManyMutationInput, CarroUncheckedUpdateManyInput>
    /**
     * Filter which Carros to update
     */
    where?: CarroWhereInput
    /**
     * Limit how many Carros to update.
     */
    limit?: number
  }

  /**
   * Carro updateManyAndReturn
   */
  export type CarroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * The data used to update Carros.
     */
    data: XOR<CarroUpdateManyMutationInput, CarroUncheckedUpdateManyInput>
    /**
     * Filter which Carros to update
     */
    where?: CarroWhereInput
    /**
     * Limit how many Carros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carro upsert
   */
  export type CarroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * The filter to search for the Carro to update in case it exists.
     */
    where: CarroWhereUniqueInput
    /**
     * In case the Carro found by the `where` argument doesn't exist, create a new Carro with this data.
     */
    create: XOR<CarroCreateInput, CarroUncheckedCreateInput>
    /**
     * In case the Carro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarroUpdateInput, CarroUncheckedUpdateInput>
  }

  /**
   * Carro delete
   */
  export type CarroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
    /**
     * Filter which Carro to delete.
     */
    where: CarroWhereUniqueInput
  }

  /**
   * Carro deleteMany
   */
  export type CarroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carros to delete
     */
    where?: CarroWhereInput
    /**
     * Limit how many Carros to delete.
     */
    limit?: number
  }

  /**
   * Carro.carroEncontro
   */
  export type Carro$carroEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    where?: CarroEncontroWhereInput
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    cursor?: CarroEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * Carro.pessoaCarona
   */
  export type Carro$pessoaCaronaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pessoa
     */
    select?: PessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pessoa
     */
    omit?: PessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PessoaInclude<ExtArgs> | null
    where?: PessoaWhereInput
  }

  /**
   * Carro without action
   */
  export type CarroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carro
     */
    select?: CarroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carro
     */
    omit?: CarroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroInclude<ExtArgs> | null
  }


  /**
   * Model CarroEncontro
   */

  export type AggregateCarroEncontro = {
    _count: CarroEncontroCountAggregateOutputType | null
    _avg: CarroEncontroAvgAggregateOutputType | null
    _sum: CarroEncontroSumAggregateOutputType | null
    _min: CarroEncontroMinAggregateOutputType | null
    _max: CarroEncontroMaxAggregateOutputType | null
  }

  export type CarroEncontroAvgAggregateOutputType = {
    numeroCarro: number | null
  }

  export type CarroEncontroSumAggregateOutputType = {
    numeroCarro: number | null
  }

  export type CarroEncontroMinAggregateOutputType = {
    idCarro: string | null
    idEncontro: string | null
    numeroCarro: number | null
    idExterna: string | null
    id: string | null
    observacao: string | null
  }

  export type CarroEncontroMaxAggregateOutputType = {
    idCarro: string | null
    idEncontro: string | null
    numeroCarro: number | null
    idExterna: string | null
    id: string | null
    observacao: string | null
  }

  export type CarroEncontroCountAggregateOutputType = {
    idCarro: number
    idEncontro: number
    numeroCarro: number
    idExterna: number
    id: number
    observacao: number
    _all: number
  }


  export type CarroEncontroAvgAggregateInputType = {
    numeroCarro?: true
  }

  export type CarroEncontroSumAggregateInputType = {
    numeroCarro?: true
  }

  export type CarroEncontroMinAggregateInputType = {
    idCarro?: true
    idEncontro?: true
    numeroCarro?: true
    idExterna?: true
    id?: true
    observacao?: true
  }

  export type CarroEncontroMaxAggregateInputType = {
    idCarro?: true
    idEncontro?: true
    numeroCarro?: true
    idExterna?: true
    id?: true
    observacao?: true
  }

  export type CarroEncontroCountAggregateInputType = {
    idCarro?: true
    idEncontro?: true
    numeroCarro?: true
    idExterna?: true
    id?: true
    observacao?: true
    _all?: true
  }

  export type CarroEncontroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarroEncontro to aggregate.
     */
    where?: CarroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarroEncontros to fetch.
     */
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarroEncontros
    **/
    _count?: true | CarroEncontroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarroEncontroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarroEncontroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarroEncontroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarroEncontroMaxAggregateInputType
  }

  export type GetCarroEncontroAggregateType<T extends CarroEncontroAggregateArgs> = {
        [P in keyof T & keyof AggregateCarroEncontro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarroEncontro[P]>
      : GetScalarType<T[P], AggregateCarroEncontro[P]>
  }




  export type CarroEncontroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarroEncontroWhereInput
    orderBy?: CarroEncontroOrderByWithAggregationInput | CarroEncontroOrderByWithAggregationInput[]
    by: CarroEncontroScalarFieldEnum[] | CarroEncontroScalarFieldEnum
    having?: CarroEncontroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarroEncontroCountAggregateInputType | true
    _avg?: CarroEncontroAvgAggregateInputType
    _sum?: CarroEncontroSumAggregateInputType
    _min?: CarroEncontroMinAggregateInputType
    _max?: CarroEncontroMaxAggregateInputType
  }

  export type CarroEncontroGroupByOutputType = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    idExterna: string | null
    id: string
    observacao: string | null
    _count: CarroEncontroCountAggregateOutputType | null
    _avg: CarroEncontroAvgAggregateOutputType | null
    _sum: CarroEncontroSumAggregateOutputType | null
    _min: CarroEncontroMinAggregateOutputType | null
    _max: CarroEncontroMaxAggregateOutputType | null
  }

  type GetCarroEncontroGroupByPayload<T extends CarroEncontroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarroEncontroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarroEncontroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarroEncontroGroupByOutputType[P]>
            : GetScalarType<T[P], CarroEncontroGroupByOutputType[P]>
        }
      >
    >


  export type CarroEncontroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCarro?: boolean
    idEncontro?: boolean
    numeroCarro?: boolean
    idExterna?: boolean
    id?: boolean
    observacao?: boolean
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    encontrista?: boolean | CarroEncontro$encontristaArgs<ExtArgs>
    _count?: boolean | CarroEncontroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carroEncontro"]>

  export type CarroEncontroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCarro?: boolean
    idEncontro?: boolean
    numeroCarro?: boolean
    idExterna?: boolean
    id?: boolean
    observacao?: boolean
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carroEncontro"]>

  export type CarroEncontroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCarro?: boolean
    idEncontro?: boolean
    numeroCarro?: boolean
    idExterna?: boolean
    id?: boolean
    observacao?: boolean
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carroEncontro"]>

  export type CarroEncontroSelectScalar = {
    idCarro?: boolean
    idEncontro?: boolean
    numeroCarro?: boolean
    idExterna?: boolean
    id?: boolean
    observacao?: boolean
  }

  export type CarroEncontroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCarro" | "idEncontro" | "numeroCarro" | "idExterna" | "id" | "observacao", ExtArgs["result"]["carroEncontro"]>
  export type CarroEncontroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    encontrista?: boolean | CarroEncontro$encontristaArgs<ExtArgs>
    _count?: boolean | CarroEncontroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarroEncontroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
  }
  export type CarroEncontroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    externa?: boolean | CarroEncontro$externaArgs<ExtArgs>
    carro?: boolean | CarroDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
  }

  export type $CarroEncontroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarroEncontro"
    objects: {
      externa: Prisma.$EncontreiroPayload<ExtArgs> | null
      carro: Prisma.$CarroPayload<ExtArgs>
      encontro: Prisma.$EncontroPayload<ExtArgs>
      encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCarro: string
      idEncontro: string
      numeroCarro: number
      idExterna: string | null
      id: string
      observacao: string | null
    }, ExtArgs["result"]["carroEncontro"]>
    composites: {}
  }

  type CarroEncontroGetPayload<S extends boolean | null | undefined | CarroEncontroDefaultArgs> = $Result.GetResult<Prisma.$CarroEncontroPayload, S>

  type CarroEncontroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CarroEncontroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CarroEncontroCountAggregateInputType | true
    }

  export interface CarroEncontroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarroEncontro'], meta: { name: 'CarroEncontro' } }
    /**
     * Find zero or one CarroEncontro that matches the filter.
     * @param {CarroEncontroFindUniqueArgs} args - Arguments to find a CarroEncontro
     * @example
     * // Get one CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarroEncontroFindUniqueArgs>(args: SelectSubset<T, CarroEncontroFindUniqueArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CarroEncontro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CarroEncontroFindUniqueOrThrowArgs} args - Arguments to find a CarroEncontro
     * @example
     * // Get one CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarroEncontroFindUniqueOrThrowArgs>(args: SelectSubset<T, CarroEncontroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarroEncontro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroFindFirstArgs} args - Arguments to find a CarroEncontro
     * @example
     * // Get one CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarroEncontroFindFirstArgs>(args?: SelectSubset<T, CarroEncontroFindFirstArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CarroEncontro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroFindFirstOrThrowArgs} args - Arguments to find a CarroEncontro
     * @example
     * // Get one CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarroEncontroFindFirstOrThrowArgs>(args?: SelectSubset<T, CarroEncontroFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CarroEncontros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarroEncontros
     * const carroEncontros = await prisma.carroEncontro.findMany()
     * 
     * // Get first 10 CarroEncontros
     * const carroEncontros = await prisma.carroEncontro.findMany({ take: 10 })
     * 
     * // Only select the `idCarro`
     * const carroEncontroWithIdCarroOnly = await prisma.carroEncontro.findMany({ select: { idCarro: true } })
     * 
     */
    findMany<T extends CarroEncontroFindManyArgs>(args?: SelectSubset<T, CarroEncontroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CarroEncontro.
     * @param {CarroEncontroCreateArgs} args - Arguments to create a CarroEncontro.
     * @example
     * // Create one CarroEncontro
     * const CarroEncontro = await prisma.carroEncontro.create({
     *   data: {
     *     // ... data to create a CarroEncontro
     *   }
     * })
     * 
     */
    create<T extends CarroEncontroCreateArgs>(args: SelectSubset<T, CarroEncontroCreateArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CarroEncontros.
     * @param {CarroEncontroCreateManyArgs} args - Arguments to create many CarroEncontros.
     * @example
     * // Create many CarroEncontros
     * const carroEncontro = await prisma.carroEncontro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarroEncontroCreateManyArgs>(args?: SelectSubset<T, CarroEncontroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarroEncontros and returns the data saved in the database.
     * @param {CarroEncontroCreateManyAndReturnArgs} args - Arguments to create many CarroEncontros.
     * @example
     * // Create many CarroEncontros
     * const carroEncontro = await prisma.carroEncontro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarroEncontros and only return the `idCarro`
     * const carroEncontroWithIdCarroOnly = await prisma.carroEncontro.createManyAndReturn({
     *   select: { idCarro: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarroEncontroCreateManyAndReturnArgs>(args?: SelectSubset<T, CarroEncontroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CarroEncontro.
     * @param {CarroEncontroDeleteArgs} args - Arguments to delete one CarroEncontro.
     * @example
     * // Delete one CarroEncontro
     * const CarroEncontro = await prisma.carroEncontro.delete({
     *   where: {
     *     // ... filter to delete one CarroEncontro
     *   }
     * })
     * 
     */
    delete<T extends CarroEncontroDeleteArgs>(args: SelectSubset<T, CarroEncontroDeleteArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CarroEncontro.
     * @param {CarroEncontroUpdateArgs} args - Arguments to update one CarroEncontro.
     * @example
     * // Update one CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarroEncontroUpdateArgs>(args: SelectSubset<T, CarroEncontroUpdateArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CarroEncontros.
     * @param {CarroEncontroDeleteManyArgs} args - Arguments to filter CarroEncontros to delete.
     * @example
     * // Delete a few CarroEncontros
     * const { count } = await prisma.carroEncontro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarroEncontroDeleteManyArgs>(args?: SelectSubset<T, CarroEncontroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarroEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarroEncontros
     * const carroEncontro = await prisma.carroEncontro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarroEncontroUpdateManyArgs>(args: SelectSubset<T, CarroEncontroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarroEncontros and returns the data updated in the database.
     * @param {CarroEncontroUpdateManyAndReturnArgs} args - Arguments to update many CarroEncontros.
     * @example
     * // Update many CarroEncontros
     * const carroEncontro = await prisma.carroEncontro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CarroEncontros and only return the `idCarro`
     * const carroEncontroWithIdCarroOnly = await prisma.carroEncontro.updateManyAndReturn({
     *   select: { idCarro: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CarroEncontroUpdateManyAndReturnArgs>(args: SelectSubset<T, CarroEncontroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CarroEncontro.
     * @param {CarroEncontroUpsertArgs} args - Arguments to update or create a CarroEncontro.
     * @example
     * // Update or create a CarroEncontro
     * const carroEncontro = await prisma.carroEncontro.upsert({
     *   create: {
     *     // ... data to create a CarroEncontro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarroEncontro we want to update
     *   }
     * })
     */
    upsert<T extends CarroEncontroUpsertArgs>(args: SelectSubset<T, CarroEncontroUpsertArgs<ExtArgs>>): Prisma__CarroEncontroClient<$Result.GetResult<Prisma.$CarroEncontroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CarroEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroCountArgs} args - Arguments to filter CarroEncontros to count.
     * @example
     * // Count the number of CarroEncontros
     * const count = await prisma.carroEncontro.count({
     *   where: {
     *     // ... the filter for the CarroEncontros we want to count
     *   }
     * })
    **/
    count<T extends CarroEncontroCountArgs>(
      args?: Subset<T, CarroEncontroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarroEncontroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarroEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarroEncontroAggregateArgs>(args: Subset<T, CarroEncontroAggregateArgs>): Prisma.PrismaPromise<GetCarroEncontroAggregateType<T>>

    /**
     * Group by CarroEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarroEncontroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarroEncontroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarroEncontroGroupByArgs['orderBy'] }
        : { orderBy?: CarroEncontroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarroEncontroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarroEncontroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarroEncontro model
   */
  readonly fields: CarroEncontroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarroEncontro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarroEncontroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    externa<T extends CarroEncontro$externaArgs<ExtArgs> = {}>(args?: Subset<T, CarroEncontro$externaArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    carro<T extends CarroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarroDefaultArgs<ExtArgs>>): Prisma__CarroClient<$Result.GetResult<Prisma.$CarroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encontro<T extends EncontroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontroDefaultArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encontrista<T extends CarroEncontro$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, CarroEncontro$encontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarroEncontro model
   */
  interface CarroEncontroFieldRefs {
    readonly idCarro: FieldRef<"CarroEncontro", 'String'>
    readonly idEncontro: FieldRef<"CarroEncontro", 'String'>
    readonly numeroCarro: FieldRef<"CarroEncontro", 'Int'>
    readonly idExterna: FieldRef<"CarroEncontro", 'String'>
    readonly id: FieldRef<"CarroEncontro", 'String'>
    readonly observacao: FieldRef<"CarroEncontro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CarroEncontro findUnique
   */
  export type CarroEncontroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter, which CarroEncontro to fetch.
     */
    where: CarroEncontroWhereUniqueInput
  }

  /**
   * CarroEncontro findUniqueOrThrow
   */
  export type CarroEncontroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter, which CarroEncontro to fetch.
     */
    where: CarroEncontroWhereUniqueInput
  }

  /**
   * CarroEncontro findFirst
   */
  export type CarroEncontroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter, which CarroEncontro to fetch.
     */
    where?: CarroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarroEncontros to fetch.
     */
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarroEncontros.
     */
    cursor?: CarroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarroEncontros.
     */
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * CarroEncontro findFirstOrThrow
   */
  export type CarroEncontroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter, which CarroEncontro to fetch.
     */
    where?: CarroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarroEncontros to fetch.
     */
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarroEncontros.
     */
    cursor?: CarroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarroEncontros.
     */
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * CarroEncontro findMany
   */
  export type CarroEncontroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter, which CarroEncontros to fetch.
     */
    where?: CarroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarroEncontros to fetch.
     */
    orderBy?: CarroEncontroOrderByWithRelationInput | CarroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarroEncontros.
     */
    cursor?: CarroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarroEncontros.
     */
    skip?: number
    distinct?: CarroEncontroScalarFieldEnum | CarroEncontroScalarFieldEnum[]
  }

  /**
   * CarroEncontro create
   */
  export type CarroEncontroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * The data needed to create a CarroEncontro.
     */
    data: XOR<CarroEncontroCreateInput, CarroEncontroUncheckedCreateInput>
  }

  /**
   * CarroEncontro createMany
   */
  export type CarroEncontroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarroEncontros.
     */
    data: CarroEncontroCreateManyInput | CarroEncontroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarroEncontro createManyAndReturn
   */
  export type CarroEncontroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * The data used to create many CarroEncontros.
     */
    data: CarroEncontroCreateManyInput | CarroEncontroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarroEncontro update
   */
  export type CarroEncontroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * The data needed to update a CarroEncontro.
     */
    data: XOR<CarroEncontroUpdateInput, CarroEncontroUncheckedUpdateInput>
    /**
     * Choose, which CarroEncontro to update.
     */
    where: CarroEncontroWhereUniqueInput
  }

  /**
   * CarroEncontro updateMany
   */
  export type CarroEncontroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarroEncontros.
     */
    data: XOR<CarroEncontroUpdateManyMutationInput, CarroEncontroUncheckedUpdateManyInput>
    /**
     * Filter which CarroEncontros to update
     */
    where?: CarroEncontroWhereInput
    /**
     * Limit how many CarroEncontros to update.
     */
    limit?: number
  }

  /**
   * CarroEncontro updateManyAndReturn
   */
  export type CarroEncontroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * The data used to update CarroEncontros.
     */
    data: XOR<CarroEncontroUpdateManyMutationInput, CarroEncontroUncheckedUpdateManyInput>
    /**
     * Filter which CarroEncontros to update
     */
    where?: CarroEncontroWhereInput
    /**
     * Limit how many CarroEncontros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarroEncontro upsert
   */
  export type CarroEncontroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * The filter to search for the CarroEncontro to update in case it exists.
     */
    where: CarroEncontroWhereUniqueInput
    /**
     * In case the CarroEncontro found by the `where` argument doesn't exist, create a new CarroEncontro with this data.
     */
    create: XOR<CarroEncontroCreateInput, CarroEncontroUncheckedCreateInput>
    /**
     * In case the CarroEncontro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarroEncontroUpdateInput, CarroEncontroUncheckedUpdateInput>
  }

  /**
   * CarroEncontro delete
   */
  export type CarroEncontroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
    /**
     * Filter which CarroEncontro to delete.
     */
    where: CarroEncontroWhereUniqueInput
  }

  /**
   * CarroEncontro deleteMany
   */
  export type CarroEncontroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarroEncontros to delete
     */
    where?: CarroEncontroWhereInput
    /**
     * Limit how many CarroEncontros to delete.
     */
    limit?: number
  }

  /**
   * CarroEncontro.externa
   */
  export type CarroEncontro$externaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
  }

  /**
   * CarroEncontro.encontrista
   */
  export type CarroEncontro$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * CarroEncontro without action
   */
  export type CarroEncontroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarroEncontro
     */
    select?: CarroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CarroEncontro
     */
    omit?: CarroEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarroEncontroInclude<ExtArgs> | null
  }


  /**
   * Model ResponsavelExterna
   */

  export type AggregateResponsavelExterna = {
    _count: ResponsavelExternaCountAggregateOutputType | null
    _min: ResponsavelExternaMinAggregateOutputType | null
    _max: ResponsavelExternaMaxAggregateOutputType | null
  }

  export type ResponsavelExternaMinAggregateOutputType = {
    idExterna: string | null
    idEncontrista: string | null
    idEncontro: string | null
  }

  export type ResponsavelExternaMaxAggregateOutputType = {
    idExterna: string | null
    idEncontrista: string | null
    idEncontro: string | null
  }

  export type ResponsavelExternaCountAggregateOutputType = {
    idExterna: number
    idEncontrista: number
    idEncontro: number
    _all: number
  }


  export type ResponsavelExternaMinAggregateInputType = {
    idExterna?: true
    idEncontrista?: true
    idEncontro?: true
  }

  export type ResponsavelExternaMaxAggregateInputType = {
    idExterna?: true
    idEncontrista?: true
    idEncontro?: true
  }

  export type ResponsavelExternaCountAggregateInputType = {
    idExterna?: true
    idEncontrista?: true
    idEncontro?: true
    _all?: true
  }

  export type ResponsavelExternaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsavelExterna to aggregate.
     */
    where?: ResponsavelExternaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsavelExternas to fetch.
     */
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponsavelExternaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsavelExternas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsavelExternas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponsavelExternas
    **/
    _count?: true | ResponsavelExternaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsavelExternaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsavelExternaMaxAggregateInputType
  }

  export type GetResponsavelExternaAggregateType<T extends ResponsavelExternaAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsavelExterna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsavelExterna[P]>
      : GetScalarType<T[P], AggregateResponsavelExterna[P]>
  }




  export type ResponsavelExternaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponsavelExternaWhereInput
    orderBy?: ResponsavelExternaOrderByWithAggregationInput | ResponsavelExternaOrderByWithAggregationInput[]
    by: ResponsavelExternaScalarFieldEnum[] | ResponsavelExternaScalarFieldEnum
    having?: ResponsavelExternaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsavelExternaCountAggregateInputType | true
    _min?: ResponsavelExternaMinAggregateInputType
    _max?: ResponsavelExternaMaxAggregateInputType
  }

  export type ResponsavelExternaGroupByOutputType = {
    idExterna: string
    idEncontrista: string
    idEncontro: string
    _count: ResponsavelExternaCountAggregateOutputType | null
    _min: ResponsavelExternaMinAggregateOutputType | null
    _max: ResponsavelExternaMaxAggregateOutputType | null
  }

  type GetResponsavelExternaGroupByPayload<T extends ResponsavelExternaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponsavelExternaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsavelExternaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsavelExternaGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsavelExternaGroupByOutputType[P]>
        }
      >
    >


  export type ResponsavelExternaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idExterna?: boolean
    idEncontrista?: boolean
    idEncontro?: boolean
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responsavelExterna"]>

  export type ResponsavelExternaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idExterna?: boolean
    idEncontrista?: boolean
    idEncontro?: boolean
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responsavelExterna"]>

  export type ResponsavelExternaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idExterna?: boolean
    idEncontrista?: boolean
    idEncontro?: boolean
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responsavelExterna"]>

  export type ResponsavelExternaSelectScalar = {
    idExterna?: boolean
    idEncontrista?: boolean
    idEncontro?: boolean
  }

  export type ResponsavelExternaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idExterna" | "idEncontrista" | "idEncontro", ExtArgs["result"]["responsavelExterna"]>
  export type ResponsavelExternaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }
  export type ResponsavelExternaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }
  export type ResponsavelExternaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | EncontristaDefaultArgs<ExtArgs>
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    externa?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }

  export type $ResponsavelExternaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponsavelExterna"
    objects: {
      encontrista: Prisma.$EncontristaPayload<ExtArgs>
      encontro: Prisma.$EncontroPayload<ExtArgs>
      externa: Prisma.$EncontreiroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idExterna: string
      idEncontrista: string
      idEncontro: string
    }, ExtArgs["result"]["responsavelExterna"]>
    composites: {}
  }

  type ResponsavelExternaGetPayload<S extends boolean | null | undefined | ResponsavelExternaDefaultArgs> = $Result.GetResult<Prisma.$ResponsavelExternaPayload, S>

  type ResponsavelExternaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResponsavelExternaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResponsavelExternaCountAggregateInputType | true
    }

  export interface ResponsavelExternaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponsavelExterna'], meta: { name: 'ResponsavelExterna' } }
    /**
     * Find zero or one ResponsavelExterna that matches the filter.
     * @param {ResponsavelExternaFindUniqueArgs} args - Arguments to find a ResponsavelExterna
     * @example
     * // Get one ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponsavelExternaFindUniqueArgs>(args: SelectSubset<T, ResponsavelExternaFindUniqueArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResponsavelExterna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResponsavelExternaFindUniqueOrThrowArgs} args - Arguments to find a ResponsavelExterna
     * @example
     * // Get one ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponsavelExternaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponsavelExternaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsavelExterna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaFindFirstArgs} args - Arguments to find a ResponsavelExterna
     * @example
     * // Get one ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponsavelExternaFindFirstArgs>(args?: SelectSubset<T, ResponsavelExternaFindFirstArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResponsavelExterna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaFindFirstOrThrowArgs} args - Arguments to find a ResponsavelExterna
     * @example
     * // Get one ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponsavelExternaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponsavelExternaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResponsavelExternas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponsavelExternas
     * const responsavelExternas = await prisma.responsavelExterna.findMany()
     * 
     * // Get first 10 ResponsavelExternas
     * const responsavelExternas = await prisma.responsavelExterna.findMany({ take: 10 })
     * 
     * // Only select the `idExterna`
     * const responsavelExternaWithIdExternaOnly = await prisma.responsavelExterna.findMany({ select: { idExterna: true } })
     * 
     */
    findMany<T extends ResponsavelExternaFindManyArgs>(args?: SelectSubset<T, ResponsavelExternaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResponsavelExterna.
     * @param {ResponsavelExternaCreateArgs} args - Arguments to create a ResponsavelExterna.
     * @example
     * // Create one ResponsavelExterna
     * const ResponsavelExterna = await prisma.responsavelExterna.create({
     *   data: {
     *     // ... data to create a ResponsavelExterna
     *   }
     * })
     * 
     */
    create<T extends ResponsavelExternaCreateArgs>(args: SelectSubset<T, ResponsavelExternaCreateArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResponsavelExternas.
     * @param {ResponsavelExternaCreateManyArgs} args - Arguments to create many ResponsavelExternas.
     * @example
     * // Create many ResponsavelExternas
     * const responsavelExterna = await prisma.responsavelExterna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponsavelExternaCreateManyArgs>(args?: SelectSubset<T, ResponsavelExternaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponsavelExternas and returns the data saved in the database.
     * @param {ResponsavelExternaCreateManyAndReturnArgs} args - Arguments to create many ResponsavelExternas.
     * @example
     * // Create many ResponsavelExternas
     * const responsavelExterna = await prisma.responsavelExterna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponsavelExternas and only return the `idExterna`
     * const responsavelExternaWithIdExternaOnly = await prisma.responsavelExterna.createManyAndReturn({
     *   select: { idExterna: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponsavelExternaCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponsavelExternaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResponsavelExterna.
     * @param {ResponsavelExternaDeleteArgs} args - Arguments to delete one ResponsavelExterna.
     * @example
     * // Delete one ResponsavelExterna
     * const ResponsavelExterna = await prisma.responsavelExterna.delete({
     *   where: {
     *     // ... filter to delete one ResponsavelExterna
     *   }
     * })
     * 
     */
    delete<T extends ResponsavelExternaDeleteArgs>(args: SelectSubset<T, ResponsavelExternaDeleteArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResponsavelExterna.
     * @param {ResponsavelExternaUpdateArgs} args - Arguments to update one ResponsavelExterna.
     * @example
     * // Update one ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponsavelExternaUpdateArgs>(args: SelectSubset<T, ResponsavelExternaUpdateArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResponsavelExternas.
     * @param {ResponsavelExternaDeleteManyArgs} args - Arguments to filter ResponsavelExternas to delete.
     * @example
     * // Delete a few ResponsavelExternas
     * const { count } = await prisma.responsavelExterna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponsavelExternaDeleteManyArgs>(args?: SelectSubset<T, ResponsavelExternaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsavelExternas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponsavelExternas
     * const responsavelExterna = await prisma.responsavelExterna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponsavelExternaUpdateManyArgs>(args: SelectSubset<T, ResponsavelExternaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponsavelExternas and returns the data updated in the database.
     * @param {ResponsavelExternaUpdateManyAndReturnArgs} args - Arguments to update many ResponsavelExternas.
     * @example
     * // Update many ResponsavelExternas
     * const responsavelExterna = await prisma.responsavelExterna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResponsavelExternas and only return the `idExterna`
     * const responsavelExternaWithIdExternaOnly = await prisma.responsavelExterna.updateManyAndReturn({
     *   select: { idExterna: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResponsavelExternaUpdateManyAndReturnArgs>(args: SelectSubset<T, ResponsavelExternaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResponsavelExterna.
     * @param {ResponsavelExternaUpsertArgs} args - Arguments to update or create a ResponsavelExterna.
     * @example
     * // Update or create a ResponsavelExterna
     * const responsavelExterna = await prisma.responsavelExterna.upsert({
     *   create: {
     *     // ... data to create a ResponsavelExterna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponsavelExterna we want to update
     *   }
     * })
     */
    upsert<T extends ResponsavelExternaUpsertArgs>(args: SelectSubset<T, ResponsavelExternaUpsertArgs<ExtArgs>>): Prisma__ResponsavelExternaClient<$Result.GetResult<Prisma.$ResponsavelExternaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResponsavelExternas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaCountArgs} args - Arguments to filter ResponsavelExternas to count.
     * @example
     * // Count the number of ResponsavelExternas
     * const count = await prisma.responsavelExterna.count({
     *   where: {
     *     // ... the filter for the ResponsavelExternas we want to count
     *   }
     * })
    **/
    count<T extends ResponsavelExternaCountArgs>(
      args?: Subset<T, ResponsavelExternaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsavelExternaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponsavelExterna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsavelExternaAggregateArgs>(args: Subset<T, ResponsavelExternaAggregateArgs>): Prisma.PrismaPromise<GetResponsavelExternaAggregateType<T>>

    /**
     * Group by ResponsavelExterna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsavelExternaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponsavelExternaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponsavelExternaGroupByArgs['orderBy'] }
        : { orderBy?: ResponsavelExternaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponsavelExternaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsavelExternaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponsavelExterna model
   */
  readonly fields: ResponsavelExternaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponsavelExterna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponsavelExternaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontrista<T extends EncontristaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontristaDefaultArgs<ExtArgs>>): Prisma__EncontristaClient<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encontro<T extends EncontroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontroDefaultArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    externa<T extends EncontreiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontreiroDefaultArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponsavelExterna model
   */
  interface ResponsavelExternaFieldRefs {
    readonly idExterna: FieldRef<"ResponsavelExterna", 'String'>
    readonly idEncontrista: FieldRef<"ResponsavelExterna", 'String'>
    readonly idEncontro: FieldRef<"ResponsavelExterna", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResponsavelExterna findUnique
   */
  export type ResponsavelExternaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter, which ResponsavelExterna to fetch.
     */
    where: ResponsavelExternaWhereUniqueInput
  }

  /**
   * ResponsavelExterna findUniqueOrThrow
   */
  export type ResponsavelExternaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter, which ResponsavelExterna to fetch.
     */
    where: ResponsavelExternaWhereUniqueInput
  }

  /**
   * ResponsavelExterna findFirst
   */
  export type ResponsavelExternaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter, which ResponsavelExterna to fetch.
     */
    where?: ResponsavelExternaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsavelExternas to fetch.
     */
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsavelExternas.
     */
    cursor?: ResponsavelExternaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsavelExternas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsavelExternas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsavelExternas.
     */
    distinct?: ResponsavelExternaScalarFieldEnum | ResponsavelExternaScalarFieldEnum[]
  }

  /**
   * ResponsavelExterna findFirstOrThrow
   */
  export type ResponsavelExternaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter, which ResponsavelExterna to fetch.
     */
    where?: ResponsavelExternaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsavelExternas to fetch.
     */
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponsavelExternas.
     */
    cursor?: ResponsavelExternaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsavelExternas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsavelExternas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponsavelExternas.
     */
    distinct?: ResponsavelExternaScalarFieldEnum | ResponsavelExternaScalarFieldEnum[]
  }

  /**
   * ResponsavelExterna findMany
   */
  export type ResponsavelExternaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter, which ResponsavelExternas to fetch.
     */
    where?: ResponsavelExternaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponsavelExternas to fetch.
     */
    orderBy?: ResponsavelExternaOrderByWithRelationInput | ResponsavelExternaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponsavelExternas.
     */
    cursor?: ResponsavelExternaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponsavelExternas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponsavelExternas.
     */
    skip?: number
    distinct?: ResponsavelExternaScalarFieldEnum | ResponsavelExternaScalarFieldEnum[]
  }

  /**
   * ResponsavelExterna create
   */
  export type ResponsavelExternaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * The data needed to create a ResponsavelExterna.
     */
    data: XOR<ResponsavelExternaCreateInput, ResponsavelExternaUncheckedCreateInput>
  }

  /**
   * ResponsavelExterna createMany
   */
  export type ResponsavelExternaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponsavelExternas.
     */
    data: ResponsavelExternaCreateManyInput | ResponsavelExternaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponsavelExterna createManyAndReturn
   */
  export type ResponsavelExternaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * The data used to create many ResponsavelExternas.
     */
    data: ResponsavelExternaCreateManyInput | ResponsavelExternaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResponsavelExterna update
   */
  export type ResponsavelExternaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * The data needed to update a ResponsavelExterna.
     */
    data: XOR<ResponsavelExternaUpdateInput, ResponsavelExternaUncheckedUpdateInput>
    /**
     * Choose, which ResponsavelExterna to update.
     */
    where: ResponsavelExternaWhereUniqueInput
  }

  /**
   * ResponsavelExterna updateMany
   */
  export type ResponsavelExternaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponsavelExternas.
     */
    data: XOR<ResponsavelExternaUpdateManyMutationInput, ResponsavelExternaUncheckedUpdateManyInput>
    /**
     * Filter which ResponsavelExternas to update
     */
    where?: ResponsavelExternaWhereInput
    /**
     * Limit how many ResponsavelExternas to update.
     */
    limit?: number
  }

  /**
   * ResponsavelExterna updateManyAndReturn
   */
  export type ResponsavelExternaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * The data used to update ResponsavelExternas.
     */
    data: XOR<ResponsavelExternaUpdateManyMutationInput, ResponsavelExternaUncheckedUpdateManyInput>
    /**
     * Filter which ResponsavelExternas to update
     */
    where?: ResponsavelExternaWhereInput
    /**
     * Limit how many ResponsavelExternas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResponsavelExterna upsert
   */
  export type ResponsavelExternaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * The filter to search for the ResponsavelExterna to update in case it exists.
     */
    where: ResponsavelExternaWhereUniqueInput
    /**
     * In case the ResponsavelExterna found by the `where` argument doesn't exist, create a new ResponsavelExterna with this data.
     */
    create: XOR<ResponsavelExternaCreateInput, ResponsavelExternaUncheckedCreateInput>
    /**
     * In case the ResponsavelExterna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponsavelExternaUpdateInput, ResponsavelExternaUncheckedUpdateInput>
  }

  /**
   * ResponsavelExterna delete
   */
  export type ResponsavelExternaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
    /**
     * Filter which ResponsavelExterna to delete.
     */
    where: ResponsavelExternaWhereUniqueInput
  }

  /**
   * ResponsavelExterna deleteMany
   */
  export type ResponsavelExternaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponsavelExternas to delete
     */
    where?: ResponsavelExternaWhereInput
    /**
     * Limit how many ResponsavelExternas to delete.
     */
    limit?: number
  }

  /**
   * ResponsavelExterna without action
   */
  export type ResponsavelExternaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponsavelExterna
     */
    select?: ResponsavelExternaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResponsavelExterna
     */
    omit?: ResponsavelExternaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponsavelExternaInclude<ExtArgs> | null
  }


  /**
   * Model Carta
   */

  export type AggregateCarta = {
    _count: CartaCountAggregateOutputType | null
    _min: CartaMinAggregateOutputType | null
    _max: CartaMaxAggregateOutputType | null
  }

  export type CartaMinAggregateOutputType = {
    id: string | null
    para: string | null
    de: string | null
    conteudo: string | null
    createdAt: Date | null
    slugEncontrista: string | null
    isPrinted: boolean | null
  }

  export type CartaMaxAggregateOutputType = {
    id: string | null
    para: string | null
    de: string | null
    conteudo: string | null
    createdAt: Date | null
    slugEncontrista: string | null
    isPrinted: boolean | null
  }

  export type CartaCountAggregateOutputType = {
    id: number
    para: number
    de: number
    conteudo: number
    createdAt: number
    slugEncontrista: number
    isPrinted: number
    _all: number
  }


  export type CartaMinAggregateInputType = {
    id?: true
    para?: true
    de?: true
    conteudo?: true
    createdAt?: true
    slugEncontrista?: true
    isPrinted?: true
  }

  export type CartaMaxAggregateInputType = {
    id?: true
    para?: true
    de?: true
    conteudo?: true
    createdAt?: true
    slugEncontrista?: true
    isPrinted?: true
  }

  export type CartaCountAggregateInputType = {
    id?: true
    para?: true
    de?: true
    conteudo?: true
    createdAt?: true
    slugEncontrista?: true
    isPrinted?: true
    _all?: true
  }

  export type CartaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carta to aggregate.
     */
    where?: CartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartas to fetch.
     */
    orderBy?: CartaOrderByWithRelationInput | CartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cartas
    **/
    _count?: true | CartaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartaMaxAggregateInputType
  }

  export type GetCartaAggregateType<T extends CartaAggregateArgs> = {
        [P in keyof T & keyof AggregateCarta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarta[P]>
      : GetScalarType<T[P], AggregateCarta[P]>
  }




  export type CartaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartaWhereInput
    orderBy?: CartaOrderByWithAggregationInput | CartaOrderByWithAggregationInput[]
    by: CartaScalarFieldEnum[] | CartaScalarFieldEnum
    having?: CartaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartaCountAggregateInputType | true
    _min?: CartaMinAggregateInputType
    _max?: CartaMaxAggregateInputType
  }

  export type CartaGroupByOutputType = {
    id: string
    para: string
    de: string
    conteudo: string
    createdAt: Date
    slugEncontrista: string
    isPrinted: boolean
    _count: CartaCountAggregateOutputType | null
    _min: CartaMinAggregateOutputType | null
    _max: CartaMaxAggregateOutputType | null
  }

  type GetCartaGroupByPayload<T extends CartaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartaGroupByOutputType[P]>
            : GetScalarType<T[P], CartaGroupByOutputType[P]>
        }
      >
    >


  export type CartaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    de?: boolean
    conteudo?: boolean
    createdAt?: boolean
    slugEncontrista?: boolean
    isPrinted?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carta"]>

  export type CartaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    de?: boolean
    conteudo?: boolean
    createdAt?: boolean
    slugEncontrista?: boolean
    isPrinted?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carta"]>

  export type CartaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    de?: boolean
    conteudo?: boolean
    createdAt?: boolean
    slugEncontrista?: boolean
    isPrinted?: boolean
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carta"]>

  export type CartaSelectScalar = {
    id?: boolean
    para?: boolean
    de?: boolean
    conteudo?: boolean
    createdAt?: boolean
    slugEncontrista?: boolean
    isPrinted?: boolean
  }

  export type CartaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "para" | "de" | "conteudo" | "createdAt" | "slugEncontrista" | "isPrinted", ExtArgs["result"]["carta"]>
  export type CartaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type CartaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type CartaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $CartaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Carta"
    objects: {
      pessoa: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      para: string
      de: string
      conteudo: string
      createdAt: Date
      slugEncontrista: string
      isPrinted: boolean
    }, ExtArgs["result"]["carta"]>
    composites: {}
  }

  type CartaGetPayload<S extends boolean | null | undefined | CartaDefaultArgs> = $Result.GetResult<Prisma.$CartaPayload, S>

  type CartaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartaCountAggregateInputType | true
    }

  export interface CartaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Carta'], meta: { name: 'Carta' } }
    /**
     * Find zero or one Carta that matches the filter.
     * @param {CartaFindUniqueArgs} args - Arguments to find a Carta
     * @example
     * // Get one Carta
     * const carta = await prisma.carta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartaFindUniqueArgs>(args: SelectSubset<T, CartaFindUniqueArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Carta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartaFindUniqueOrThrowArgs} args - Arguments to find a Carta
     * @example
     * // Get one Carta
     * const carta = await prisma.carta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartaFindUniqueOrThrowArgs>(args: SelectSubset<T, CartaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaFindFirstArgs} args - Arguments to find a Carta
     * @example
     * // Get one Carta
     * const carta = await prisma.carta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartaFindFirstArgs>(args?: SelectSubset<T, CartaFindFirstArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Carta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaFindFirstOrThrowArgs} args - Arguments to find a Carta
     * @example
     * // Get one Carta
     * const carta = await prisma.carta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartaFindFirstOrThrowArgs>(args?: SelectSubset<T, CartaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cartas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cartas
     * const cartas = await prisma.carta.findMany()
     * 
     * // Get first 10 Cartas
     * const cartas = await prisma.carta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartaWithIdOnly = await prisma.carta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartaFindManyArgs>(args?: SelectSubset<T, CartaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Carta.
     * @param {CartaCreateArgs} args - Arguments to create a Carta.
     * @example
     * // Create one Carta
     * const Carta = await prisma.carta.create({
     *   data: {
     *     // ... data to create a Carta
     *   }
     * })
     * 
     */
    create<T extends CartaCreateArgs>(args: SelectSubset<T, CartaCreateArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cartas.
     * @param {CartaCreateManyArgs} args - Arguments to create many Cartas.
     * @example
     * // Create many Cartas
     * const carta = await prisma.carta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartaCreateManyArgs>(args?: SelectSubset<T, CartaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cartas and returns the data saved in the database.
     * @param {CartaCreateManyAndReturnArgs} args - Arguments to create many Cartas.
     * @example
     * // Create many Cartas
     * const carta = await prisma.carta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cartas and only return the `id`
     * const cartaWithIdOnly = await prisma.carta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartaCreateManyAndReturnArgs>(args?: SelectSubset<T, CartaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Carta.
     * @param {CartaDeleteArgs} args - Arguments to delete one Carta.
     * @example
     * // Delete one Carta
     * const Carta = await prisma.carta.delete({
     *   where: {
     *     // ... filter to delete one Carta
     *   }
     * })
     * 
     */
    delete<T extends CartaDeleteArgs>(args: SelectSubset<T, CartaDeleteArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Carta.
     * @param {CartaUpdateArgs} args - Arguments to update one Carta.
     * @example
     * // Update one Carta
     * const carta = await prisma.carta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartaUpdateArgs>(args: SelectSubset<T, CartaUpdateArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cartas.
     * @param {CartaDeleteManyArgs} args - Arguments to filter Cartas to delete.
     * @example
     * // Delete a few Cartas
     * const { count } = await prisma.carta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartaDeleteManyArgs>(args?: SelectSubset<T, CartaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cartas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cartas
     * const carta = await prisma.carta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartaUpdateManyArgs>(args: SelectSubset<T, CartaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cartas and returns the data updated in the database.
     * @param {CartaUpdateManyAndReturnArgs} args - Arguments to update many Cartas.
     * @example
     * // Update many Cartas
     * const carta = await prisma.carta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cartas and only return the `id`
     * const cartaWithIdOnly = await prisma.carta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartaUpdateManyAndReturnArgs>(args: SelectSubset<T, CartaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Carta.
     * @param {CartaUpsertArgs} args - Arguments to update or create a Carta.
     * @example
     * // Update or create a Carta
     * const carta = await prisma.carta.upsert({
     *   create: {
     *     // ... data to create a Carta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carta we want to update
     *   }
     * })
     */
    upsert<T extends CartaUpsertArgs>(args: SelectSubset<T, CartaUpsertArgs<ExtArgs>>): Prisma__CartaClient<$Result.GetResult<Prisma.$CartaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cartas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaCountArgs} args - Arguments to filter Cartas to count.
     * @example
     * // Count the number of Cartas
     * const count = await prisma.carta.count({
     *   where: {
     *     // ... the filter for the Cartas we want to count
     *   }
     * })
    **/
    count<T extends CartaCountArgs>(
      args?: Subset<T, CartaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartaAggregateArgs>(args: Subset<T, CartaAggregateArgs>): Prisma.PrismaPromise<GetCartaAggregateType<T>>

    /**
     * Group by Carta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartaGroupByArgs['orderBy'] }
        : { orderBy?: CartaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Carta model
   */
  readonly fields: CartaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Carta model
   */
  interface CartaFieldRefs {
    readonly id: FieldRef<"Carta", 'String'>
    readonly para: FieldRef<"Carta", 'String'>
    readonly de: FieldRef<"Carta", 'String'>
    readonly conteudo: FieldRef<"Carta", 'String'>
    readonly createdAt: FieldRef<"Carta", 'DateTime'>
    readonly slugEncontrista: FieldRef<"Carta", 'String'>
    readonly isPrinted: FieldRef<"Carta", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Carta findUnique
   */
  export type CartaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter, which Carta to fetch.
     */
    where: CartaWhereUniqueInput
  }

  /**
   * Carta findUniqueOrThrow
   */
  export type CartaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter, which Carta to fetch.
     */
    where: CartaWhereUniqueInput
  }

  /**
   * Carta findFirst
   */
  export type CartaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter, which Carta to fetch.
     */
    where?: CartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartas to fetch.
     */
    orderBy?: CartaOrderByWithRelationInput | CartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cartas.
     */
    cursor?: CartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cartas.
     */
    distinct?: CartaScalarFieldEnum | CartaScalarFieldEnum[]
  }

  /**
   * Carta findFirstOrThrow
   */
  export type CartaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter, which Carta to fetch.
     */
    where?: CartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartas to fetch.
     */
    orderBy?: CartaOrderByWithRelationInput | CartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cartas.
     */
    cursor?: CartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cartas.
     */
    distinct?: CartaScalarFieldEnum | CartaScalarFieldEnum[]
  }

  /**
   * Carta findMany
   */
  export type CartaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter, which Cartas to fetch.
     */
    where?: CartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cartas to fetch.
     */
    orderBy?: CartaOrderByWithRelationInput | CartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cartas.
     */
    cursor?: CartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cartas.
     */
    skip?: number
    distinct?: CartaScalarFieldEnum | CartaScalarFieldEnum[]
  }

  /**
   * Carta create
   */
  export type CartaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * The data needed to create a Carta.
     */
    data: XOR<CartaCreateInput, CartaUncheckedCreateInput>
  }

  /**
   * Carta createMany
   */
  export type CartaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cartas.
     */
    data: CartaCreateManyInput | CartaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Carta createManyAndReturn
   */
  export type CartaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * The data used to create many Cartas.
     */
    data: CartaCreateManyInput | CartaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carta update
   */
  export type CartaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * The data needed to update a Carta.
     */
    data: XOR<CartaUpdateInput, CartaUncheckedUpdateInput>
    /**
     * Choose, which Carta to update.
     */
    where: CartaWhereUniqueInput
  }

  /**
   * Carta updateMany
   */
  export type CartaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cartas.
     */
    data: XOR<CartaUpdateManyMutationInput, CartaUncheckedUpdateManyInput>
    /**
     * Filter which Cartas to update
     */
    where?: CartaWhereInput
    /**
     * Limit how many Cartas to update.
     */
    limit?: number
  }

  /**
   * Carta updateManyAndReturn
   */
  export type CartaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * The data used to update Cartas.
     */
    data: XOR<CartaUpdateManyMutationInput, CartaUncheckedUpdateManyInput>
    /**
     * Filter which Cartas to update
     */
    where?: CartaWhereInput
    /**
     * Limit how many Cartas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Carta upsert
   */
  export type CartaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * The filter to search for the Carta to update in case it exists.
     */
    where: CartaWhereUniqueInput
    /**
     * In case the Carta found by the `where` argument doesn't exist, create a new Carta with this data.
     */
    create: XOR<CartaCreateInput, CartaUncheckedCreateInput>
    /**
     * In case the Carta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartaUpdateInput, CartaUncheckedUpdateInput>
  }

  /**
   * Carta delete
   */
  export type CartaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
    /**
     * Filter which Carta to delete.
     */
    where: CartaWhereUniqueInput
  }

  /**
   * Carta deleteMany
   */
  export type CartaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cartas to delete
     */
    where?: CartaWhereInput
    /**
     * Limit how many Cartas to delete.
     */
    limit?: number
  }

  /**
   * Carta without action
   */
  export type CartaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Carta
     */
    select?: CartaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Carta
     */
    omit?: CartaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartaInclude<ExtArgs> | null
  }


  /**
   * Model ListaPreferencia
   */

  export type AggregateListaPreferencia = {
    _count: ListaPreferenciaCountAggregateOutputType | null
    _avg: ListaPreferenciaAvgAggregateOutputType | null
    _sum: ListaPreferenciaSumAggregateOutputType | null
    _min: ListaPreferenciaMinAggregateOutputType | null
    _max: ListaPreferenciaMaxAggregateOutputType | null
  }

  export type ListaPreferenciaAvgAggregateOutputType = {
    posicao: number | null
  }

  export type ListaPreferenciaSumAggregateOutputType = {
    posicao: number | null
  }

  export type ListaPreferenciaMinAggregateOutputType = {
    idPessoa: string | null
    posicao: number | null
    valueEquipe: string | null
  }

  export type ListaPreferenciaMaxAggregateOutputType = {
    idPessoa: string | null
    posicao: number | null
    valueEquipe: string | null
  }

  export type ListaPreferenciaCountAggregateOutputType = {
    idPessoa: number
    posicao: number
    valueEquipe: number
    _all: number
  }


  export type ListaPreferenciaAvgAggregateInputType = {
    posicao?: true
  }

  export type ListaPreferenciaSumAggregateInputType = {
    posicao?: true
  }

  export type ListaPreferenciaMinAggregateInputType = {
    idPessoa?: true
    posicao?: true
    valueEquipe?: true
  }

  export type ListaPreferenciaMaxAggregateInputType = {
    idPessoa?: true
    posicao?: true
    valueEquipe?: true
  }

  export type ListaPreferenciaCountAggregateInputType = {
    idPessoa?: true
    posicao?: true
    valueEquipe?: true
    _all?: true
  }

  export type ListaPreferenciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListaPreferencia to aggregate.
     */
    where?: ListaPreferenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaPreferencias to fetch.
     */
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListaPreferenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaPreferencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaPreferencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListaPreferencias
    **/
    _count?: true | ListaPreferenciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListaPreferenciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListaPreferenciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListaPreferenciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListaPreferenciaMaxAggregateInputType
  }

  export type GetListaPreferenciaAggregateType<T extends ListaPreferenciaAggregateArgs> = {
        [P in keyof T & keyof AggregateListaPreferencia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListaPreferencia[P]>
      : GetScalarType<T[P], AggregateListaPreferencia[P]>
  }




  export type ListaPreferenciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListaPreferenciaWhereInput
    orderBy?: ListaPreferenciaOrderByWithAggregationInput | ListaPreferenciaOrderByWithAggregationInput[]
    by: ListaPreferenciaScalarFieldEnum[] | ListaPreferenciaScalarFieldEnum
    having?: ListaPreferenciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListaPreferenciaCountAggregateInputType | true
    _avg?: ListaPreferenciaAvgAggregateInputType
    _sum?: ListaPreferenciaSumAggregateInputType
    _min?: ListaPreferenciaMinAggregateInputType
    _max?: ListaPreferenciaMaxAggregateInputType
  }

  export type ListaPreferenciaGroupByOutputType = {
    idPessoa: string
    posicao: number
    valueEquipe: string
    _count: ListaPreferenciaCountAggregateOutputType | null
    _avg: ListaPreferenciaAvgAggregateOutputType | null
    _sum: ListaPreferenciaSumAggregateOutputType | null
    _min: ListaPreferenciaMinAggregateOutputType | null
    _max: ListaPreferenciaMaxAggregateOutputType | null
  }

  type GetListaPreferenciaGroupByPayload<T extends ListaPreferenciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListaPreferenciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListaPreferenciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListaPreferenciaGroupByOutputType[P]>
            : GetScalarType<T[P], ListaPreferenciaGroupByOutputType[P]>
        }
      >
    >


  export type ListaPreferenciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    posicao?: boolean
    valueEquipe?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaPreferencia"]>

  export type ListaPreferenciaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    posicao?: boolean
    valueEquipe?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaPreferencia"]>

  export type ListaPreferenciaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    posicao?: boolean
    valueEquipe?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listaPreferencia"]>

  export type ListaPreferenciaSelectScalar = {
    idPessoa?: boolean
    posicao?: boolean
    valueEquipe?: boolean
  }

  export type ListaPreferenciaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPessoa" | "posicao" | "valueEquipe", ExtArgs["result"]["listaPreferencia"]>
  export type ListaPreferenciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }
  export type ListaPreferenciaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }
  export type ListaPreferenciaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }

  export type $ListaPreferenciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListaPreferencia"
    objects: {
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>
      equipe: Prisma.$DomainEquipesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPessoa: string
      posicao: number
      valueEquipe: string
    }, ExtArgs["result"]["listaPreferencia"]>
    composites: {}
  }

  type ListaPreferenciaGetPayload<S extends boolean | null | undefined | ListaPreferenciaDefaultArgs> = $Result.GetResult<Prisma.$ListaPreferenciaPayload, S>

  type ListaPreferenciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListaPreferenciaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListaPreferenciaCountAggregateInputType | true
    }

  export interface ListaPreferenciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListaPreferencia'], meta: { name: 'ListaPreferencia' } }
    /**
     * Find zero or one ListaPreferencia that matches the filter.
     * @param {ListaPreferenciaFindUniqueArgs} args - Arguments to find a ListaPreferencia
     * @example
     * // Get one ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListaPreferenciaFindUniqueArgs>(args: SelectSubset<T, ListaPreferenciaFindUniqueArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ListaPreferencia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListaPreferenciaFindUniqueOrThrowArgs} args - Arguments to find a ListaPreferencia
     * @example
     * // Get one ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListaPreferenciaFindUniqueOrThrowArgs>(args: SelectSubset<T, ListaPreferenciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListaPreferencia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaFindFirstArgs} args - Arguments to find a ListaPreferencia
     * @example
     * // Get one ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListaPreferenciaFindFirstArgs>(args?: SelectSubset<T, ListaPreferenciaFindFirstArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ListaPreferencia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaFindFirstOrThrowArgs} args - Arguments to find a ListaPreferencia
     * @example
     * // Get one ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListaPreferenciaFindFirstOrThrowArgs>(args?: SelectSubset<T, ListaPreferenciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ListaPreferencias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListaPreferencias
     * const listaPreferencias = await prisma.listaPreferencia.findMany()
     * 
     * // Get first 10 ListaPreferencias
     * const listaPreferencias = await prisma.listaPreferencia.findMany({ take: 10 })
     * 
     * // Only select the `idPessoa`
     * const listaPreferenciaWithIdPessoaOnly = await prisma.listaPreferencia.findMany({ select: { idPessoa: true } })
     * 
     */
    findMany<T extends ListaPreferenciaFindManyArgs>(args?: SelectSubset<T, ListaPreferenciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ListaPreferencia.
     * @param {ListaPreferenciaCreateArgs} args - Arguments to create a ListaPreferencia.
     * @example
     * // Create one ListaPreferencia
     * const ListaPreferencia = await prisma.listaPreferencia.create({
     *   data: {
     *     // ... data to create a ListaPreferencia
     *   }
     * })
     * 
     */
    create<T extends ListaPreferenciaCreateArgs>(args: SelectSubset<T, ListaPreferenciaCreateArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ListaPreferencias.
     * @param {ListaPreferenciaCreateManyArgs} args - Arguments to create many ListaPreferencias.
     * @example
     * // Create many ListaPreferencias
     * const listaPreferencia = await prisma.listaPreferencia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListaPreferenciaCreateManyArgs>(args?: SelectSubset<T, ListaPreferenciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListaPreferencias and returns the data saved in the database.
     * @param {ListaPreferenciaCreateManyAndReturnArgs} args - Arguments to create many ListaPreferencias.
     * @example
     * // Create many ListaPreferencias
     * const listaPreferencia = await prisma.listaPreferencia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListaPreferencias and only return the `idPessoa`
     * const listaPreferenciaWithIdPessoaOnly = await prisma.listaPreferencia.createManyAndReturn({
     *   select: { idPessoa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListaPreferenciaCreateManyAndReturnArgs>(args?: SelectSubset<T, ListaPreferenciaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ListaPreferencia.
     * @param {ListaPreferenciaDeleteArgs} args - Arguments to delete one ListaPreferencia.
     * @example
     * // Delete one ListaPreferencia
     * const ListaPreferencia = await prisma.listaPreferencia.delete({
     *   where: {
     *     // ... filter to delete one ListaPreferencia
     *   }
     * })
     * 
     */
    delete<T extends ListaPreferenciaDeleteArgs>(args: SelectSubset<T, ListaPreferenciaDeleteArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ListaPreferencia.
     * @param {ListaPreferenciaUpdateArgs} args - Arguments to update one ListaPreferencia.
     * @example
     * // Update one ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListaPreferenciaUpdateArgs>(args: SelectSubset<T, ListaPreferenciaUpdateArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ListaPreferencias.
     * @param {ListaPreferenciaDeleteManyArgs} args - Arguments to filter ListaPreferencias to delete.
     * @example
     * // Delete a few ListaPreferencias
     * const { count } = await prisma.listaPreferencia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListaPreferenciaDeleteManyArgs>(args?: SelectSubset<T, ListaPreferenciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListaPreferencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListaPreferencias
     * const listaPreferencia = await prisma.listaPreferencia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListaPreferenciaUpdateManyArgs>(args: SelectSubset<T, ListaPreferenciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListaPreferencias and returns the data updated in the database.
     * @param {ListaPreferenciaUpdateManyAndReturnArgs} args - Arguments to update many ListaPreferencias.
     * @example
     * // Update many ListaPreferencias
     * const listaPreferencia = await prisma.listaPreferencia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ListaPreferencias and only return the `idPessoa`
     * const listaPreferenciaWithIdPessoaOnly = await prisma.listaPreferencia.updateManyAndReturn({
     *   select: { idPessoa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListaPreferenciaUpdateManyAndReturnArgs>(args: SelectSubset<T, ListaPreferenciaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ListaPreferencia.
     * @param {ListaPreferenciaUpsertArgs} args - Arguments to update or create a ListaPreferencia.
     * @example
     * // Update or create a ListaPreferencia
     * const listaPreferencia = await prisma.listaPreferencia.upsert({
     *   create: {
     *     // ... data to create a ListaPreferencia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListaPreferencia we want to update
     *   }
     * })
     */
    upsert<T extends ListaPreferenciaUpsertArgs>(args: SelectSubset<T, ListaPreferenciaUpsertArgs<ExtArgs>>): Prisma__ListaPreferenciaClient<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ListaPreferencias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaCountArgs} args - Arguments to filter ListaPreferencias to count.
     * @example
     * // Count the number of ListaPreferencias
     * const count = await prisma.listaPreferencia.count({
     *   where: {
     *     // ... the filter for the ListaPreferencias we want to count
     *   }
     * })
    **/
    count<T extends ListaPreferenciaCountArgs>(
      args?: Subset<T, ListaPreferenciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListaPreferenciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListaPreferencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListaPreferenciaAggregateArgs>(args: Subset<T, ListaPreferenciaAggregateArgs>): Prisma.PrismaPromise<GetListaPreferenciaAggregateType<T>>

    /**
     * Group by ListaPreferencia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListaPreferenciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListaPreferenciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListaPreferenciaGroupByArgs['orderBy'] }
        : { orderBy?: ListaPreferenciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListaPreferenciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListaPreferenciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListaPreferencia model
   */
  readonly fields: ListaPreferenciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListaPreferencia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListaPreferenciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontreiro<T extends EncontreiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontreiroDefaultArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipe<T extends DomainEquipesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipesDefaultArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListaPreferencia model
   */
  interface ListaPreferenciaFieldRefs {
    readonly idPessoa: FieldRef<"ListaPreferencia", 'String'>
    readonly posicao: FieldRef<"ListaPreferencia", 'Int'>
    readonly valueEquipe: FieldRef<"ListaPreferencia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ListaPreferencia findUnique
   */
  export type ListaPreferenciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter, which ListaPreferencia to fetch.
     */
    where: ListaPreferenciaWhereUniqueInput
  }

  /**
   * ListaPreferencia findUniqueOrThrow
   */
  export type ListaPreferenciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter, which ListaPreferencia to fetch.
     */
    where: ListaPreferenciaWhereUniqueInput
  }

  /**
   * ListaPreferencia findFirst
   */
  export type ListaPreferenciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter, which ListaPreferencia to fetch.
     */
    where?: ListaPreferenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaPreferencias to fetch.
     */
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListaPreferencias.
     */
    cursor?: ListaPreferenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaPreferencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaPreferencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListaPreferencias.
     */
    distinct?: ListaPreferenciaScalarFieldEnum | ListaPreferenciaScalarFieldEnum[]
  }

  /**
   * ListaPreferencia findFirstOrThrow
   */
  export type ListaPreferenciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter, which ListaPreferencia to fetch.
     */
    where?: ListaPreferenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaPreferencias to fetch.
     */
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListaPreferencias.
     */
    cursor?: ListaPreferenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaPreferencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaPreferencias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListaPreferencias.
     */
    distinct?: ListaPreferenciaScalarFieldEnum | ListaPreferenciaScalarFieldEnum[]
  }

  /**
   * ListaPreferencia findMany
   */
  export type ListaPreferenciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter, which ListaPreferencias to fetch.
     */
    where?: ListaPreferenciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListaPreferencias to fetch.
     */
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListaPreferencias.
     */
    cursor?: ListaPreferenciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListaPreferencias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListaPreferencias.
     */
    skip?: number
    distinct?: ListaPreferenciaScalarFieldEnum | ListaPreferenciaScalarFieldEnum[]
  }

  /**
   * ListaPreferencia create
   */
  export type ListaPreferenciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * The data needed to create a ListaPreferencia.
     */
    data: XOR<ListaPreferenciaCreateInput, ListaPreferenciaUncheckedCreateInput>
  }

  /**
   * ListaPreferencia createMany
   */
  export type ListaPreferenciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListaPreferencias.
     */
    data: ListaPreferenciaCreateManyInput | ListaPreferenciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListaPreferencia createManyAndReturn
   */
  export type ListaPreferenciaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * The data used to create many ListaPreferencias.
     */
    data: ListaPreferenciaCreateManyInput | ListaPreferenciaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListaPreferencia update
   */
  export type ListaPreferenciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * The data needed to update a ListaPreferencia.
     */
    data: XOR<ListaPreferenciaUpdateInput, ListaPreferenciaUncheckedUpdateInput>
    /**
     * Choose, which ListaPreferencia to update.
     */
    where: ListaPreferenciaWhereUniqueInput
  }

  /**
   * ListaPreferencia updateMany
   */
  export type ListaPreferenciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListaPreferencias.
     */
    data: XOR<ListaPreferenciaUpdateManyMutationInput, ListaPreferenciaUncheckedUpdateManyInput>
    /**
     * Filter which ListaPreferencias to update
     */
    where?: ListaPreferenciaWhereInput
    /**
     * Limit how many ListaPreferencias to update.
     */
    limit?: number
  }

  /**
   * ListaPreferencia updateManyAndReturn
   */
  export type ListaPreferenciaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * The data used to update ListaPreferencias.
     */
    data: XOR<ListaPreferenciaUpdateManyMutationInput, ListaPreferenciaUncheckedUpdateManyInput>
    /**
     * Filter which ListaPreferencias to update
     */
    where?: ListaPreferenciaWhereInput
    /**
     * Limit how many ListaPreferencias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListaPreferencia upsert
   */
  export type ListaPreferenciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * The filter to search for the ListaPreferencia to update in case it exists.
     */
    where: ListaPreferenciaWhereUniqueInput
    /**
     * In case the ListaPreferencia found by the `where` argument doesn't exist, create a new ListaPreferencia with this data.
     */
    create: XOR<ListaPreferenciaCreateInput, ListaPreferenciaUncheckedCreateInput>
    /**
     * In case the ListaPreferencia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListaPreferenciaUpdateInput, ListaPreferenciaUncheckedUpdateInput>
  }

  /**
   * ListaPreferencia delete
   */
  export type ListaPreferenciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    /**
     * Filter which ListaPreferencia to delete.
     */
    where: ListaPreferenciaWhereUniqueInput
  }

  /**
   * ListaPreferencia deleteMany
   */
  export type ListaPreferenciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListaPreferencias to delete
     */
    where?: ListaPreferenciaWhereInput
    /**
     * Limit how many ListaPreferencias to delete.
     */
    limit?: number
  }

  /**
   * ListaPreferencia without action
   */
  export type ListaPreferenciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
  }


  /**
   * Model EquipeEncontro
   */

  export type AggregateEquipeEncontro = {
    _count: EquipeEncontroCountAggregateOutputType | null
    _min: EquipeEncontroMinAggregateOutputType | null
    _max: EquipeEncontroMaxAggregateOutputType | null
  }

  export type EquipeEncontroMinAggregateOutputType = {
    idPessoa: string | null
    idEncontro: string | null
    idEquipe: string | null
    coordenou: boolean | null
    fichaPreenchida: boolean | null
  }

  export type EquipeEncontroMaxAggregateOutputType = {
    idPessoa: string | null
    idEncontro: string | null
    idEquipe: string | null
    coordenou: boolean | null
    fichaPreenchida: boolean | null
  }

  export type EquipeEncontroCountAggregateOutputType = {
    idPessoa: number
    idEncontro: number
    idEquipe: number
    coordenou: number
    fichaPreenchida: number
    _all: number
  }


  export type EquipeEncontroMinAggregateInputType = {
    idPessoa?: true
    idEncontro?: true
    idEquipe?: true
    coordenou?: true
    fichaPreenchida?: true
  }

  export type EquipeEncontroMaxAggregateInputType = {
    idPessoa?: true
    idEncontro?: true
    idEquipe?: true
    coordenou?: true
    fichaPreenchida?: true
  }

  export type EquipeEncontroCountAggregateInputType = {
    idPessoa?: true
    idEncontro?: true
    idEquipe?: true
    coordenou?: true
    fichaPreenchida?: true
    _all?: true
  }

  export type EquipeEncontroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipeEncontro to aggregate.
     */
    where?: EquipeEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeEncontros to fetch.
     */
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipeEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipeEncontros
    **/
    _count?: true | EquipeEncontroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipeEncontroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipeEncontroMaxAggregateInputType
  }

  export type GetEquipeEncontroAggregateType<T extends EquipeEncontroAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipeEncontro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipeEncontro[P]>
      : GetScalarType<T[P], AggregateEquipeEncontro[P]>
  }




  export type EquipeEncontroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeEncontroWhereInput
    orderBy?: EquipeEncontroOrderByWithAggregationInput | EquipeEncontroOrderByWithAggregationInput[]
    by: EquipeEncontroScalarFieldEnum[] | EquipeEncontroScalarFieldEnum
    having?: EquipeEncontroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipeEncontroCountAggregateInputType | true
    _min?: EquipeEncontroMinAggregateInputType
    _max?: EquipeEncontroMaxAggregateInputType
  }

  export type EquipeEncontroGroupByOutputType = {
    idPessoa: string
    idEncontro: string
    idEquipe: string
    coordenou: boolean
    fichaPreenchida: boolean
    _count: EquipeEncontroCountAggregateOutputType | null
    _min: EquipeEncontroMinAggregateOutputType | null
    _max: EquipeEncontroMaxAggregateOutputType | null
  }

  type GetEquipeEncontroGroupByPayload<T extends EquipeEncontroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipeEncontroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipeEncontroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipeEncontroGroupByOutputType[P]>
            : GetScalarType<T[P], EquipeEncontroGroupByOutputType[P]>
        }
      >
    >


  export type EquipeEncontroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    idEncontro?: boolean
    idEquipe?: boolean
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeEncontro"]>

  export type EquipeEncontroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    idEncontro?: boolean
    idEquipe?: boolean
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeEncontro"]>

  export type EquipeEncontroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPessoa?: boolean
    idEncontro?: boolean
    idEquipe?: boolean
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeEncontro"]>

  export type EquipeEncontroSelectScalar = {
    idPessoa?: boolean
    idEncontro?: boolean
    idEquipe?: boolean
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPessoa" | "idEncontro" | "idEquipe" | "coordenou" | "fichaPreenchida", ExtArgs["result"]["equipeEncontro"]>
  export type EquipeEncontroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }
  export type EquipeEncontroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }
  export type EquipeEncontroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontro?: boolean | EncontroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
  }

  export type $EquipeEncontroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipeEncontro"
    objects: {
      encontro: Prisma.$EncontroPayload<ExtArgs>
      equipe: Prisma.$DomainEquipesPayload<ExtArgs>
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPessoa: string
      idEncontro: string
      idEquipe: string
      coordenou: boolean
      fichaPreenchida: boolean
    }, ExtArgs["result"]["equipeEncontro"]>
    composites: {}
  }

  type EquipeEncontroGetPayload<S extends boolean | null | undefined | EquipeEncontroDefaultArgs> = $Result.GetResult<Prisma.$EquipeEncontroPayload, S>

  type EquipeEncontroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipeEncontroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipeEncontroCountAggregateInputType | true
    }

  export interface EquipeEncontroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipeEncontro'], meta: { name: 'EquipeEncontro' } }
    /**
     * Find zero or one EquipeEncontro that matches the filter.
     * @param {EquipeEncontroFindUniqueArgs} args - Arguments to find a EquipeEncontro
     * @example
     * // Get one EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipeEncontroFindUniqueArgs>(args: SelectSubset<T, EquipeEncontroFindUniqueArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipeEncontro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipeEncontroFindUniqueOrThrowArgs} args - Arguments to find a EquipeEncontro
     * @example
     * // Get one EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipeEncontroFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipeEncontroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeEncontro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroFindFirstArgs} args - Arguments to find a EquipeEncontro
     * @example
     * // Get one EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipeEncontroFindFirstArgs>(args?: SelectSubset<T, EquipeEncontroFindFirstArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeEncontro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroFindFirstOrThrowArgs} args - Arguments to find a EquipeEncontro
     * @example
     * // Get one EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipeEncontroFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipeEncontroFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipeEncontros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipeEncontros
     * const equipeEncontros = await prisma.equipeEncontro.findMany()
     * 
     * // Get first 10 EquipeEncontros
     * const equipeEncontros = await prisma.equipeEncontro.findMany({ take: 10 })
     * 
     * // Only select the `idPessoa`
     * const equipeEncontroWithIdPessoaOnly = await prisma.equipeEncontro.findMany({ select: { idPessoa: true } })
     * 
     */
    findMany<T extends EquipeEncontroFindManyArgs>(args?: SelectSubset<T, EquipeEncontroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipeEncontro.
     * @param {EquipeEncontroCreateArgs} args - Arguments to create a EquipeEncontro.
     * @example
     * // Create one EquipeEncontro
     * const EquipeEncontro = await prisma.equipeEncontro.create({
     *   data: {
     *     // ... data to create a EquipeEncontro
     *   }
     * })
     * 
     */
    create<T extends EquipeEncontroCreateArgs>(args: SelectSubset<T, EquipeEncontroCreateArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipeEncontros.
     * @param {EquipeEncontroCreateManyArgs} args - Arguments to create many EquipeEncontros.
     * @example
     * // Create many EquipeEncontros
     * const equipeEncontro = await prisma.equipeEncontro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipeEncontroCreateManyArgs>(args?: SelectSubset<T, EquipeEncontroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipeEncontros and returns the data saved in the database.
     * @param {EquipeEncontroCreateManyAndReturnArgs} args - Arguments to create many EquipeEncontros.
     * @example
     * // Create many EquipeEncontros
     * const equipeEncontro = await prisma.equipeEncontro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipeEncontros and only return the `idPessoa`
     * const equipeEncontroWithIdPessoaOnly = await prisma.equipeEncontro.createManyAndReturn({
     *   select: { idPessoa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipeEncontroCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipeEncontroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipeEncontro.
     * @param {EquipeEncontroDeleteArgs} args - Arguments to delete one EquipeEncontro.
     * @example
     * // Delete one EquipeEncontro
     * const EquipeEncontro = await prisma.equipeEncontro.delete({
     *   where: {
     *     // ... filter to delete one EquipeEncontro
     *   }
     * })
     * 
     */
    delete<T extends EquipeEncontroDeleteArgs>(args: SelectSubset<T, EquipeEncontroDeleteArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipeEncontro.
     * @param {EquipeEncontroUpdateArgs} args - Arguments to update one EquipeEncontro.
     * @example
     * // Update one EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipeEncontroUpdateArgs>(args: SelectSubset<T, EquipeEncontroUpdateArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipeEncontros.
     * @param {EquipeEncontroDeleteManyArgs} args - Arguments to filter EquipeEncontros to delete.
     * @example
     * // Delete a few EquipeEncontros
     * const { count } = await prisma.equipeEncontro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipeEncontroDeleteManyArgs>(args?: SelectSubset<T, EquipeEncontroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipeEncontros
     * const equipeEncontro = await prisma.equipeEncontro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipeEncontroUpdateManyArgs>(args: SelectSubset<T, EquipeEncontroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeEncontros and returns the data updated in the database.
     * @param {EquipeEncontroUpdateManyAndReturnArgs} args - Arguments to update many EquipeEncontros.
     * @example
     * // Update many EquipeEncontros
     * const equipeEncontro = await prisma.equipeEncontro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipeEncontros and only return the `idPessoa`
     * const equipeEncontroWithIdPessoaOnly = await prisma.equipeEncontro.updateManyAndReturn({
     *   select: { idPessoa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipeEncontroUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipeEncontroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipeEncontro.
     * @param {EquipeEncontroUpsertArgs} args - Arguments to update or create a EquipeEncontro.
     * @example
     * // Update or create a EquipeEncontro
     * const equipeEncontro = await prisma.equipeEncontro.upsert({
     *   create: {
     *     // ... data to create a EquipeEncontro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipeEncontro we want to update
     *   }
     * })
     */
    upsert<T extends EquipeEncontroUpsertArgs>(args: SelectSubset<T, EquipeEncontroUpsertArgs<ExtArgs>>): Prisma__EquipeEncontroClient<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipeEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroCountArgs} args - Arguments to filter EquipeEncontros to count.
     * @example
     * // Count the number of EquipeEncontros
     * const count = await prisma.equipeEncontro.count({
     *   where: {
     *     // ... the filter for the EquipeEncontros we want to count
     *   }
     * })
    **/
    count<T extends EquipeEncontroCountArgs>(
      args?: Subset<T, EquipeEncontroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipeEncontroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipeEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipeEncontroAggregateArgs>(args: Subset<T, EquipeEncontroAggregateArgs>): Prisma.PrismaPromise<GetEquipeEncontroAggregateType<T>>

    /**
     * Group by EquipeEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeEncontroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipeEncontroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipeEncontroGroupByArgs['orderBy'] }
        : { orderBy?: EquipeEncontroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipeEncontroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipeEncontroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipeEncontro model
   */
  readonly fields: EquipeEncontroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipeEncontro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipeEncontroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontro<T extends EncontroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontroDefaultArgs<ExtArgs>>): Prisma__EncontroClient<$Result.GetResult<Prisma.$EncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipe<T extends DomainEquipesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipesDefaultArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encontreiro<T extends EncontreiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontreiroDefaultArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipeEncontro model
   */
  interface EquipeEncontroFieldRefs {
    readonly idPessoa: FieldRef<"EquipeEncontro", 'String'>
    readonly idEncontro: FieldRef<"EquipeEncontro", 'String'>
    readonly idEquipe: FieldRef<"EquipeEncontro", 'String'>
    readonly coordenou: FieldRef<"EquipeEncontro", 'Boolean'>
    readonly fichaPreenchida: FieldRef<"EquipeEncontro", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EquipeEncontro findUnique
   */
  export type EquipeEncontroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter, which EquipeEncontro to fetch.
     */
    where: EquipeEncontroWhereUniqueInput
  }

  /**
   * EquipeEncontro findUniqueOrThrow
   */
  export type EquipeEncontroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter, which EquipeEncontro to fetch.
     */
    where: EquipeEncontroWhereUniqueInput
  }

  /**
   * EquipeEncontro findFirst
   */
  export type EquipeEncontroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter, which EquipeEncontro to fetch.
     */
    where?: EquipeEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeEncontros to fetch.
     */
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipeEncontros.
     */
    cursor?: EquipeEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipeEncontros.
     */
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * EquipeEncontro findFirstOrThrow
   */
  export type EquipeEncontroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter, which EquipeEncontro to fetch.
     */
    where?: EquipeEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeEncontros to fetch.
     */
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipeEncontros.
     */
    cursor?: EquipeEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipeEncontros.
     */
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * EquipeEncontro findMany
   */
  export type EquipeEncontroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter, which EquipeEncontros to fetch.
     */
    where?: EquipeEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeEncontros to fetch.
     */
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipeEncontros.
     */
    cursor?: EquipeEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeEncontros.
     */
    skip?: number
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * EquipeEncontro create
   */
  export type EquipeEncontroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipeEncontro.
     */
    data: XOR<EquipeEncontroCreateInput, EquipeEncontroUncheckedCreateInput>
  }

  /**
   * EquipeEncontro createMany
   */
  export type EquipeEncontroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipeEncontros.
     */
    data: EquipeEncontroCreateManyInput | EquipeEncontroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipeEncontro createManyAndReturn
   */
  export type EquipeEncontroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * The data used to create many EquipeEncontros.
     */
    data: EquipeEncontroCreateManyInput | EquipeEncontroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipeEncontro update
   */
  export type EquipeEncontroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipeEncontro.
     */
    data: XOR<EquipeEncontroUpdateInput, EquipeEncontroUncheckedUpdateInput>
    /**
     * Choose, which EquipeEncontro to update.
     */
    where: EquipeEncontroWhereUniqueInput
  }

  /**
   * EquipeEncontro updateMany
   */
  export type EquipeEncontroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipeEncontros.
     */
    data: XOR<EquipeEncontroUpdateManyMutationInput, EquipeEncontroUncheckedUpdateManyInput>
    /**
     * Filter which EquipeEncontros to update
     */
    where?: EquipeEncontroWhereInput
    /**
     * Limit how many EquipeEncontros to update.
     */
    limit?: number
  }

  /**
   * EquipeEncontro updateManyAndReturn
   */
  export type EquipeEncontroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * The data used to update EquipeEncontros.
     */
    data: XOR<EquipeEncontroUpdateManyMutationInput, EquipeEncontroUncheckedUpdateManyInput>
    /**
     * Filter which EquipeEncontros to update
     */
    where?: EquipeEncontroWhereInput
    /**
     * Limit how many EquipeEncontros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipeEncontro upsert
   */
  export type EquipeEncontroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipeEncontro to update in case it exists.
     */
    where: EquipeEncontroWhereUniqueInput
    /**
     * In case the EquipeEncontro found by the `where` argument doesn't exist, create a new EquipeEncontro with this data.
     */
    create: XOR<EquipeEncontroCreateInput, EquipeEncontroUncheckedCreateInput>
    /**
     * In case the EquipeEncontro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipeEncontroUpdateInput, EquipeEncontroUncheckedUpdateInput>
  }

  /**
   * EquipeEncontro delete
   */
  export type EquipeEncontroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    /**
     * Filter which EquipeEncontro to delete.
     */
    where: EquipeEncontroWhereUniqueInput
  }

  /**
   * EquipeEncontro deleteMany
   */
  export type EquipeEncontroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipeEncontros to delete
     */
    where?: EquipeEncontroWhereInput
    /**
     * Limit how many EquipeEncontros to delete.
     */
    limit?: number
  }

  /**
   * EquipeEncontro without action
   */
  export type EquipeEncontroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
  }


  /**
   * Model EquipeMontagem
   */

  export type AggregateEquipeMontagem = {
    _count: EquipeMontagemCountAggregateOutputType | null
    _min: EquipeMontagemMinAggregateOutputType | null
    _max: EquipeMontagemMaxAggregateOutputType | null
  }

  export type EquipeMontagemMinAggregateOutputType = {
    valueEquipe: string | null
    coordenando: boolean | null
    idEncontreiro: string | null
  }

  export type EquipeMontagemMaxAggregateOutputType = {
    valueEquipe: string | null
    coordenando: boolean | null
    idEncontreiro: string | null
  }

  export type EquipeMontagemCountAggregateOutputType = {
    valueEquipe: number
    coordenando: number
    idEncontreiro: number
    _all: number
  }


  export type EquipeMontagemMinAggregateInputType = {
    valueEquipe?: true
    coordenando?: true
    idEncontreiro?: true
  }

  export type EquipeMontagemMaxAggregateInputType = {
    valueEquipe?: true
    coordenando?: true
    idEncontreiro?: true
  }

  export type EquipeMontagemCountAggregateInputType = {
    valueEquipe?: true
    coordenando?: true
    idEncontreiro?: true
    _all?: true
  }

  export type EquipeMontagemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipeMontagem to aggregate.
     */
    where?: EquipeMontagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeMontagems to fetch.
     */
    orderBy?: EquipeMontagemOrderByWithRelationInput | EquipeMontagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipeMontagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeMontagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeMontagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipeMontagems
    **/
    _count?: true | EquipeMontagemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipeMontagemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipeMontagemMaxAggregateInputType
  }

  export type GetEquipeMontagemAggregateType<T extends EquipeMontagemAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipeMontagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipeMontagem[P]>
      : GetScalarType<T[P], AggregateEquipeMontagem[P]>
  }




  export type EquipeMontagemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipeMontagemWhereInput
    orderBy?: EquipeMontagemOrderByWithAggregationInput | EquipeMontagemOrderByWithAggregationInput[]
    by: EquipeMontagemScalarFieldEnum[] | EquipeMontagemScalarFieldEnum
    having?: EquipeMontagemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipeMontagemCountAggregateInputType | true
    _min?: EquipeMontagemMinAggregateInputType
    _max?: EquipeMontagemMaxAggregateInputType
  }

  export type EquipeMontagemGroupByOutputType = {
    valueEquipe: string
    coordenando: boolean
    idEncontreiro: string
    _count: EquipeMontagemCountAggregateOutputType | null
    _min: EquipeMontagemMinAggregateOutputType | null
    _max: EquipeMontagemMaxAggregateOutputType | null
  }

  type GetEquipeMontagemGroupByPayload<T extends EquipeMontagemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipeMontagemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipeMontagemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipeMontagemGroupByOutputType[P]>
            : GetScalarType<T[P], EquipeMontagemGroupByOutputType[P]>
        }
      >
    >


  export type EquipeMontagemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    valueEquipe?: boolean
    coordenando?: boolean
    idEncontreiro?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeMontagem"]>

  export type EquipeMontagemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    valueEquipe?: boolean
    coordenando?: boolean
    idEncontreiro?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeMontagem"]>

  export type EquipeMontagemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    valueEquipe?: boolean
    coordenando?: boolean
    idEncontreiro?: boolean
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeMontagem"]>

  export type EquipeMontagemSelectScalar = {
    valueEquipe?: boolean
    coordenando?: boolean
    idEncontreiro?: boolean
  }

  export type EquipeMontagemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"valueEquipe" | "coordenando" | "idEncontreiro", ExtArgs["result"]["equipeMontagem"]>
  export type EquipeMontagemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }
  export type EquipeMontagemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }
  export type EquipeMontagemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | EncontreiroDefaultArgs<ExtArgs>
    equipe?: boolean | DomainEquipesDefaultArgs<ExtArgs>
  }

  export type $EquipeMontagemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipeMontagem"
    objects: {
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>
      equipe: Prisma.$DomainEquipesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      valueEquipe: string
      coordenando: boolean
      idEncontreiro: string
    }, ExtArgs["result"]["equipeMontagem"]>
    composites: {}
  }

  type EquipeMontagemGetPayload<S extends boolean | null | undefined | EquipeMontagemDefaultArgs> = $Result.GetResult<Prisma.$EquipeMontagemPayload, S>

  type EquipeMontagemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipeMontagemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipeMontagemCountAggregateInputType | true
    }

  export interface EquipeMontagemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipeMontagem'], meta: { name: 'EquipeMontagem' } }
    /**
     * Find zero or one EquipeMontagem that matches the filter.
     * @param {EquipeMontagemFindUniqueArgs} args - Arguments to find a EquipeMontagem
     * @example
     * // Get one EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipeMontagemFindUniqueArgs>(args: SelectSubset<T, EquipeMontagemFindUniqueArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipeMontagem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipeMontagemFindUniqueOrThrowArgs} args - Arguments to find a EquipeMontagem
     * @example
     * // Get one EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipeMontagemFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipeMontagemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeMontagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemFindFirstArgs} args - Arguments to find a EquipeMontagem
     * @example
     * // Get one EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipeMontagemFindFirstArgs>(args?: SelectSubset<T, EquipeMontagemFindFirstArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeMontagem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemFindFirstOrThrowArgs} args - Arguments to find a EquipeMontagem
     * @example
     * // Get one EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipeMontagemFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipeMontagemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipeMontagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipeMontagems
     * const equipeMontagems = await prisma.equipeMontagem.findMany()
     * 
     * // Get first 10 EquipeMontagems
     * const equipeMontagems = await prisma.equipeMontagem.findMany({ take: 10 })
     * 
     * // Only select the `valueEquipe`
     * const equipeMontagemWithValueEquipeOnly = await prisma.equipeMontagem.findMany({ select: { valueEquipe: true } })
     * 
     */
    findMany<T extends EquipeMontagemFindManyArgs>(args?: SelectSubset<T, EquipeMontagemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipeMontagem.
     * @param {EquipeMontagemCreateArgs} args - Arguments to create a EquipeMontagem.
     * @example
     * // Create one EquipeMontagem
     * const EquipeMontagem = await prisma.equipeMontagem.create({
     *   data: {
     *     // ... data to create a EquipeMontagem
     *   }
     * })
     * 
     */
    create<T extends EquipeMontagemCreateArgs>(args: SelectSubset<T, EquipeMontagemCreateArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipeMontagems.
     * @param {EquipeMontagemCreateManyArgs} args - Arguments to create many EquipeMontagems.
     * @example
     * // Create many EquipeMontagems
     * const equipeMontagem = await prisma.equipeMontagem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipeMontagemCreateManyArgs>(args?: SelectSubset<T, EquipeMontagemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipeMontagems and returns the data saved in the database.
     * @param {EquipeMontagemCreateManyAndReturnArgs} args - Arguments to create many EquipeMontagems.
     * @example
     * // Create many EquipeMontagems
     * const equipeMontagem = await prisma.equipeMontagem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipeMontagems and only return the `valueEquipe`
     * const equipeMontagemWithValueEquipeOnly = await prisma.equipeMontagem.createManyAndReturn({
     *   select: { valueEquipe: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipeMontagemCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipeMontagemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipeMontagem.
     * @param {EquipeMontagemDeleteArgs} args - Arguments to delete one EquipeMontagem.
     * @example
     * // Delete one EquipeMontagem
     * const EquipeMontagem = await prisma.equipeMontagem.delete({
     *   where: {
     *     // ... filter to delete one EquipeMontagem
     *   }
     * })
     * 
     */
    delete<T extends EquipeMontagemDeleteArgs>(args: SelectSubset<T, EquipeMontagemDeleteArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipeMontagem.
     * @param {EquipeMontagemUpdateArgs} args - Arguments to update one EquipeMontagem.
     * @example
     * // Update one EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipeMontagemUpdateArgs>(args: SelectSubset<T, EquipeMontagemUpdateArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipeMontagems.
     * @param {EquipeMontagemDeleteManyArgs} args - Arguments to filter EquipeMontagems to delete.
     * @example
     * // Delete a few EquipeMontagems
     * const { count } = await prisma.equipeMontagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipeMontagemDeleteManyArgs>(args?: SelectSubset<T, EquipeMontagemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeMontagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipeMontagems
     * const equipeMontagem = await prisma.equipeMontagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipeMontagemUpdateManyArgs>(args: SelectSubset<T, EquipeMontagemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeMontagems and returns the data updated in the database.
     * @param {EquipeMontagemUpdateManyAndReturnArgs} args - Arguments to update many EquipeMontagems.
     * @example
     * // Update many EquipeMontagems
     * const equipeMontagem = await prisma.equipeMontagem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipeMontagems and only return the `valueEquipe`
     * const equipeMontagemWithValueEquipeOnly = await prisma.equipeMontagem.updateManyAndReturn({
     *   select: { valueEquipe: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipeMontagemUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipeMontagemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipeMontagem.
     * @param {EquipeMontagemUpsertArgs} args - Arguments to update or create a EquipeMontagem.
     * @example
     * // Update or create a EquipeMontagem
     * const equipeMontagem = await prisma.equipeMontagem.upsert({
     *   create: {
     *     // ... data to create a EquipeMontagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipeMontagem we want to update
     *   }
     * })
     */
    upsert<T extends EquipeMontagemUpsertArgs>(args: SelectSubset<T, EquipeMontagemUpsertArgs<ExtArgs>>): Prisma__EquipeMontagemClient<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipeMontagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemCountArgs} args - Arguments to filter EquipeMontagems to count.
     * @example
     * // Count the number of EquipeMontagems
     * const count = await prisma.equipeMontagem.count({
     *   where: {
     *     // ... the filter for the EquipeMontagems we want to count
     *   }
     * })
    **/
    count<T extends EquipeMontagemCountArgs>(
      args?: Subset<T, EquipeMontagemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipeMontagemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipeMontagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipeMontagemAggregateArgs>(args: Subset<T, EquipeMontagemAggregateArgs>): Prisma.PrismaPromise<GetEquipeMontagemAggregateType<T>>

    /**
     * Group by EquipeMontagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeMontagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipeMontagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipeMontagemGroupByArgs['orderBy'] }
        : { orderBy?: EquipeMontagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipeMontagemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipeMontagemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipeMontagem model
   */
  readonly fields: EquipeMontagemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipeMontagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipeMontagemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontreiro<T extends EncontreiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncontreiroDefaultArgs<ExtArgs>>): Prisma__EncontreiroClient<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipe<T extends DomainEquipesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipesDefaultArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipeMontagem model
   */
  interface EquipeMontagemFieldRefs {
    readonly valueEquipe: FieldRef<"EquipeMontagem", 'String'>
    readonly coordenando: FieldRef<"EquipeMontagem", 'Boolean'>
    readonly idEncontreiro: FieldRef<"EquipeMontagem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EquipeMontagem findUnique
   */
  export type EquipeMontagemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter, which EquipeMontagem to fetch.
     */
    where: EquipeMontagemWhereUniqueInput
  }

  /**
   * EquipeMontagem findUniqueOrThrow
   */
  export type EquipeMontagemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter, which EquipeMontagem to fetch.
     */
    where: EquipeMontagemWhereUniqueInput
  }

  /**
   * EquipeMontagem findFirst
   */
  export type EquipeMontagemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter, which EquipeMontagem to fetch.
     */
    where?: EquipeMontagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeMontagems to fetch.
     */
    orderBy?: EquipeMontagemOrderByWithRelationInput | EquipeMontagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipeMontagems.
     */
    cursor?: EquipeMontagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeMontagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeMontagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipeMontagems.
     */
    distinct?: EquipeMontagemScalarFieldEnum | EquipeMontagemScalarFieldEnum[]
  }

  /**
   * EquipeMontagem findFirstOrThrow
   */
  export type EquipeMontagemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter, which EquipeMontagem to fetch.
     */
    where?: EquipeMontagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeMontagems to fetch.
     */
    orderBy?: EquipeMontagemOrderByWithRelationInput | EquipeMontagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipeMontagems.
     */
    cursor?: EquipeMontagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeMontagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeMontagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipeMontagems.
     */
    distinct?: EquipeMontagemScalarFieldEnum | EquipeMontagemScalarFieldEnum[]
  }

  /**
   * EquipeMontagem findMany
   */
  export type EquipeMontagemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter, which EquipeMontagems to fetch.
     */
    where?: EquipeMontagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipeMontagems to fetch.
     */
    orderBy?: EquipeMontagemOrderByWithRelationInput | EquipeMontagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipeMontagems.
     */
    cursor?: EquipeMontagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipeMontagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipeMontagems.
     */
    skip?: number
    distinct?: EquipeMontagemScalarFieldEnum | EquipeMontagemScalarFieldEnum[]
  }

  /**
   * EquipeMontagem create
   */
  export type EquipeMontagemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipeMontagem.
     */
    data: XOR<EquipeMontagemCreateInput, EquipeMontagemUncheckedCreateInput>
  }

  /**
   * EquipeMontagem createMany
   */
  export type EquipeMontagemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipeMontagems.
     */
    data: EquipeMontagemCreateManyInput | EquipeMontagemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipeMontagem createManyAndReturn
   */
  export type EquipeMontagemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * The data used to create many EquipeMontagems.
     */
    data: EquipeMontagemCreateManyInput | EquipeMontagemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipeMontagem update
   */
  export type EquipeMontagemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipeMontagem.
     */
    data: XOR<EquipeMontagemUpdateInput, EquipeMontagemUncheckedUpdateInput>
    /**
     * Choose, which EquipeMontagem to update.
     */
    where: EquipeMontagemWhereUniqueInput
  }

  /**
   * EquipeMontagem updateMany
   */
  export type EquipeMontagemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipeMontagems.
     */
    data: XOR<EquipeMontagemUpdateManyMutationInput, EquipeMontagemUncheckedUpdateManyInput>
    /**
     * Filter which EquipeMontagems to update
     */
    where?: EquipeMontagemWhereInput
    /**
     * Limit how many EquipeMontagems to update.
     */
    limit?: number
  }

  /**
   * EquipeMontagem updateManyAndReturn
   */
  export type EquipeMontagemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * The data used to update EquipeMontagems.
     */
    data: XOR<EquipeMontagemUpdateManyMutationInput, EquipeMontagemUncheckedUpdateManyInput>
    /**
     * Filter which EquipeMontagems to update
     */
    where?: EquipeMontagemWhereInput
    /**
     * Limit how many EquipeMontagems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipeMontagem upsert
   */
  export type EquipeMontagemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipeMontagem to update in case it exists.
     */
    where: EquipeMontagemWhereUniqueInput
    /**
     * In case the EquipeMontagem found by the `where` argument doesn't exist, create a new EquipeMontagem with this data.
     */
    create: XOR<EquipeMontagemCreateInput, EquipeMontagemUncheckedCreateInput>
    /**
     * In case the EquipeMontagem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipeMontagemUpdateInput, EquipeMontagemUncheckedUpdateInput>
  }

  /**
   * EquipeMontagem delete
   */
  export type EquipeMontagemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    /**
     * Filter which EquipeMontagem to delete.
     */
    where: EquipeMontagemWhereUniqueInput
  }

  /**
   * EquipeMontagem deleteMany
   */
  export type EquipeMontagemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipeMontagems to delete
     */
    where?: EquipeMontagemWhereInput
    /**
     * Limit how many EquipeMontagems to delete.
     */
    limit?: number
  }

  /**
   * EquipeMontagem without action
   */
  export type EquipeMontagemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
  }


  /**
   * Model DomainStatus
   */

  export type AggregateDomainStatus = {
    _count: DomainStatusCountAggregateOutputType | null
    _min: DomainStatusMinAggregateOutputType | null
    _max: DomainStatusMaxAggregateOutputType | null
  }

  export type DomainStatusMinAggregateOutputType = {
    id: $Enums.Value_Status | null
    status: string | null
  }

  export type DomainStatusMaxAggregateOutputType = {
    id: $Enums.Value_Status | null
    status: string | null
  }

  export type DomainStatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type DomainStatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type DomainStatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type DomainStatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type DomainStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainStatus to aggregate.
     */
    where?: DomainStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatuses to fetch.
     */
    orderBy?: DomainStatusOrderByWithRelationInput | DomainStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainStatuses
    **/
    _count?: true | DomainStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainStatusMaxAggregateInputType
  }

  export type GetDomainStatusAggregateType<T extends DomainStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainStatus[P]>
      : GetScalarType<T[P], AggregateDomainStatus[P]>
  }




  export type DomainStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainStatusWhereInput
    orderBy?: DomainStatusOrderByWithAggregationInput | DomainStatusOrderByWithAggregationInput[]
    by: DomainStatusScalarFieldEnum[] | DomainStatusScalarFieldEnum
    having?: DomainStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainStatusCountAggregateInputType | true
    _min?: DomainStatusMinAggregateInputType
    _max?: DomainStatusMaxAggregateInputType
  }

  export type DomainStatusGroupByOutputType = {
    id: $Enums.Value_Status
    status: string
    _count: DomainStatusCountAggregateOutputType | null
    _min: DomainStatusMinAggregateOutputType | null
    _max: DomainStatusMaxAggregateOutputType | null
  }

  type GetDomainStatusGroupByPayload<T extends DomainStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainStatusGroupByOutputType[P]>
            : GetScalarType<T[P], DomainStatusGroupByOutputType[P]>
        }
      >
    >


  export type DomainStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    encontrista?: boolean | DomainStatus$encontristaArgs<ExtArgs>
    _count?: boolean | DomainStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainStatus"]>

  export type DomainStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
  }, ExtArgs["result"]["domainStatus"]>

  export type DomainStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
  }, ExtArgs["result"]["domainStatus"]>

  export type DomainStatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type DomainStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["domainStatus"]>
  export type DomainStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainStatus$encontristaArgs<ExtArgs>
    _count?: boolean | DomainStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainStatus"
    objects: {
      encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_Status
      status: string
    }, ExtArgs["result"]["domainStatus"]>
    composites: {}
  }

  type DomainStatusGetPayload<S extends boolean | null | undefined | DomainStatusDefaultArgs> = $Result.GetResult<Prisma.$DomainStatusPayload, S>

  type DomainStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainStatusCountAggregateInputType | true
    }

  export interface DomainStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainStatus'], meta: { name: 'DomainStatus' } }
    /**
     * Find zero or one DomainStatus that matches the filter.
     * @param {DomainStatusFindUniqueArgs} args - Arguments to find a DomainStatus
     * @example
     * // Get one DomainStatus
     * const domainStatus = await prisma.domainStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainStatusFindUniqueArgs>(args: SelectSubset<T, DomainStatusFindUniqueArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainStatusFindUniqueOrThrowArgs} args - Arguments to find a DomainStatus
     * @example
     * // Get one DomainStatus
     * const domainStatus = await prisma.domainStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusFindFirstArgs} args - Arguments to find a DomainStatus
     * @example
     * // Get one DomainStatus
     * const domainStatus = await prisma.domainStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainStatusFindFirstArgs>(args?: SelectSubset<T, DomainStatusFindFirstArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusFindFirstOrThrowArgs} args - Arguments to find a DomainStatus
     * @example
     * // Get one DomainStatus
     * const domainStatus = await prisma.domainStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainStatuses
     * const domainStatuses = await prisma.domainStatus.findMany()
     * 
     * // Get first 10 DomainStatuses
     * const domainStatuses = await prisma.domainStatus.findMany({ take: 10 })
     * 
     * // Only select the `status`
     * const domainStatusWithStatusOnly = await prisma.domainStatus.findMany({ select: { status: true } })
     * 
     */
    findMany<T extends DomainStatusFindManyArgs>(args?: SelectSubset<T, DomainStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainStatus.
     * @param {DomainStatusCreateArgs} args - Arguments to create a DomainStatus.
     * @example
     * // Create one DomainStatus
     * const DomainStatus = await prisma.domainStatus.create({
     *   data: {
     *     // ... data to create a DomainStatus
     *   }
     * })
     * 
     */
    create<T extends DomainStatusCreateArgs>(args: SelectSubset<T, DomainStatusCreateArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainStatuses.
     * @param {DomainStatusCreateManyArgs} args - Arguments to create many DomainStatuses.
     * @example
     * // Create many DomainStatuses
     * const domainStatus = await prisma.domainStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainStatusCreateManyArgs>(args?: SelectSubset<T, DomainStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainStatuses and returns the data saved in the database.
     * @param {DomainStatusCreateManyAndReturnArgs} args - Arguments to create many DomainStatuses.
     * @example
     * // Create many DomainStatuses
     * const domainStatus = await prisma.domainStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainStatuses and only return the `status`
     * const domainStatusWithStatusOnly = await prisma.domainStatus.createManyAndReturn({
     *   select: { status: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainStatus.
     * @param {DomainStatusDeleteArgs} args - Arguments to delete one DomainStatus.
     * @example
     * // Delete one DomainStatus
     * const DomainStatus = await prisma.domainStatus.delete({
     *   where: {
     *     // ... filter to delete one DomainStatus
     *   }
     * })
     * 
     */
    delete<T extends DomainStatusDeleteArgs>(args: SelectSubset<T, DomainStatusDeleteArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainStatus.
     * @param {DomainStatusUpdateArgs} args - Arguments to update one DomainStatus.
     * @example
     * // Update one DomainStatus
     * const domainStatus = await prisma.domainStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainStatusUpdateArgs>(args: SelectSubset<T, DomainStatusUpdateArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainStatuses.
     * @param {DomainStatusDeleteManyArgs} args - Arguments to filter DomainStatuses to delete.
     * @example
     * // Delete a few DomainStatuses
     * const { count } = await prisma.domainStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainStatusDeleteManyArgs>(args?: SelectSubset<T, DomainStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainStatuses
     * const domainStatus = await prisma.domainStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainStatusUpdateManyArgs>(args: SelectSubset<T, DomainStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainStatuses and returns the data updated in the database.
     * @param {DomainStatusUpdateManyAndReturnArgs} args - Arguments to update many DomainStatuses.
     * @example
     * // Update many DomainStatuses
     * const domainStatus = await prisma.domainStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainStatuses and only return the `status`
     * const domainStatusWithStatusOnly = await prisma.domainStatus.updateManyAndReturn({
     *   select: { status: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainStatus.
     * @param {DomainStatusUpsertArgs} args - Arguments to update or create a DomainStatus.
     * @example
     * // Update or create a DomainStatus
     * const domainStatus = await prisma.domainStatus.upsert({
     *   create: {
     *     // ... data to create a DomainStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainStatus we want to update
     *   }
     * })
     */
    upsert<T extends DomainStatusUpsertArgs>(args: SelectSubset<T, DomainStatusUpsertArgs<ExtArgs>>): Prisma__DomainStatusClient<$Result.GetResult<Prisma.$DomainStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusCountArgs} args - Arguments to filter DomainStatuses to count.
     * @example
     * // Count the number of DomainStatuses
     * const count = await prisma.domainStatus.count({
     *   where: {
     *     // ... the filter for the DomainStatuses we want to count
     *   }
     * })
    **/
    count<T extends DomainStatusCountArgs>(
      args?: Subset<T, DomainStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainStatusAggregateArgs>(args: Subset<T, DomainStatusAggregateArgs>): Prisma.PrismaPromise<GetDomainStatusAggregateType<T>>

    /**
     * Group by DomainStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainStatusGroupByArgs['orderBy'] }
        : { orderBy?: DomainStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainStatus model
   */
  readonly fields: DomainStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontrista<T extends DomainStatus$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, DomainStatus$encontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainStatus model
   */
  interface DomainStatusFieldRefs {
    readonly id: FieldRef<"DomainStatus", 'Value_Status'>
    readonly status: FieldRef<"DomainStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainStatus findUnique
   */
  export type DomainStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatus to fetch.
     */
    where: DomainStatusWhereUniqueInput
  }

  /**
   * DomainStatus findUniqueOrThrow
   */
  export type DomainStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatus to fetch.
     */
    where: DomainStatusWhereUniqueInput
  }

  /**
   * DomainStatus findFirst
   */
  export type DomainStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatus to fetch.
     */
    where?: DomainStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatuses to fetch.
     */
    orderBy?: DomainStatusOrderByWithRelationInput | DomainStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainStatuses.
     */
    cursor?: DomainStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainStatuses.
     */
    distinct?: DomainStatusScalarFieldEnum | DomainStatusScalarFieldEnum[]
  }

  /**
   * DomainStatus findFirstOrThrow
   */
  export type DomainStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatus to fetch.
     */
    where?: DomainStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatuses to fetch.
     */
    orderBy?: DomainStatusOrderByWithRelationInput | DomainStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainStatuses.
     */
    cursor?: DomainStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainStatuses.
     */
    distinct?: DomainStatusScalarFieldEnum | DomainStatusScalarFieldEnum[]
  }

  /**
   * DomainStatus findMany
   */
  export type DomainStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatuses to fetch.
     */
    where?: DomainStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatuses to fetch.
     */
    orderBy?: DomainStatusOrderByWithRelationInput | DomainStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainStatuses.
     */
    cursor?: DomainStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatuses.
     */
    skip?: number
    distinct?: DomainStatusScalarFieldEnum | DomainStatusScalarFieldEnum[]
  }

  /**
   * DomainStatus create
   */
  export type DomainStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainStatus.
     */
    data: XOR<DomainStatusCreateInput, DomainStatusUncheckedCreateInput>
  }

  /**
   * DomainStatus createMany
   */
  export type DomainStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainStatuses.
     */
    data: DomainStatusCreateManyInput | DomainStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainStatus createManyAndReturn
   */
  export type DomainStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * The data used to create many DomainStatuses.
     */
    data: DomainStatusCreateManyInput | DomainStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainStatus update
   */
  export type DomainStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainStatus.
     */
    data: XOR<DomainStatusUpdateInput, DomainStatusUncheckedUpdateInput>
    /**
     * Choose, which DomainStatus to update.
     */
    where: DomainStatusWhereUniqueInput
  }

  /**
   * DomainStatus updateMany
   */
  export type DomainStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainStatuses.
     */
    data: XOR<DomainStatusUpdateManyMutationInput, DomainStatusUncheckedUpdateManyInput>
    /**
     * Filter which DomainStatuses to update
     */
    where?: DomainStatusWhereInput
    /**
     * Limit how many DomainStatuses to update.
     */
    limit?: number
  }

  /**
   * DomainStatus updateManyAndReturn
   */
  export type DomainStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * The data used to update DomainStatuses.
     */
    data: XOR<DomainStatusUpdateManyMutationInput, DomainStatusUncheckedUpdateManyInput>
    /**
     * Filter which DomainStatuses to update
     */
    where?: DomainStatusWhereInput
    /**
     * Limit how many DomainStatuses to update.
     */
    limit?: number
  }

  /**
   * DomainStatus upsert
   */
  export type DomainStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainStatus to update in case it exists.
     */
    where: DomainStatusWhereUniqueInput
    /**
     * In case the DomainStatus found by the `where` argument doesn't exist, create a new DomainStatus with this data.
     */
    create: XOR<DomainStatusCreateInput, DomainStatusUncheckedCreateInput>
    /**
     * In case the DomainStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainStatusUpdateInput, DomainStatusUncheckedUpdateInput>
  }

  /**
   * DomainStatus delete
   */
  export type DomainStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
    /**
     * Filter which DomainStatus to delete.
     */
    where: DomainStatusWhereUniqueInput
  }

  /**
   * DomainStatus deleteMany
   */
  export type DomainStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainStatuses to delete
     */
    where?: DomainStatusWhereInput
    /**
     * Limit how many DomainStatuses to delete.
     */
    limit?: number
  }

  /**
   * DomainStatus.encontrista
   */
  export type DomainStatus$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * DomainStatus without action
   */
  export type DomainStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatus
     */
    select?: DomainStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatus
     */
    omit?: DomainStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusInclude<ExtArgs> | null
  }


  /**
   * Model DomainReligiao
   */

  export type AggregateDomainReligiao = {
    _count: DomainReligiaoCountAggregateOutputType | null
    _min: DomainReligiaoMinAggregateOutputType | null
    _max: DomainReligiaoMaxAggregateOutputType | null
  }

  export type DomainReligiaoMinAggregateOutputType = {
    id: $Enums.Value_Religiao | null
    religiao: string | null
  }

  export type DomainReligiaoMaxAggregateOutputType = {
    id: $Enums.Value_Religiao | null
    religiao: string | null
  }

  export type DomainReligiaoCountAggregateOutputType = {
    id: number
    religiao: number
    _all: number
  }


  export type DomainReligiaoMinAggregateInputType = {
    id?: true
    religiao?: true
  }

  export type DomainReligiaoMaxAggregateInputType = {
    id?: true
    religiao?: true
  }

  export type DomainReligiaoCountAggregateInputType = {
    id?: true
    religiao?: true
    _all?: true
  }

  export type DomainReligiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainReligiao to aggregate.
     */
    where?: DomainReligiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReligiaos to fetch.
     */
    orderBy?: DomainReligiaoOrderByWithRelationInput | DomainReligiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainReligiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReligiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReligiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainReligiaos
    **/
    _count?: true | DomainReligiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainReligiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainReligiaoMaxAggregateInputType
  }

  export type GetDomainReligiaoAggregateType<T extends DomainReligiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainReligiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainReligiao[P]>
      : GetScalarType<T[P], AggregateDomainReligiao[P]>
  }




  export type DomainReligiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainReligiaoWhereInput
    orderBy?: DomainReligiaoOrderByWithAggregationInput | DomainReligiaoOrderByWithAggregationInput[]
    by: DomainReligiaoScalarFieldEnum[] | DomainReligiaoScalarFieldEnum
    having?: DomainReligiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainReligiaoCountAggregateInputType | true
    _min?: DomainReligiaoMinAggregateInputType
    _max?: DomainReligiaoMaxAggregateInputType
  }

  export type DomainReligiaoGroupByOutputType = {
    id: $Enums.Value_Religiao
    religiao: string
    _count: DomainReligiaoCountAggregateOutputType | null
    _min: DomainReligiaoMinAggregateOutputType | null
    _max: DomainReligiaoMaxAggregateOutputType | null
  }

  type GetDomainReligiaoGroupByPayload<T extends DomainReligiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainReligiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainReligiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainReligiaoGroupByOutputType[P]>
            : GetScalarType<T[P], DomainReligiaoGroupByOutputType[P]>
        }
      >
    >


  export type DomainReligiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    religiao?: boolean
    encontrista?: boolean | DomainReligiao$encontristaArgs<ExtArgs>
    _count?: boolean | DomainReligiaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainReligiao"]>

  export type DomainReligiaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    religiao?: boolean
  }, ExtArgs["result"]["domainReligiao"]>

  export type DomainReligiaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    religiao?: boolean
  }, ExtArgs["result"]["domainReligiao"]>

  export type DomainReligiaoSelectScalar = {
    id?: boolean
    religiao?: boolean
  }

  export type DomainReligiaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "religiao", ExtArgs["result"]["domainReligiao"]>
  export type DomainReligiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainReligiao$encontristaArgs<ExtArgs>
    _count?: boolean | DomainReligiaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainReligiaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainReligiaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainReligiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainReligiao"
    objects: {
      encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_Religiao
      religiao: string
    }, ExtArgs["result"]["domainReligiao"]>
    composites: {}
  }

  type DomainReligiaoGetPayload<S extends boolean | null | undefined | DomainReligiaoDefaultArgs> = $Result.GetResult<Prisma.$DomainReligiaoPayload, S>

  type DomainReligiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainReligiaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainReligiaoCountAggregateInputType | true
    }

  export interface DomainReligiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainReligiao'], meta: { name: 'DomainReligiao' } }
    /**
     * Find zero or one DomainReligiao that matches the filter.
     * @param {DomainReligiaoFindUniqueArgs} args - Arguments to find a DomainReligiao
     * @example
     * // Get one DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainReligiaoFindUniqueArgs>(args: SelectSubset<T, DomainReligiaoFindUniqueArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainReligiao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainReligiaoFindUniqueOrThrowArgs} args - Arguments to find a DomainReligiao
     * @example
     * // Get one DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainReligiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainReligiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainReligiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoFindFirstArgs} args - Arguments to find a DomainReligiao
     * @example
     * // Get one DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainReligiaoFindFirstArgs>(args?: SelectSubset<T, DomainReligiaoFindFirstArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainReligiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoFindFirstOrThrowArgs} args - Arguments to find a DomainReligiao
     * @example
     * // Get one DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainReligiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainReligiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainReligiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainReligiaos
     * const domainReligiaos = await prisma.domainReligiao.findMany()
     * 
     * // Get first 10 DomainReligiaos
     * const domainReligiaos = await prisma.domainReligiao.findMany({ take: 10 })
     * 
     * // Only select the `religiao`
     * const domainReligiaoWithReligiaoOnly = await prisma.domainReligiao.findMany({ select: { religiao: true } })
     * 
     */
    findMany<T extends DomainReligiaoFindManyArgs>(args?: SelectSubset<T, DomainReligiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainReligiao.
     * @param {DomainReligiaoCreateArgs} args - Arguments to create a DomainReligiao.
     * @example
     * // Create one DomainReligiao
     * const DomainReligiao = await prisma.domainReligiao.create({
     *   data: {
     *     // ... data to create a DomainReligiao
     *   }
     * })
     * 
     */
    create<T extends DomainReligiaoCreateArgs>(args: SelectSubset<T, DomainReligiaoCreateArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainReligiaos.
     * @param {DomainReligiaoCreateManyArgs} args - Arguments to create many DomainReligiaos.
     * @example
     * // Create many DomainReligiaos
     * const domainReligiao = await prisma.domainReligiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainReligiaoCreateManyArgs>(args?: SelectSubset<T, DomainReligiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainReligiaos and returns the data saved in the database.
     * @param {DomainReligiaoCreateManyAndReturnArgs} args - Arguments to create many DomainReligiaos.
     * @example
     * // Create many DomainReligiaos
     * const domainReligiao = await prisma.domainReligiao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainReligiaos and only return the `religiao`
     * const domainReligiaoWithReligiaoOnly = await prisma.domainReligiao.createManyAndReturn({
     *   select: { religiao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainReligiaoCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainReligiaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainReligiao.
     * @param {DomainReligiaoDeleteArgs} args - Arguments to delete one DomainReligiao.
     * @example
     * // Delete one DomainReligiao
     * const DomainReligiao = await prisma.domainReligiao.delete({
     *   where: {
     *     // ... filter to delete one DomainReligiao
     *   }
     * })
     * 
     */
    delete<T extends DomainReligiaoDeleteArgs>(args: SelectSubset<T, DomainReligiaoDeleteArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainReligiao.
     * @param {DomainReligiaoUpdateArgs} args - Arguments to update one DomainReligiao.
     * @example
     * // Update one DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainReligiaoUpdateArgs>(args: SelectSubset<T, DomainReligiaoUpdateArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainReligiaos.
     * @param {DomainReligiaoDeleteManyArgs} args - Arguments to filter DomainReligiaos to delete.
     * @example
     * // Delete a few DomainReligiaos
     * const { count } = await prisma.domainReligiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainReligiaoDeleteManyArgs>(args?: SelectSubset<T, DomainReligiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainReligiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainReligiaos
     * const domainReligiao = await prisma.domainReligiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainReligiaoUpdateManyArgs>(args: SelectSubset<T, DomainReligiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainReligiaos and returns the data updated in the database.
     * @param {DomainReligiaoUpdateManyAndReturnArgs} args - Arguments to update many DomainReligiaos.
     * @example
     * // Update many DomainReligiaos
     * const domainReligiao = await prisma.domainReligiao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainReligiaos and only return the `religiao`
     * const domainReligiaoWithReligiaoOnly = await prisma.domainReligiao.updateManyAndReturn({
     *   select: { religiao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainReligiaoUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainReligiaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainReligiao.
     * @param {DomainReligiaoUpsertArgs} args - Arguments to update or create a DomainReligiao.
     * @example
     * // Update or create a DomainReligiao
     * const domainReligiao = await prisma.domainReligiao.upsert({
     *   create: {
     *     // ... data to create a DomainReligiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainReligiao we want to update
     *   }
     * })
     */
    upsert<T extends DomainReligiaoUpsertArgs>(args: SelectSubset<T, DomainReligiaoUpsertArgs<ExtArgs>>): Prisma__DomainReligiaoClient<$Result.GetResult<Prisma.$DomainReligiaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainReligiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoCountArgs} args - Arguments to filter DomainReligiaos to count.
     * @example
     * // Count the number of DomainReligiaos
     * const count = await prisma.domainReligiao.count({
     *   where: {
     *     // ... the filter for the DomainReligiaos we want to count
     *   }
     * })
    **/
    count<T extends DomainReligiaoCountArgs>(
      args?: Subset<T, DomainReligiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainReligiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainReligiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainReligiaoAggregateArgs>(args: Subset<T, DomainReligiaoAggregateArgs>): Prisma.PrismaPromise<GetDomainReligiaoAggregateType<T>>

    /**
     * Group by DomainReligiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReligiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainReligiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainReligiaoGroupByArgs['orderBy'] }
        : { orderBy?: DomainReligiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainReligiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainReligiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainReligiao model
   */
  readonly fields: DomainReligiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainReligiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainReligiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontrista<T extends DomainReligiao$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, DomainReligiao$encontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainReligiao model
   */
  interface DomainReligiaoFieldRefs {
    readonly id: FieldRef<"DomainReligiao", 'Value_Religiao'>
    readonly religiao: FieldRef<"DomainReligiao", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainReligiao findUnique
   */
  export type DomainReligiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter, which DomainReligiao to fetch.
     */
    where: DomainReligiaoWhereUniqueInput
  }

  /**
   * DomainReligiao findUniqueOrThrow
   */
  export type DomainReligiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter, which DomainReligiao to fetch.
     */
    where: DomainReligiaoWhereUniqueInput
  }

  /**
   * DomainReligiao findFirst
   */
  export type DomainReligiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter, which DomainReligiao to fetch.
     */
    where?: DomainReligiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReligiaos to fetch.
     */
    orderBy?: DomainReligiaoOrderByWithRelationInput | DomainReligiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainReligiaos.
     */
    cursor?: DomainReligiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReligiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReligiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainReligiaos.
     */
    distinct?: DomainReligiaoScalarFieldEnum | DomainReligiaoScalarFieldEnum[]
  }

  /**
   * DomainReligiao findFirstOrThrow
   */
  export type DomainReligiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter, which DomainReligiao to fetch.
     */
    where?: DomainReligiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReligiaos to fetch.
     */
    orderBy?: DomainReligiaoOrderByWithRelationInput | DomainReligiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainReligiaos.
     */
    cursor?: DomainReligiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReligiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReligiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainReligiaos.
     */
    distinct?: DomainReligiaoScalarFieldEnum | DomainReligiaoScalarFieldEnum[]
  }

  /**
   * DomainReligiao findMany
   */
  export type DomainReligiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter, which DomainReligiaos to fetch.
     */
    where?: DomainReligiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReligiaos to fetch.
     */
    orderBy?: DomainReligiaoOrderByWithRelationInput | DomainReligiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainReligiaos.
     */
    cursor?: DomainReligiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReligiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReligiaos.
     */
    skip?: number
    distinct?: DomainReligiaoScalarFieldEnum | DomainReligiaoScalarFieldEnum[]
  }

  /**
   * DomainReligiao create
   */
  export type DomainReligiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainReligiao.
     */
    data: XOR<DomainReligiaoCreateInput, DomainReligiaoUncheckedCreateInput>
  }

  /**
   * DomainReligiao createMany
   */
  export type DomainReligiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainReligiaos.
     */
    data: DomainReligiaoCreateManyInput | DomainReligiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainReligiao createManyAndReturn
   */
  export type DomainReligiaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * The data used to create many DomainReligiaos.
     */
    data: DomainReligiaoCreateManyInput | DomainReligiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainReligiao update
   */
  export type DomainReligiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainReligiao.
     */
    data: XOR<DomainReligiaoUpdateInput, DomainReligiaoUncheckedUpdateInput>
    /**
     * Choose, which DomainReligiao to update.
     */
    where: DomainReligiaoWhereUniqueInput
  }

  /**
   * DomainReligiao updateMany
   */
  export type DomainReligiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainReligiaos.
     */
    data: XOR<DomainReligiaoUpdateManyMutationInput, DomainReligiaoUncheckedUpdateManyInput>
    /**
     * Filter which DomainReligiaos to update
     */
    where?: DomainReligiaoWhereInput
    /**
     * Limit how many DomainReligiaos to update.
     */
    limit?: number
  }

  /**
   * DomainReligiao updateManyAndReturn
   */
  export type DomainReligiaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * The data used to update DomainReligiaos.
     */
    data: XOR<DomainReligiaoUpdateManyMutationInput, DomainReligiaoUncheckedUpdateManyInput>
    /**
     * Filter which DomainReligiaos to update
     */
    where?: DomainReligiaoWhereInput
    /**
     * Limit how many DomainReligiaos to update.
     */
    limit?: number
  }

  /**
   * DomainReligiao upsert
   */
  export type DomainReligiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainReligiao to update in case it exists.
     */
    where: DomainReligiaoWhereUniqueInput
    /**
     * In case the DomainReligiao found by the `where` argument doesn't exist, create a new DomainReligiao with this data.
     */
    create: XOR<DomainReligiaoCreateInput, DomainReligiaoUncheckedCreateInput>
    /**
     * In case the DomainReligiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainReligiaoUpdateInput, DomainReligiaoUncheckedUpdateInput>
  }

  /**
   * DomainReligiao delete
   */
  export type DomainReligiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
    /**
     * Filter which DomainReligiao to delete.
     */
    where: DomainReligiaoWhereUniqueInput
  }

  /**
   * DomainReligiao deleteMany
   */
  export type DomainReligiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainReligiaos to delete
     */
    where?: DomainReligiaoWhereInput
    /**
     * Limit how many DomainReligiaos to delete.
     */
    limit?: number
  }

  /**
   * DomainReligiao.encontrista
   */
  export type DomainReligiao$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * DomainReligiao without action
   */
  export type DomainReligiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReligiao
     */
    select?: DomainReligiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReligiao
     */
    omit?: DomainReligiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReligiaoInclude<ExtArgs> | null
  }


  /**
   * Model DomainBairroEncontro
   */

  export type AggregateDomainBairroEncontro = {
    _count: DomainBairroEncontroCountAggregateOutputType | null
    _avg: DomainBairroEncontroAvgAggregateOutputType | null
    _sum: DomainBairroEncontroSumAggregateOutputType | null
    _min: DomainBairroEncontroMinAggregateOutputType | null
    _max: DomainBairroEncontroMaxAggregateOutputType | null
  }

  export type DomainBairroEncontroAvgAggregateOutputType = {
    id: number | null
  }

  export type DomainBairroEncontroSumAggregateOutputType = {
    id: number | null
  }

  export type DomainBairroEncontroMinAggregateOutputType = {
    id: number | null
    value: string | null
    bairro: string | null
    zona: string | null
  }

  export type DomainBairroEncontroMaxAggregateOutputType = {
    id: number | null
    value: string | null
    bairro: string | null
    zona: string | null
  }

  export type DomainBairroEncontroCountAggregateOutputType = {
    id: number
    value: number
    bairro: number
    zona: number
    _all: number
  }


  export type DomainBairroEncontroAvgAggregateInputType = {
    id?: true
  }

  export type DomainBairroEncontroSumAggregateInputType = {
    id?: true
  }

  export type DomainBairroEncontroMinAggregateInputType = {
    id?: true
    value?: true
    bairro?: true
    zona?: true
  }

  export type DomainBairroEncontroMaxAggregateInputType = {
    id?: true
    value?: true
    bairro?: true
    zona?: true
  }

  export type DomainBairroEncontroCountAggregateInputType = {
    id?: true
    value?: true
    bairro?: true
    zona?: true
    _all?: true
  }

  export type DomainBairroEncontroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainBairroEncontro to aggregate.
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBairroEncontros to fetch.
     */
    orderBy?: DomainBairroEncontroOrderByWithRelationInput | DomainBairroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainBairroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBairroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBairroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainBairroEncontros
    **/
    _count?: true | DomainBairroEncontroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainBairroEncontroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainBairroEncontroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainBairroEncontroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainBairroEncontroMaxAggregateInputType
  }

  export type GetDomainBairroEncontroAggregateType<T extends DomainBairroEncontroAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainBairroEncontro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainBairroEncontro[P]>
      : GetScalarType<T[P], AggregateDomainBairroEncontro[P]>
  }




  export type DomainBairroEncontroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainBairroEncontroWhereInput
    orderBy?: DomainBairroEncontroOrderByWithAggregationInput | DomainBairroEncontroOrderByWithAggregationInput[]
    by: DomainBairroEncontroScalarFieldEnum[] | DomainBairroEncontroScalarFieldEnum
    having?: DomainBairroEncontroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainBairroEncontroCountAggregateInputType | true
    _avg?: DomainBairroEncontroAvgAggregateInputType
    _sum?: DomainBairroEncontroSumAggregateInputType
    _min?: DomainBairroEncontroMinAggregateInputType
    _max?: DomainBairroEncontroMaxAggregateInputType
  }

  export type DomainBairroEncontroGroupByOutputType = {
    id: number
    value: string
    bairro: string
    zona: string
    _count: DomainBairroEncontroCountAggregateOutputType | null
    _avg: DomainBairroEncontroAvgAggregateOutputType | null
    _sum: DomainBairroEncontroSumAggregateOutputType | null
    _min: DomainBairroEncontroMinAggregateOutputType | null
    _max: DomainBairroEncontroMaxAggregateOutputType | null
  }

  type GetDomainBairroEncontroGroupByPayload<T extends DomainBairroEncontroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainBairroEncontroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainBairroEncontroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainBairroEncontroGroupByOutputType[P]>
            : GetScalarType<T[P], DomainBairroEncontroGroupByOutputType[P]>
        }
      >
    >


  export type DomainBairroEncontroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    bairro?: boolean
    zona?: boolean
  }, ExtArgs["result"]["domainBairroEncontro"]>

  export type DomainBairroEncontroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    bairro?: boolean
    zona?: boolean
  }, ExtArgs["result"]["domainBairroEncontro"]>

  export type DomainBairroEncontroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    bairro?: boolean
    zona?: boolean
  }, ExtArgs["result"]["domainBairroEncontro"]>

  export type DomainBairroEncontroSelectScalar = {
    id?: boolean
    value?: boolean
    bairro?: boolean
    zona?: boolean
  }

  export type DomainBairroEncontroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "bairro" | "zona", ExtArgs["result"]["domainBairroEncontro"]>

  export type $DomainBairroEncontroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainBairroEncontro"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      bairro: string
      zona: string
    }, ExtArgs["result"]["domainBairroEncontro"]>
    composites: {}
  }

  type DomainBairroEncontroGetPayload<S extends boolean | null | undefined | DomainBairroEncontroDefaultArgs> = $Result.GetResult<Prisma.$DomainBairroEncontroPayload, S>

  type DomainBairroEncontroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainBairroEncontroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainBairroEncontroCountAggregateInputType | true
    }

  export interface DomainBairroEncontroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainBairroEncontro'], meta: { name: 'DomainBairroEncontro' } }
    /**
     * Find zero or one DomainBairroEncontro that matches the filter.
     * @param {DomainBairroEncontroFindUniqueArgs} args - Arguments to find a DomainBairroEncontro
     * @example
     * // Get one DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainBairroEncontroFindUniqueArgs>(args: SelectSubset<T, DomainBairroEncontroFindUniqueArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainBairroEncontro that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainBairroEncontroFindUniqueOrThrowArgs} args - Arguments to find a DomainBairroEncontro
     * @example
     * // Get one DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainBairroEncontroFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainBairroEncontroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainBairroEncontro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroFindFirstArgs} args - Arguments to find a DomainBairroEncontro
     * @example
     * // Get one DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainBairroEncontroFindFirstArgs>(args?: SelectSubset<T, DomainBairroEncontroFindFirstArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainBairroEncontro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroFindFirstOrThrowArgs} args - Arguments to find a DomainBairroEncontro
     * @example
     * // Get one DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainBairroEncontroFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainBairroEncontroFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainBairroEncontros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainBairroEncontros
     * const domainBairroEncontros = await prisma.domainBairroEncontro.findMany()
     * 
     * // Get first 10 DomainBairroEncontros
     * const domainBairroEncontros = await prisma.domainBairroEncontro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainBairroEncontroWithIdOnly = await prisma.domainBairroEncontro.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainBairroEncontroFindManyArgs>(args?: SelectSubset<T, DomainBairroEncontroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainBairroEncontro.
     * @param {DomainBairroEncontroCreateArgs} args - Arguments to create a DomainBairroEncontro.
     * @example
     * // Create one DomainBairroEncontro
     * const DomainBairroEncontro = await prisma.domainBairroEncontro.create({
     *   data: {
     *     // ... data to create a DomainBairroEncontro
     *   }
     * })
     * 
     */
    create<T extends DomainBairroEncontroCreateArgs>(args: SelectSubset<T, DomainBairroEncontroCreateArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainBairroEncontros.
     * @param {DomainBairroEncontroCreateManyArgs} args - Arguments to create many DomainBairroEncontros.
     * @example
     * // Create many DomainBairroEncontros
     * const domainBairroEncontro = await prisma.domainBairroEncontro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainBairroEncontroCreateManyArgs>(args?: SelectSubset<T, DomainBairroEncontroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainBairroEncontros and returns the data saved in the database.
     * @param {DomainBairroEncontroCreateManyAndReturnArgs} args - Arguments to create many DomainBairroEncontros.
     * @example
     * // Create many DomainBairroEncontros
     * const domainBairroEncontro = await prisma.domainBairroEncontro.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainBairroEncontros and only return the `id`
     * const domainBairroEncontroWithIdOnly = await prisma.domainBairroEncontro.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainBairroEncontroCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainBairroEncontroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainBairroEncontro.
     * @param {DomainBairroEncontroDeleteArgs} args - Arguments to delete one DomainBairroEncontro.
     * @example
     * // Delete one DomainBairroEncontro
     * const DomainBairroEncontro = await prisma.domainBairroEncontro.delete({
     *   where: {
     *     // ... filter to delete one DomainBairroEncontro
     *   }
     * })
     * 
     */
    delete<T extends DomainBairroEncontroDeleteArgs>(args: SelectSubset<T, DomainBairroEncontroDeleteArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainBairroEncontro.
     * @param {DomainBairroEncontroUpdateArgs} args - Arguments to update one DomainBairroEncontro.
     * @example
     * // Update one DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainBairroEncontroUpdateArgs>(args: SelectSubset<T, DomainBairroEncontroUpdateArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainBairroEncontros.
     * @param {DomainBairroEncontroDeleteManyArgs} args - Arguments to filter DomainBairroEncontros to delete.
     * @example
     * // Delete a few DomainBairroEncontros
     * const { count } = await prisma.domainBairroEncontro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainBairroEncontroDeleteManyArgs>(args?: SelectSubset<T, DomainBairroEncontroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainBairroEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainBairroEncontros
     * const domainBairroEncontro = await prisma.domainBairroEncontro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainBairroEncontroUpdateManyArgs>(args: SelectSubset<T, DomainBairroEncontroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainBairroEncontros and returns the data updated in the database.
     * @param {DomainBairroEncontroUpdateManyAndReturnArgs} args - Arguments to update many DomainBairroEncontros.
     * @example
     * // Update many DomainBairroEncontros
     * const domainBairroEncontro = await prisma.domainBairroEncontro.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainBairroEncontros and only return the `id`
     * const domainBairroEncontroWithIdOnly = await prisma.domainBairroEncontro.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainBairroEncontroUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainBairroEncontroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainBairroEncontro.
     * @param {DomainBairroEncontroUpsertArgs} args - Arguments to update or create a DomainBairroEncontro.
     * @example
     * // Update or create a DomainBairroEncontro
     * const domainBairroEncontro = await prisma.domainBairroEncontro.upsert({
     *   create: {
     *     // ... data to create a DomainBairroEncontro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainBairroEncontro we want to update
     *   }
     * })
     */
    upsert<T extends DomainBairroEncontroUpsertArgs>(args: SelectSubset<T, DomainBairroEncontroUpsertArgs<ExtArgs>>): Prisma__DomainBairroEncontroClient<$Result.GetResult<Prisma.$DomainBairroEncontroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainBairroEncontros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroCountArgs} args - Arguments to filter DomainBairroEncontros to count.
     * @example
     * // Count the number of DomainBairroEncontros
     * const count = await prisma.domainBairroEncontro.count({
     *   where: {
     *     // ... the filter for the DomainBairroEncontros we want to count
     *   }
     * })
    **/
    count<T extends DomainBairroEncontroCountArgs>(
      args?: Subset<T, DomainBairroEncontroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainBairroEncontroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainBairroEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainBairroEncontroAggregateArgs>(args: Subset<T, DomainBairroEncontroAggregateArgs>): Prisma.PrismaPromise<GetDomainBairroEncontroAggregateType<T>>

    /**
     * Group by DomainBairroEncontro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBairroEncontroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainBairroEncontroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainBairroEncontroGroupByArgs['orderBy'] }
        : { orderBy?: DomainBairroEncontroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainBairroEncontroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainBairroEncontroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainBairroEncontro model
   */
  readonly fields: DomainBairroEncontroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainBairroEncontro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainBairroEncontroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainBairroEncontro model
   */
  interface DomainBairroEncontroFieldRefs {
    readonly id: FieldRef<"DomainBairroEncontro", 'Int'>
    readonly value: FieldRef<"DomainBairroEncontro", 'String'>
    readonly bairro: FieldRef<"DomainBairroEncontro", 'String'>
    readonly zona: FieldRef<"DomainBairroEncontro", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainBairroEncontro findUnique
   */
  export type DomainBairroEncontroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter, which DomainBairroEncontro to fetch.
     */
    where: DomainBairroEncontroWhereUniqueInput
  }

  /**
   * DomainBairroEncontro findUniqueOrThrow
   */
  export type DomainBairroEncontroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter, which DomainBairroEncontro to fetch.
     */
    where: DomainBairroEncontroWhereUniqueInput
  }

  /**
   * DomainBairroEncontro findFirst
   */
  export type DomainBairroEncontroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter, which DomainBairroEncontro to fetch.
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBairroEncontros to fetch.
     */
    orderBy?: DomainBairroEncontroOrderByWithRelationInput | DomainBairroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainBairroEncontros.
     */
    cursor?: DomainBairroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBairroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBairroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainBairroEncontros.
     */
    distinct?: DomainBairroEncontroScalarFieldEnum | DomainBairroEncontroScalarFieldEnum[]
  }

  /**
   * DomainBairroEncontro findFirstOrThrow
   */
  export type DomainBairroEncontroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter, which DomainBairroEncontro to fetch.
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBairroEncontros to fetch.
     */
    orderBy?: DomainBairroEncontroOrderByWithRelationInput | DomainBairroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainBairroEncontros.
     */
    cursor?: DomainBairroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBairroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBairroEncontros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainBairroEncontros.
     */
    distinct?: DomainBairroEncontroScalarFieldEnum | DomainBairroEncontroScalarFieldEnum[]
  }

  /**
   * DomainBairroEncontro findMany
   */
  export type DomainBairroEncontroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter, which DomainBairroEncontros to fetch.
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBairroEncontros to fetch.
     */
    orderBy?: DomainBairroEncontroOrderByWithRelationInput | DomainBairroEncontroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainBairroEncontros.
     */
    cursor?: DomainBairroEncontroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBairroEncontros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBairroEncontros.
     */
    skip?: number
    distinct?: DomainBairroEncontroScalarFieldEnum | DomainBairroEncontroScalarFieldEnum[]
  }

  /**
   * DomainBairroEncontro create
   */
  export type DomainBairroEncontroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * The data needed to create a DomainBairroEncontro.
     */
    data: XOR<DomainBairroEncontroCreateInput, DomainBairroEncontroUncheckedCreateInput>
  }

  /**
   * DomainBairroEncontro createMany
   */
  export type DomainBairroEncontroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainBairroEncontros.
     */
    data: DomainBairroEncontroCreateManyInput | DomainBairroEncontroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainBairroEncontro createManyAndReturn
   */
  export type DomainBairroEncontroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * The data used to create many DomainBairroEncontros.
     */
    data: DomainBairroEncontroCreateManyInput | DomainBairroEncontroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainBairroEncontro update
   */
  export type DomainBairroEncontroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * The data needed to update a DomainBairroEncontro.
     */
    data: XOR<DomainBairroEncontroUpdateInput, DomainBairroEncontroUncheckedUpdateInput>
    /**
     * Choose, which DomainBairroEncontro to update.
     */
    where: DomainBairroEncontroWhereUniqueInput
  }

  /**
   * DomainBairroEncontro updateMany
   */
  export type DomainBairroEncontroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainBairroEncontros.
     */
    data: XOR<DomainBairroEncontroUpdateManyMutationInput, DomainBairroEncontroUncheckedUpdateManyInput>
    /**
     * Filter which DomainBairroEncontros to update
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * Limit how many DomainBairroEncontros to update.
     */
    limit?: number
  }

  /**
   * DomainBairroEncontro updateManyAndReturn
   */
  export type DomainBairroEncontroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * The data used to update DomainBairroEncontros.
     */
    data: XOR<DomainBairroEncontroUpdateManyMutationInput, DomainBairroEncontroUncheckedUpdateManyInput>
    /**
     * Filter which DomainBairroEncontros to update
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * Limit how many DomainBairroEncontros to update.
     */
    limit?: number
  }

  /**
   * DomainBairroEncontro upsert
   */
  export type DomainBairroEncontroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * The filter to search for the DomainBairroEncontro to update in case it exists.
     */
    where: DomainBairroEncontroWhereUniqueInput
    /**
     * In case the DomainBairroEncontro found by the `where` argument doesn't exist, create a new DomainBairroEncontro with this data.
     */
    create: XOR<DomainBairroEncontroCreateInput, DomainBairroEncontroUncheckedCreateInput>
    /**
     * In case the DomainBairroEncontro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainBairroEncontroUpdateInput, DomainBairroEncontroUncheckedUpdateInput>
  }

  /**
   * DomainBairroEncontro delete
   */
  export type DomainBairroEncontroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
    /**
     * Filter which DomainBairroEncontro to delete.
     */
    where: DomainBairroEncontroWhereUniqueInput
  }

  /**
   * DomainBairroEncontro deleteMany
   */
  export type DomainBairroEncontroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainBairroEncontros to delete
     */
    where?: DomainBairroEncontroWhereInput
    /**
     * Limit how many DomainBairroEncontros to delete.
     */
    limit?: number
  }

  /**
   * DomainBairroEncontro without action
   */
  export type DomainBairroEncontroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBairroEncontro
     */
    select?: DomainBairroEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBairroEncontro
     */
    omit?: DomainBairroEncontroOmit<ExtArgs> | null
  }


  /**
   * Model DomainMoraCom
   */

  export type AggregateDomainMoraCom = {
    _count: DomainMoraComCountAggregateOutputType | null
    _min: DomainMoraComMinAggregateOutputType | null
    _max: DomainMoraComMaxAggregateOutputType | null
  }

  export type DomainMoraComMinAggregateOutputType = {
    id: $Enums.Value_MoraCom | null
    moraCom: string | null
  }

  export type DomainMoraComMaxAggregateOutputType = {
    id: $Enums.Value_MoraCom | null
    moraCom: string | null
  }

  export type DomainMoraComCountAggregateOutputType = {
    id: number
    moraCom: number
    _all: number
  }


  export type DomainMoraComMinAggregateInputType = {
    id?: true
    moraCom?: true
  }

  export type DomainMoraComMaxAggregateInputType = {
    id?: true
    moraCom?: true
  }

  export type DomainMoraComCountAggregateInputType = {
    id?: true
    moraCom?: true
    _all?: true
  }

  export type DomainMoraComAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainMoraCom to aggregate.
     */
    where?: DomainMoraComWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainMoraComs to fetch.
     */
    orderBy?: DomainMoraComOrderByWithRelationInput | DomainMoraComOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainMoraComWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainMoraComs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainMoraComs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainMoraComs
    **/
    _count?: true | DomainMoraComCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainMoraComMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainMoraComMaxAggregateInputType
  }

  export type GetDomainMoraComAggregateType<T extends DomainMoraComAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainMoraCom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainMoraCom[P]>
      : GetScalarType<T[P], AggregateDomainMoraCom[P]>
  }




  export type DomainMoraComGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainMoraComWhereInput
    orderBy?: DomainMoraComOrderByWithAggregationInput | DomainMoraComOrderByWithAggregationInput[]
    by: DomainMoraComScalarFieldEnum[] | DomainMoraComScalarFieldEnum
    having?: DomainMoraComScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainMoraComCountAggregateInputType | true
    _min?: DomainMoraComMinAggregateInputType
    _max?: DomainMoraComMaxAggregateInputType
  }

  export type DomainMoraComGroupByOutputType = {
    id: $Enums.Value_MoraCom
    moraCom: string
    _count: DomainMoraComCountAggregateOutputType | null
    _min: DomainMoraComMinAggregateOutputType | null
    _max: DomainMoraComMaxAggregateOutputType | null
  }

  type GetDomainMoraComGroupByPayload<T extends DomainMoraComGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainMoraComGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainMoraComGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainMoraComGroupByOutputType[P]>
            : GetScalarType<T[P], DomainMoraComGroupByOutputType[P]>
        }
      >
    >


  export type DomainMoraComSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moraCom?: boolean
    encontrista?: boolean | DomainMoraCom$encontristaArgs<ExtArgs>
    _count?: boolean | DomainMoraComCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainMoraCom"]>

  export type DomainMoraComSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moraCom?: boolean
  }, ExtArgs["result"]["domainMoraCom"]>

  export type DomainMoraComSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moraCom?: boolean
  }, ExtArgs["result"]["domainMoraCom"]>

  export type DomainMoraComSelectScalar = {
    id?: boolean
    moraCom?: boolean
  }

  export type DomainMoraComOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moraCom", ExtArgs["result"]["domainMoraCom"]>
  export type DomainMoraComInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainMoraCom$encontristaArgs<ExtArgs>
    _count?: boolean | DomainMoraComCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainMoraComIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainMoraComIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainMoraComPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainMoraCom"
    objects: {
      encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_MoraCom
      moraCom: string
    }, ExtArgs["result"]["domainMoraCom"]>
    composites: {}
  }

  type DomainMoraComGetPayload<S extends boolean | null | undefined | DomainMoraComDefaultArgs> = $Result.GetResult<Prisma.$DomainMoraComPayload, S>

  type DomainMoraComCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainMoraComFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainMoraComCountAggregateInputType | true
    }

  export interface DomainMoraComDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainMoraCom'], meta: { name: 'DomainMoraCom' } }
    /**
     * Find zero or one DomainMoraCom that matches the filter.
     * @param {DomainMoraComFindUniqueArgs} args - Arguments to find a DomainMoraCom
     * @example
     * // Get one DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainMoraComFindUniqueArgs>(args: SelectSubset<T, DomainMoraComFindUniqueArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainMoraCom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainMoraComFindUniqueOrThrowArgs} args - Arguments to find a DomainMoraCom
     * @example
     * // Get one DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainMoraComFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainMoraComFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainMoraCom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComFindFirstArgs} args - Arguments to find a DomainMoraCom
     * @example
     * // Get one DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainMoraComFindFirstArgs>(args?: SelectSubset<T, DomainMoraComFindFirstArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainMoraCom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComFindFirstOrThrowArgs} args - Arguments to find a DomainMoraCom
     * @example
     * // Get one DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainMoraComFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainMoraComFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainMoraComs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainMoraComs
     * const domainMoraComs = await prisma.domainMoraCom.findMany()
     * 
     * // Get first 10 DomainMoraComs
     * const domainMoraComs = await prisma.domainMoraCom.findMany({ take: 10 })
     * 
     * // Only select the `moraCom`
     * const domainMoraComWithMoraComOnly = await prisma.domainMoraCom.findMany({ select: { moraCom: true } })
     * 
     */
    findMany<T extends DomainMoraComFindManyArgs>(args?: SelectSubset<T, DomainMoraComFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainMoraCom.
     * @param {DomainMoraComCreateArgs} args - Arguments to create a DomainMoraCom.
     * @example
     * // Create one DomainMoraCom
     * const DomainMoraCom = await prisma.domainMoraCom.create({
     *   data: {
     *     // ... data to create a DomainMoraCom
     *   }
     * })
     * 
     */
    create<T extends DomainMoraComCreateArgs>(args: SelectSubset<T, DomainMoraComCreateArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainMoraComs.
     * @param {DomainMoraComCreateManyArgs} args - Arguments to create many DomainMoraComs.
     * @example
     * // Create many DomainMoraComs
     * const domainMoraCom = await prisma.domainMoraCom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainMoraComCreateManyArgs>(args?: SelectSubset<T, DomainMoraComCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainMoraComs and returns the data saved in the database.
     * @param {DomainMoraComCreateManyAndReturnArgs} args - Arguments to create many DomainMoraComs.
     * @example
     * // Create many DomainMoraComs
     * const domainMoraCom = await prisma.domainMoraCom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainMoraComs and only return the `moraCom`
     * const domainMoraComWithMoraComOnly = await prisma.domainMoraCom.createManyAndReturn({
     *   select: { moraCom: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainMoraComCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainMoraComCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainMoraCom.
     * @param {DomainMoraComDeleteArgs} args - Arguments to delete one DomainMoraCom.
     * @example
     * // Delete one DomainMoraCom
     * const DomainMoraCom = await prisma.domainMoraCom.delete({
     *   where: {
     *     // ... filter to delete one DomainMoraCom
     *   }
     * })
     * 
     */
    delete<T extends DomainMoraComDeleteArgs>(args: SelectSubset<T, DomainMoraComDeleteArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainMoraCom.
     * @param {DomainMoraComUpdateArgs} args - Arguments to update one DomainMoraCom.
     * @example
     * // Update one DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainMoraComUpdateArgs>(args: SelectSubset<T, DomainMoraComUpdateArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainMoraComs.
     * @param {DomainMoraComDeleteManyArgs} args - Arguments to filter DomainMoraComs to delete.
     * @example
     * // Delete a few DomainMoraComs
     * const { count } = await prisma.domainMoraCom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainMoraComDeleteManyArgs>(args?: SelectSubset<T, DomainMoraComDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainMoraComs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainMoraComs
     * const domainMoraCom = await prisma.domainMoraCom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainMoraComUpdateManyArgs>(args: SelectSubset<T, DomainMoraComUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainMoraComs and returns the data updated in the database.
     * @param {DomainMoraComUpdateManyAndReturnArgs} args - Arguments to update many DomainMoraComs.
     * @example
     * // Update many DomainMoraComs
     * const domainMoraCom = await prisma.domainMoraCom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainMoraComs and only return the `moraCom`
     * const domainMoraComWithMoraComOnly = await prisma.domainMoraCom.updateManyAndReturn({
     *   select: { moraCom: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainMoraComUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainMoraComUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainMoraCom.
     * @param {DomainMoraComUpsertArgs} args - Arguments to update or create a DomainMoraCom.
     * @example
     * // Update or create a DomainMoraCom
     * const domainMoraCom = await prisma.domainMoraCom.upsert({
     *   create: {
     *     // ... data to create a DomainMoraCom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainMoraCom we want to update
     *   }
     * })
     */
    upsert<T extends DomainMoraComUpsertArgs>(args: SelectSubset<T, DomainMoraComUpsertArgs<ExtArgs>>): Prisma__DomainMoraComClient<$Result.GetResult<Prisma.$DomainMoraComPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainMoraComs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComCountArgs} args - Arguments to filter DomainMoraComs to count.
     * @example
     * // Count the number of DomainMoraComs
     * const count = await prisma.domainMoraCom.count({
     *   where: {
     *     // ... the filter for the DomainMoraComs we want to count
     *   }
     * })
    **/
    count<T extends DomainMoraComCountArgs>(
      args?: Subset<T, DomainMoraComCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainMoraComCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainMoraCom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainMoraComAggregateArgs>(args: Subset<T, DomainMoraComAggregateArgs>): Prisma.PrismaPromise<GetDomainMoraComAggregateType<T>>

    /**
     * Group by DomainMoraCom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainMoraComGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainMoraComGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainMoraComGroupByArgs['orderBy'] }
        : { orderBy?: DomainMoraComGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainMoraComGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainMoraComGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainMoraCom model
   */
  readonly fields: DomainMoraComFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainMoraCom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainMoraComClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontrista<T extends DomainMoraCom$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, DomainMoraCom$encontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainMoraCom model
   */
  interface DomainMoraComFieldRefs {
    readonly id: FieldRef<"DomainMoraCom", 'Value_MoraCom'>
    readonly moraCom: FieldRef<"DomainMoraCom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainMoraCom findUnique
   */
  export type DomainMoraComFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter, which DomainMoraCom to fetch.
     */
    where: DomainMoraComWhereUniqueInput
  }

  /**
   * DomainMoraCom findUniqueOrThrow
   */
  export type DomainMoraComFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter, which DomainMoraCom to fetch.
     */
    where: DomainMoraComWhereUniqueInput
  }

  /**
   * DomainMoraCom findFirst
   */
  export type DomainMoraComFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter, which DomainMoraCom to fetch.
     */
    where?: DomainMoraComWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainMoraComs to fetch.
     */
    orderBy?: DomainMoraComOrderByWithRelationInput | DomainMoraComOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainMoraComs.
     */
    cursor?: DomainMoraComWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainMoraComs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainMoraComs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainMoraComs.
     */
    distinct?: DomainMoraComScalarFieldEnum | DomainMoraComScalarFieldEnum[]
  }

  /**
   * DomainMoraCom findFirstOrThrow
   */
  export type DomainMoraComFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter, which DomainMoraCom to fetch.
     */
    where?: DomainMoraComWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainMoraComs to fetch.
     */
    orderBy?: DomainMoraComOrderByWithRelationInput | DomainMoraComOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainMoraComs.
     */
    cursor?: DomainMoraComWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainMoraComs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainMoraComs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainMoraComs.
     */
    distinct?: DomainMoraComScalarFieldEnum | DomainMoraComScalarFieldEnum[]
  }

  /**
   * DomainMoraCom findMany
   */
  export type DomainMoraComFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter, which DomainMoraComs to fetch.
     */
    where?: DomainMoraComWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainMoraComs to fetch.
     */
    orderBy?: DomainMoraComOrderByWithRelationInput | DomainMoraComOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainMoraComs.
     */
    cursor?: DomainMoraComWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainMoraComs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainMoraComs.
     */
    skip?: number
    distinct?: DomainMoraComScalarFieldEnum | DomainMoraComScalarFieldEnum[]
  }

  /**
   * DomainMoraCom create
   */
  export type DomainMoraComCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainMoraCom.
     */
    data: XOR<DomainMoraComCreateInput, DomainMoraComUncheckedCreateInput>
  }

  /**
   * DomainMoraCom createMany
   */
  export type DomainMoraComCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainMoraComs.
     */
    data: DomainMoraComCreateManyInput | DomainMoraComCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainMoraCom createManyAndReturn
   */
  export type DomainMoraComCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * The data used to create many DomainMoraComs.
     */
    data: DomainMoraComCreateManyInput | DomainMoraComCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainMoraCom update
   */
  export type DomainMoraComUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainMoraCom.
     */
    data: XOR<DomainMoraComUpdateInput, DomainMoraComUncheckedUpdateInput>
    /**
     * Choose, which DomainMoraCom to update.
     */
    where: DomainMoraComWhereUniqueInput
  }

  /**
   * DomainMoraCom updateMany
   */
  export type DomainMoraComUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainMoraComs.
     */
    data: XOR<DomainMoraComUpdateManyMutationInput, DomainMoraComUncheckedUpdateManyInput>
    /**
     * Filter which DomainMoraComs to update
     */
    where?: DomainMoraComWhereInput
    /**
     * Limit how many DomainMoraComs to update.
     */
    limit?: number
  }

  /**
   * DomainMoraCom updateManyAndReturn
   */
  export type DomainMoraComUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * The data used to update DomainMoraComs.
     */
    data: XOR<DomainMoraComUpdateManyMutationInput, DomainMoraComUncheckedUpdateManyInput>
    /**
     * Filter which DomainMoraComs to update
     */
    where?: DomainMoraComWhereInput
    /**
     * Limit how many DomainMoraComs to update.
     */
    limit?: number
  }

  /**
   * DomainMoraCom upsert
   */
  export type DomainMoraComUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainMoraCom to update in case it exists.
     */
    where: DomainMoraComWhereUniqueInput
    /**
     * In case the DomainMoraCom found by the `where` argument doesn't exist, create a new DomainMoraCom with this data.
     */
    create: XOR<DomainMoraComCreateInput, DomainMoraComUncheckedCreateInput>
    /**
     * In case the DomainMoraCom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainMoraComUpdateInput, DomainMoraComUncheckedUpdateInput>
  }

  /**
   * DomainMoraCom delete
   */
  export type DomainMoraComDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
    /**
     * Filter which DomainMoraCom to delete.
     */
    where: DomainMoraComWhereUniqueInput
  }

  /**
   * DomainMoraCom deleteMany
   */
  export type DomainMoraComDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainMoraComs to delete
     */
    where?: DomainMoraComWhereInput
    /**
     * Limit how many DomainMoraComs to delete.
     */
    limit?: number
  }

  /**
   * DomainMoraCom.encontrista
   */
  export type DomainMoraCom$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * DomainMoraCom without action
   */
  export type DomainMoraComDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainMoraCom
     */
    select?: DomainMoraComSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainMoraCom
     */
    omit?: DomainMoraComOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainMoraComInclude<ExtArgs> | null
  }


  /**
   * Model DomainStatusPais
   */

  export type AggregateDomainStatusPais = {
    _count: DomainStatusPaisCountAggregateOutputType | null
    _min: DomainStatusPaisMinAggregateOutputType | null
    _max: DomainStatusPaisMaxAggregateOutputType | null
  }

  export type DomainStatusPaisMinAggregateOutputType = {
    id: $Enums.Value_StatusPais | null
    statusPais: string | null
  }

  export type DomainStatusPaisMaxAggregateOutputType = {
    id: $Enums.Value_StatusPais | null
    statusPais: string | null
  }

  export type DomainStatusPaisCountAggregateOutputType = {
    id: number
    statusPais: number
    _all: number
  }


  export type DomainStatusPaisMinAggregateInputType = {
    id?: true
    statusPais?: true
  }

  export type DomainStatusPaisMaxAggregateInputType = {
    id?: true
    statusPais?: true
  }

  export type DomainStatusPaisCountAggregateInputType = {
    id?: true
    statusPais?: true
    _all?: true
  }

  export type DomainStatusPaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainStatusPais to aggregate.
     */
    where?: DomainStatusPaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatusPais to fetch.
     */
    orderBy?: DomainStatusPaisOrderByWithRelationInput | DomainStatusPaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainStatusPaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatusPais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatusPais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainStatusPais
    **/
    _count?: true | DomainStatusPaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainStatusPaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainStatusPaisMaxAggregateInputType
  }

  export type GetDomainStatusPaisAggregateType<T extends DomainStatusPaisAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainStatusPais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainStatusPais[P]>
      : GetScalarType<T[P], AggregateDomainStatusPais[P]>
  }




  export type DomainStatusPaisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainStatusPaisWhereInput
    orderBy?: DomainStatusPaisOrderByWithAggregationInput | DomainStatusPaisOrderByWithAggregationInput[]
    by: DomainStatusPaisScalarFieldEnum[] | DomainStatusPaisScalarFieldEnum
    having?: DomainStatusPaisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainStatusPaisCountAggregateInputType | true
    _min?: DomainStatusPaisMinAggregateInputType
    _max?: DomainStatusPaisMaxAggregateInputType
  }

  export type DomainStatusPaisGroupByOutputType = {
    id: $Enums.Value_StatusPais
    statusPais: string
    _count: DomainStatusPaisCountAggregateOutputType | null
    _min: DomainStatusPaisMinAggregateOutputType | null
    _max: DomainStatusPaisMaxAggregateOutputType | null
  }

  type GetDomainStatusPaisGroupByPayload<T extends DomainStatusPaisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainStatusPaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainStatusPaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainStatusPaisGroupByOutputType[P]>
            : GetScalarType<T[P], DomainStatusPaisGroupByOutputType[P]>
        }
      >
    >


  export type DomainStatusPaisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statusPais?: boolean
    encontrista?: boolean | DomainStatusPais$encontristaArgs<ExtArgs>
    _count?: boolean | DomainStatusPaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainStatusPais"]>

  export type DomainStatusPaisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statusPais?: boolean
  }, ExtArgs["result"]["domainStatusPais"]>

  export type DomainStatusPaisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statusPais?: boolean
  }, ExtArgs["result"]["domainStatusPais"]>

  export type DomainStatusPaisSelectScalar = {
    id?: boolean
    statusPais?: boolean
  }

  export type DomainStatusPaisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statusPais", ExtArgs["result"]["domainStatusPais"]>
  export type DomainStatusPaisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontrista?: boolean | DomainStatusPais$encontristaArgs<ExtArgs>
    _count?: boolean | DomainStatusPaisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainStatusPaisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainStatusPaisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainStatusPaisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainStatusPais"
    objects: {
      encontrista: Prisma.$EncontristaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_StatusPais
      statusPais: string
    }, ExtArgs["result"]["domainStatusPais"]>
    composites: {}
  }

  type DomainStatusPaisGetPayload<S extends boolean | null | undefined | DomainStatusPaisDefaultArgs> = $Result.GetResult<Prisma.$DomainStatusPaisPayload, S>

  type DomainStatusPaisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainStatusPaisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainStatusPaisCountAggregateInputType | true
    }

  export interface DomainStatusPaisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainStatusPais'], meta: { name: 'DomainStatusPais' } }
    /**
     * Find zero or one DomainStatusPais that matches the filter.
     * @param {DomainStatusPaisFindUniqueArgs} args - Arguments to find a DomainStatusPais
     * @example
     * // Get one DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainStatusPaisFindUniqueArgs>(args: SelectSubset<T, DomainStatusPaisFindUniqueArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainStatusPais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainStatusPaisFindUniqueOrThrowArgs} args - Arguments to find a DomainStatusPais
     * @example
     * // Get one DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainStatusPaisFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainStatusPaisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainStatusPais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisFindFirstArgs} args - Arguments to find a DomainStatusPais
     * @example
     * // Get one DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainStatusPaisFindFirstArgs>(args?: SelectSubset<T, DomainStatusPaisFindFirstArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainStatusPais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisFindFirstOrThrowArgs} args - Arguments to find a DomainStatusPais
     * @example
     * // Get one DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainStatusPaisFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainStatusPaisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainStatusPais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findMany()
     * 
     * // Get first 10 DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.findMany({ take: 10 })
     * 
     * // Only select the `statusPais`
     * const domainStatusPaisWithStatusPaisOnly = await prisma.domainStatusPais.findMany({ select: { statusPais: true } })
     * 
     */
    findMany<T extends DomainStatusPaisFindManyArgs>(args?: SelectSubset<T, DomainStatusPaisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainStatusPais.
     * @param {DomainStatusPaisCreateArgs} args - Arguments to create a DomainStatusPais.
     * @example
     * // Create one DomainStatusPais
     * const DomainStatusPais = await prisma.domainStatusPais.create({
     *   data: {
     *     // ... data to create a DomainStatusPais
     *   }
     * })
     * 
     */
    create<T extends DomainStatusPaisCreateArgs>(args: SelectSubset<T, DomainStatusPaisCreateArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainStatusPais.
     * @param {DomainStatusPaisCreateManyArgs} args - Arguments to create many DomainStatusPais.
     * @example
     * // Create many DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainStatusPaisCreateManyArgs>(args?: SelectSubset<T, DomainStatusPaisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainStatusPais and returns the data saved in the database.
     * @param {DomainStatusPaisCreateManyAndReturnArgs} args - Arguments to create many DomainStatusPais.
     * @example
     * // Create many DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainStatusPais and only return the `statusPais`
     * const domainStatusPaisWithStatusPaisOnly = await prisma.domainStatusPais.createManyAndReturn({
     *   select: { statusPais: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainStatusPaisCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainStatusPaisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainStatusPais.
     * @param {DomainStatusPaisDeleteArgs} args - Arguments to delete one DomainStatusPais.
     * @example
     * // Delete one DomainStatusPais
     * const DomainStatusPais = await prisma.domainStatusPais.delete({
     *   where: {
     *     // ... filter to delete one DomainStatusPais
     *   }
     * })
     * 
     */
    delete<T extends DomainStatusPaisDeleteArgs>(args: SelectSubset<T, DomainStatusPaisDeleteArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainStatusPais.
     * @param {DomainStatusPaisUpdateArgs} args - Arguments to update one DomainStatusPais.
     * @example
     * // Update one DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainStatusPaisUpdateArgs>(args: SelectSubset<T, DomainStatusPaisUpdateArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainStatusPais.
     * @param {DomainStatusPaisDeleteManyArgs} args - Arguments to filter DomainStatusPais to delete.
     * @example
     * // Delete a few DomainStatusPais
     * const { count } = await prisma.domainStatusPais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainStatusPaisDeleteManyArgs>(args?: SelectSubset<T, DomainStatusPaisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainStatusPais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainStatusPaisUpdateManyArgs>(args: SelectSubset<T, DomainStatusPaisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainStatusPais and returns the data updated in the database.
     * @param {DomainStatusPaisUpdateManyAndReturnArgs} args - Arguments to update many DomainStatusPais.
     * @example
     * // Update many DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainStatusPais and only return the `statusPais`
     * const domainStatusPaisWithStatusPaisOnly = await prisma.domainStatusPais.updateManyAndReturn({
     *   select: { statusPais: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainStatusPaisUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainStatusPaisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainStatusPais.
     * @param {DomainStatusPaisUpsertArgs} args - Arguments to update or create a DomainStatusPais.
     * @example
     * // Update or create a DomainStatusPais
     * const domainStatusPais = await prisma.domainStatusPais.upsert({
     *   create: {
     *     // ... data to create a DomainStatusPais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainStatusPais we want to update
     *   }
     * })
     */
    upsert<T extends DomainStatusPaisUpsertArgs>(args: SelectSubset<T, DomainStatusPaisUpsertArgs<ExtArgs>>): Prisma__DomainStatusPaisClient<$Result.GetResult<Prisma.$DomainStatusPaisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainStatusPais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisCountArgs} args - Arguments to filter DomainStatusPais to count.
     * @example
     * // Count the number of DomainStatusPais
     * const count = await prisma.domainStatusPais.count({
     *   where: {
     *     // ... the filter for the DomainStatusPais we want to count
     *   }
     * })
    **/
    count<T extends DomainStatusPaisCountArgs>(
      args?: Subset<T, DomainStatusPaisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainStatusPaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainStatusPais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainStatusPaisAggregateArgs>(args: Subset<T, DomainStatusPaisAggregateArgs>): Prisma.PrismaPromise<GetDomainStatusPaisAggregateType<T>>

    /**
     * Group by DomainStatusPais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainStatusPaisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainStatusPaisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainStatusPaisGroupByArgs['orderBy'] }
        : { orderBy?: DomainStatusPaisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainStatusPaisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainStatusPaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainStatusPais model
   */
  readonly fields: DomainStatusPaisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainStatusPais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainStatusPaisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontrista<T extends DomainStatusPais$encontristaArgs<ExtArgs> = {}>(args?: Subset<T, DomainStatusPais$encontristaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainStatusPais model
   */
  interface DomainStatusPaisFieldRefs {
    readonly id: FieldRef<"DomainStatusPais", 'Value_StatusPais'>
    readonly statusPais: FieldRef<"DomainStatusPais", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainStatusPais findUnique
   */
  export type DomainStatusPaisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatusPais to fetch.
     */
    where: DomainStatusPaisWhereUniqueInput
  }

  /**
   * DomainStatusPais findUniqueOrThrow
   */
  export type DomainStatusPaisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatusPais to fetch.
     */
    where: DomainStatusPaisWhereUniqueInput
  }

  /**
   * DomainStatusPais findFirst
   */
  export type DomainStatusPaisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatusPais to fetch.
     */
    where?: DomainStatusPaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatusPais to fetch.
     */
    orderBy?: DomainStatusPaisOrderByWithRelationInput | DomainStatusPaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainStatusPais.
     */
    cursor?: DomainStatusPaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatusPais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatusPais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainStatusPais.
     */
    distinct?: DomainStatusPaisScalarFieldEnum | DomainStatusPaisScalarFieldEnum[]
  }

  /**
   * DomainStatusPais findFirstOrThrow
   */
  export type DomainStatusPaisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatusPais to fetch.
     */
    where?: DomainStatusPaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatusPais to fetch.
     */
    orderBy?: DomainStatusPaisOrderByWithRelationInput | DomainStatusPaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainStatusPais.
     */
    cursor?: DomainStatusPaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatusPais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatusPais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainStatusPais.
     */
    distinct?: DomainStatusPaisScalarFieldEnum | DomainStatusPaisScalarFieldEnum[]
  }

  /**
   * DomainStatusPais findMany
   */
  export type DomainStatusPaisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter, which DomainStatusPais to fetch.
     */
    where?: DomainStatusPaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainStatusPais to fetch.
     */
    orderBy?: DomainStatusPaisOrderByWithRelationInput | DomainStatusPaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainStatusPais.
     */
    cursor?: DomainStatusPaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainStatusPais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainStatusPais.
     */
    skip?: number
    distinct?: DomainStatusPaisScalarFieldEnum | DomainStatusPaisScalarFieldEnum[]
  }

  /**
   * DomainStatusPais create
   */
  export type DomainStatusPaisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainStatusPais.
     */
    data: XOR<DomainStatusPaisCreateInput, DomainStatusPaisUncheckedCreateInput>
  }

  /**
   * DomainStatusPais createMany
   */
  export type DomainStatusPaisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainStatusPais.
     */
    data: DomainStatusPaisCreateManyInput | DomainStatusPaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainStatusPais createManyAndReturn
   */
  export type DomainStatusPaisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * The data used to create many DomainStatusPais.
     */
    data: DomainStatusPaisCreateManyInput | DomainStatusPaisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainStatusPais update
   */
  export type DomainStatusPaisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainStatusPais.
     */
    data: XOR<DomainStatusPaisUpdateInput, DomainStatusPaisUncheckedUpdateInput>
    /**
     * Choose, which DomainStatusPais to update.
     */
    where: DomainStatusPaisWhereUniqueInput
  }

  /**
   * DomainStatusPais updateMany
   */
  export type DomainStatusPaisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainStatusPais.
     */
    data: XOR<DomainStatusPaisUpdateManyMutationInput, DomainStatusPaisUncheckedUpdateManyInput>
    /**
     * Filter which DomainStatusPais to update
     */
    where?: DomainStatusPaisWhereInput
    /**
     * Limit how many DomainStatusPais to update.
     */
    limit?: number
  }

  /**
   * DomainStatusPais updateManyAndReturn
   */
  export type DomainStatusPaisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * The data used to update DomainStatusPais.
     */
    data: XOR<DomainStatusPaisUpdateManyMutationInput, DomainStatusPaisUncheckedUpdateManyInput>
    /**
     * Filter which DomainStatusPais to update
     */
    where?: DomainStatusPaisWhereInput
    /**
     * Limit how many DomainStatusPais to update.
     */
    limit?: number
  }

  /**
   * DomainStatusPais upsert
   */
  export type DomainStatusPaisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainStatusPais to update in case it exists.
     */
    where: DomainStatusPaisWhereUniqueInput
    /**
     * In case the DomainStatusPais found by the `where` argument doesn't exist, create a new DomainStatusPais with this data.
     */
    create: XOR<DomainStatusPaisCreateInput, DomainStatusPaisUncheckedCreateInput>
    /**
     * In case the DomainStatusPais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainStatusPaisUpdateInput, DomainStatusPaisUncheckedUpdateInput>
  }

  /**
   * DomainStatusPais delete
   */
  export type DomainStatusPaisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
    /**
     * Filter which DomainStatusPais to delete.
     */
    where: DomainStatusPaisWhereUniqueInput
  }

  /**
   * DomainStatusPais deleteMany
   */
  export type DomainStatusPaisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainStatusPais to delete
     */
    where?: DomainStatusPaisWhereInput
    /**
     * Limit how many DomainStatusPais to delete.
     */
    limit?: number
  }

  /**
   * DomainStatusPais.encontrista
   */
  export type DomainStatusPais$encontristaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontrista
     */
    select?: EncontristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontrista
     */
    omit?: EncontristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontristaInclude<ExtArgs> | null
    where?: EncontristaWhereInput
    orderBy?: EncontristaOrderByWithRelationInput | EncontristaOrderByWithRelationInput[]
    cursor?: EncontristaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontristaScalarFieldEnum | EncontristaScalarFieldEnum[]
  }

  /**
   * DomainStatusPais without action
   */
  export type DomainStatusPaisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainStatusPais
     */
    select?: DomainStatusPaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainStatusPais
     */
    omit?: DomainStatusPaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainStatusPaisInclude<ExtArgs> | null
  }


  /**
   * Model DomainTamanhoCamisa
   */

  export type AggregateDomainTamanhoCamisa = {
    _count: DomainTamanhoCamisaCountAggregateOutputType | null
    _min: DomainTamanhoCamisaMinAggregateOutputType | null
    _max: DomainTamanhoCamisaMaxAggregateOutputType | null
  }

  export type DomainTamanhoCamisaMinAggregateOutputType = {
    id: $Enums.Value_TamanhoCamisa | null
    tamanhoCamisa: string | null
  }

  export type DomainTamanhoCamisaMaxAggregateOutputType = {
    id: $Enums.Value_TamanhoCamisa | null
    tamanhoCamisa: string | null
  }

  export type DomainTamanhoCamisaCountAggregateOutputType = {
    id: number
    tamanhoCamisa: number
    _all: number
  }


  export type DomainTamanhoCamisaMinAggregateInputType = {
    id?: true
    tamanhoCamisa?: true
  }

  export type DomainTamanhoCamisaMaxAggregateInputType = {
    id?: true
    tamanhoCamisa?: true
  }

  export type DomainTamanhoCamisaCountAggregateInputType = {
    id?: true
    tamanhoCamisa?: true
    _all?: true
  }

  export type DomainTamanhoCamisaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainTamanhoCamisa to aggregate.
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainTamanhoCamisas to fetch.
     */
    orderBy?: DomainTamanhoCamisaOrderByWithRelationInput | DomainTamanhoCamisaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainTamanhoCamisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainTamanhoCamisas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainTamanhoCamisas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainTamanhoCamisas
    **/
    _count?: true | DomainTamanhoCamisaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainTamanhoCamisaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainTamanhoCamisaMaxAggregateInputType
  }

  export type GetDomainTamanhoCamisaAggregateType<T extends DomainTamanhoCamisaAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainTamanhoCamisa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainTamanhoCamisa[P]>
      : GetScalarType<T[P], AggregateDomainTamanhoCamisa[P]>
  }




  export type DomainTamanhoCamisaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainTamanhoCamisaWhereInput
    orderBy?: DomainTamanhoCamisaOrderByWithAggregationInput | DomainTamanhoCamisaOrderByWithAggregationInput[]
    by: DomainTamanhoCamisaScalarFieldEnum[] | DomainTamanhoCamisaScalarFieldEnum
    having?: DomainTamanhoCamisaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainTamanhoCamisaCountAggregateInputType | true
    _min?: DomainTamanhoCamisaMinAggregateInputType
    _max?: DomainTamanhoCamisaMaxAggregateInputType
  }

  export type DomainTamanhoCamisaGroupByOutputType = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
    _count: DomainTamanhoCamisaCountAggregateOutputType | null
    _min: DomainTamanhoCamisaMinAggregateOutputType | null
    _max: DomainTamanhoCamisaMaxAggregateOutputType | null
  }

  type GetDomainTamanhoCamisaGroupByPayload<T extends DomainTamanhoCamisaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainTamanhoCamisaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainTamanhoCamisaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainTamanhoCamisaGroupByOutputType[P]>
            : GetScalarType<T[P], DomainTamanhoCamisaGroupByOutputType[P]>
        }
      >
    >


  export type DomainTamanhoCamisaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tamanhoCamisa?: boolean
    encontreiro?: boolean | DomainTamanhoCamisa$encontreiroArgs<ExtArgs>
    _count?: boolean | DomainTamanhoCamisaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainTamanhoCamisa"]>

  export type DomainTamanhoCamisaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tamanhoCamisa?: boolean
  }, ExtArgs["result"]["domainTamanhoCamisa"]>

  export type DomainTamanhoCamisaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tamanhoCamisa?: boolean
  }, ExtArgs["result"]["domainTamanhoCamisa"]>

  export type DomainTamanhoCamisaSelectScalar = {
    id?: boolean
    tamanhoCamisa?: boolean
  }

  export type DomainTamanhoCamisaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tamanhoCamisa", ExtArgs["result"]["domainTamanhoCamisa"]>
  export type DomainTamanhoCamisaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | DomainTamanhoCamisa$encontreiroArgs<ExtArgs>
    _count?: boolean | DomainTamanhoCamisaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainTamanhoCamisaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainTamanhoCamisaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainTamanhoCamisaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainTamanhoCamisa"
    objects: {
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_TamanhoCamisa
      tamanhoCamisa: string
    }, ExtArgs["result"]["domainTamanhoCamisa"]>
    composites: {}
  }

  type DomainTamanhoCamisaGetPayload<S extends boolean | null | undefined | DomainTamanhoCamisaDefaultArgs> = $Result.GetResult<Prisma.$DomainTamanhoCamisaPayload, S>

  type DomainTamanhoCamisaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainTamanhoCamisaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainTamanhoCamisaCountAggregateInputType | true
    }

  export interface DomainTamanhoCamisaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainTamanhoCamisa'], meta: { name: 'DomainTamanhoCamisa' } }
    /**
     * Find zero or one DomainTamanhoCamisa that matches the filter.
     * @param {DomainTamanhoCamisaFindUniqueArgs} args - Arguments to find a DomainTamanhoCamisa
     * @example
     * // Get one DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainTamanhoCamisaFindUniqueArgs>(args: SelectSubset<T, DomainTamanhoCamisaFindUniqueArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainTamanhoCamisa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainTamanhoCamisaFindUniqueOrThrowArgs} args - Arguments to find a DomainTamanhoCamisa
     * @example
     * // Get one DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainTamanhoCamisaFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainTamanhoCamisaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainTamanhoCamisa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaFindFirstArgs} args - Arguments to find a DomainTamanhoCamisa
     * @example
     * // Get one DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainTamanhoCamisaFindFirstArgs>(args?: SelectSubset<T, DomainTamanhoCamisaFindFirstArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainTamanhoCamisa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaFindFirstOrThrowArgs} args - Arguments to find a DomainTamanhoCamisa
     * @example
     * // Get one DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainTamanhoCamisaFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainTamanhoCamisaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainTamanhoCamisas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainTamanhoCamisas
     * const domainTamanhoCamisas = await prisma.domainTamanhoCamisa.findMany()
     * 
     * // Get first 10 DomainTamanhoCamisas
     * const domainTamanhoCamisas = await prisma.domainTamanhoCamisa.findMany({ take: 10 })
     * 
     * // Only select the `tamanhoCamisa`
     * const domainTamanhoCamisaWithTamanhoCamisaOnly = await prisma.domainTamanhoCamisa.findMany({ select: { tamanhoCamisa: true } })
     * 
     */
    findMany<T extends DomainTamanhoCamisaFindManyArgs>(args?: SelectSubset<T, DomainTamanhoCamisaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainTamanhoCamisa.
     * @param {DomainTamanhoCamisaCreateArgs} args - Arguments to create a DomainTamanhoCamisa.
     * @example
     * // Create one DomainTamanhoCamisa
     * const DomainTamanhoCamisa = await prisma.domainTamanhoCamisa.create({
     *   data: {
     *     // ... data to create a DomainTamanhoCamisa
     *   }
     * })
     * 
     */
    create<T extends DomainTamanhoCamisaCreateArgs>(args: SelectSubset<T, DomainTamanhoCamisaCreateArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainTamanhoCamisas.
     * @param {DomainTamanhoCamisaCreateManyArgs} args - Arguments to create many DomainTamanhoCamisas.
     * @example
     * // Create many DomainTamanhoCamisas
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainTamanhoCamisaCreateManyArgs>(args?: SelectSubset<T, DomainTamanhoCamisaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainTamanhoCamisas and returns the data saved in the database.
     * @param {DomainTamanhoCamisaCreateManyAndReturnArgs} args - Arguments to create many DomainTamanhoCamisas.
     * @example
     * // Create many DomainTamanhoCamisas
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainTamanhoCamisas and only return the `tamanhoCamisa`
     * const domainTamanhoCamisaWithTamanhoCamisaOnly = await prisma.domainTamanhoCamisa.createManyAndReturn({
     *   select: { tamanhoCamisa: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainTamanhoCamisaCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainTamanhoCamisaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainTamanhoCamisa.
     * @param {DomainTamanhoCamisaDeleteArgs} args - Arguments to delete one DomainTamanhoCamisa.
     * @example
     * // Delete one DomainTamanhoCamisa
     * const DomainTamanhoCamisa = await prisma.domainTamanhoCamisa.delete({
     *   where: {
     *     // ... filter to delete one DomainTamanhoCamisa
     *   }
     * })
     * 
     */
    delete<T extends DomainTamanhoCamisaDeleteArgs>(args: SelectSubset<T, DomainTamanhoCamisaDeleteArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainTamanhoCamisa.
     * @param {DomainTamanhoCamisaUpdateArgs} args - Arguments to update one DomainTamanhoCamisa.
     * @example
     * // Update one DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainTamanhoCamisaUpdateArgs>(args: SelectSubset<T, DomainTamanhoCamisaUpdateArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainTamanhoCamisas.
     * @param {DomainTamanhoCamisaDeleteManyArgs} args - Arguments to filter DomainTamanhoCamisas to delete.
     * @example
     * // Delete a few DomainTamanhoCamisas
     * const { count } = await prisma.domainTamanhoCamisa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainTamanhoCamisaDeleteManyArgs>(args?: SelectSubset<T, DomainTamanhoCamisaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainTamanhoCamisas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainTamanhoCamisas
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainTamanhoCamisaUpdateManyArgs>(args: SelectSubset<T, DomainTamanhoCamisaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainTamanhoCamisas and returns the data updated in the database.
     * @param {DomainTamanhoCamisaUpdateManyAndReturnArgs} args - Arguments to update many DomainTamanhoCamisas.
     * @example
     * // Update many DomainTamanhoCamisas
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainTamanhoCamisas and only return the `tamanhoCamisa`
     * const domainTamanhoCamisaWithTamanhoCamisaOnly = await prisma.domainTamanhoCamisa.updateManyAndReturn({
     *   select: { tamanhoCamisa: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainTamanhoCamisaUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainTamanhoCamisaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainTamanhoCamisa.
     * @param {DomainTamanhoCamisaUpsertArgs} args - Arguments to update or create a DomainTamanhoCamisa.
     * @example
     * // Update or create a DomainTamanhoCamisa
     * const domainTamanhoCamisa = await prisma.domainTamanhoCamisa.upsert({
     *   create: {
     *     // ... data to create a DomainTamanhoCamisa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainTamanhoCamisa we want to update
     *   }
     * })
     */
    upsert<T extends DomainTamanhoCamisaUpsertArgs>(args: SelectSubset<T, DomainTamanhoCamisaUpsertArgs<ExtArgs>>): Prisma__DomainTamanhoCamisaClient<$Result.GetResult<Prisma.$DomainTamanhoCamisaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainTamanhoCamisas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaCountArgs} args - Arguments to filter DomainTamanhoCamisas to count.
     * @example
     * // Count the number of DomainTamanhoCamisas
     * const count = await prisma.domainTamanhoCamisa.count({
     *   where: {
     *     // ... the filter for the DomainTamanhoCamisas we want to count
     *   }
     * })
    **/
    count<T extends DomainTamanhoCamisaCountArgs>(
      args?: Subset<T, DomainTamanhoCamisaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainTamanhoCamisaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainTamanhoCamisa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainTamanhoCamisaAggregateArgs>(args: Subset<T, DomainTamanhoCamisaAggregateArgs>): Prisma.PrismaPromise<GetDomainTamanhoCamisaAggregateType<T>>

    /**
     * Group by DomainTamanhoCamisa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainTamanhoCamisaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainTamanhoCamisaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainTamanhoCamisaGroupByArgs['orderBy'] }
        : { orderBy?: DomainTamanhoCamisaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainTamanhoCamisaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainTamanhoCamisaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainTamanhoCamisa model
   */
  readonly fields: DomainTamanhoCamisaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainTamanhoCamisa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainTamanhoCamisaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontreiro<T extends DomainTamanhoCamisa$encontreiroArgs<ExtArgs> = {}>(args?: Subset<T, DomainTamanhoCamisa$encontreiroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainTamanhoCamisa model
   */
  interface DomainTamanhoCamisaFieldRefs {
    readonly id: FieldRef<"DomainTamanhoCamisa", 'Value_TamanhoCamisa'>
    readonly tamanhoCamisa: FieldRef<"DomainTamanhoCamisa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainTamanhoCamisa findUnique
   */
  export type DomainTamanhoCamisaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter, which DomainTamanhoCamisa to fetch.
     */
    where: DomainTamanhoCamisaWhereUniqueInput
  }

  /**
   * DomainTamanhoCamisa findUniqueOrThrow
   */
  export type DomainTamanhoCamisaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter, which DomainTamanhoCamisa to fetch.
     */
    where: DomainTamanhoCamisaWhereUniqueInput
  }

  /**
   * DomainTamanhoCamisa findFirst
   */
  export type DomainTamanhoCamisaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter, which DomainTamanhoCamisa to fetch.
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainTamanhoCamisas to fetch.
     */
    orderBy?: DomainTamanhoCamisaOrderByWithRelationInput | DomainTamanhoCamisaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainTamanhoCamisas.
     */
    cursor?: DomainTamanhoCamisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainTamanhoCamisas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainTamanhoCamisas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainTamanhoCamisas.
     */
    distinct?: DomainTamanhoCamisaScalarFieldEnum | DomainTamanhoCamisaScalarFieldEnum[]
  }

  /**
   * DomainTamanhoCamisa findFirstOrThrow
   */
  export type DomainTamanhoCamisaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter, which DomainTamanhoCamisa to fetch.
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainTamanhoCamisas to fetch.
     */
    orderBy?: DomainTamanhoCamisaOrderByWithRelationInput | DomainTamanhoCamisaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainTamanhoCamisas.
     */
    cursor?: DomainTamanhoCamisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainTamanhoCamisas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainTamanhoCamisas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainTamanhoCamisas.
     */
    distinct?: DomainTamanhoCamisaScalarFieldEnum | DomainTamanhoCamisaScalarFieldEnum[]
  }

  /**
   * DomainTamanhoCamisa findMany
   */
  export type DomainTamanhoCamisaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter, which DomainTamanhoCamisas to fetch.
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainTamanhoCamisas to fetch.
     */
    orderBy?: DomainTamanhoCamisaOrderByWithRelationInput | DomainTamanhoCamisaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainTamanhoCamisas.
     */
    cursor?: DomainTamanhoCamisaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainTamanhoCamisas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainTamanhoCamisas.
     */
    skip?: number
    distinct?: DomainTamanhoCamisaScalarFieldEnum | DomainTamanhoCamisaScalarFieldEnum[]
  }

  /**
   * DomainTamanhoCamisa create
   */
  export type DomainTamanhoCamisaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainTamanhoCamisa.
     */
    data: XOR<DomainTamanhoCamisaCreateInput, DomainTamanhoCamisaUncheckedCreateInput>
  }

  /**
   * DomainTamanhoCamisa createMany
   */
  export type DomainTamanhoCamisaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainTamanhoCamisas.
     */
    data: DomainTamanhoCamisaCreateManyInput | DomainTamanhoCamisaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainTamanhoCamisa createManyAndReturn
   */
  export type DomainTamanhoCamisaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * The data used to create many DomainTamanhoCamisas.
     */
    data: DomainTamanhoCamisaCreateManyInput | DomainTamanhoCamisaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainTamanhoCamisa update
   */
  export type DomainTamanhoCamisaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainTamanhoCamisa.
     */
    data: XOR<DomainTamanhoCamisaUpdateInput, DomainTamanhoCamisaUncheckedUpdateInput>
    /**
     * Choose, which DomainTamanhoCamisa to update.
     */
    where: DomainTamanhoCamisaWhereUniqueInput
  }

  /**
   * DomainTamanhoCamisa updateMany
   */
  export type DomainTamanhoCamisaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainTamanhoCamisas.
     */
    data: XOR<DomainTamanhoCamisaUpdateManyMutationInput, DomainTamanhoCamisaUncheckedUpdateManyInput>
    /**
     * Filter which DomainTamanhoCamisas to update
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * Limit how many DomainTamanhoCamisas to update.
     */
    limit?: number
  }

  /**
   * DomainTamanhoCamisa updateManyAndReturn
   */
  export type DomainTamanhoCamisaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * The data used to update DomainTamanhoCamisas.
     */
    data: XOR<DomainTamanhoCamisaUpdateManyMutationInput, DomainTamanhoCamisaUncheckedUpdateManyInput>
    /**
     * Filter which DomainTamanhoCamisas to update
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * Limit how many DomainTamanhoCamisas to update.
     */
    limit?: number
  }

  /**
   * DomainTamanhoCamisa upsert
   */
  export type DomainTamanhoCamisaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainTamanhoCamisa to update in case it exists.
     */
    where: DomainTamanhoCamisaWhereUniqueInput
    /**
     * In case the DomainTamanhoCamisa found by the `where` argument doesn't exist, create a new DomainTamanhoCamisa with this data.
     */
    create: XOR<DomainTamanhoCamisaCreateInput, DomainTamanhoCamisaUncheckedCreateInput>
    /**
     * In case the DomainTamanhoCamisa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainTamanhoCamisaUpdateInput, DomainTamanhoCamisaUncheckedUpdateInput>
  }

  /**
   * DomainTamanhoCamisa delete
   */
  export type DomainTamanhoCamisaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
    /**
     * Filter which DomainTamanhoCamisa to delete.
     */
    where: DomainTamanhoCamisaWhereUniqueInput
  }

  /**
   * DomainTamanhoCamisa deleteMany
   */
  export type DomainTamanhoCamisaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainTamanhoCamisas to delete
     */
    where?: DomainTamanhoCamisaWhereInput
    /**
     * Limit how many DomainTamanhoCamisas to delete.
     */
    limit?: number
  }

  /**
   * DomainTamanhoCamisa.encontreiro
   */
  export type DomainTamanhoCamisa$encontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    cursor?: EncontreiroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * DomainTamanhoCamisa without action
   */
  export type DomainTamanhoCamisaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainTamanhoCamisa
     */
    select?: DomainTamanhoCamisaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainTamanhoCamisa
     */
    omit?: DomainTamanhoCamisaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainTamanhoCamisaInclude<ExtArgs> | null
  }


  /**
   * Model DomainCorCirculo
   */

  export type AggregateDomainCorCirculo = {
    _count: DomainCorCirculoCountAggregateOutputType | null
    _avg: DomainCorCirculoAvgAggregateOutputType | null
    _sum: DomainCorCirculoSumAggregateOutputType | null
    _min: DomainCorCirculoMinAggregateOutputType | null
    _max: DomainCorCirculoMaxAggregateOutputType | null
  }

  export type DomainCorCirculoAvgAggregateOutputType = {
    id: number | null
  }

  export type DomainCorCirculoSumAggregateOutputType = {
    id: number | null
  }

  export type DomainCorCirculoMinAggregateOutputType = {
    id: number | null
    cor: string | null
  }

  export type DomainCorCirculoMaxAggregateOutputType = {
    id: number | null
    cor: string | null
  }

  export type DomainCorCirculoCountAggregateOutputType = {
    id: number
    cor: number
    _all: number
  }


  export type DomainCorCirculoAvgAggregateInputType = {
    id?: true
  }

  export type DomainCorCirculoSumAggregateInputType = {
    id?: true
  }

  export type DomainCorCirculoMinAggregateInputType = {
    id?: true
    cor?: true
  }

  export type DomainCorCirculoMaxAggregateInputType = {
    id?: true
    cor?: true
  }

  export type DomainCorCirculoCountAggregateInputType = {
    id?: true
    cor?: true
    _all?: true
  }

  export type DomainCorCirculoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainCorCirculo to aggregate.
     */
    where?: DomainCorCirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainCorCirculos to fetch.
     */
    orderBy?: DomainCorCirculoOrderByWithRelationInput | DomainCorCirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainCorCirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainCorCirculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainCorCirculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainCorCirculos
    **/
    _count?: true | DomainCorCirculoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainCorCirculoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainCorCirculoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainCorCirculoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainCorCirculoMaxAggregateInputType
  }

  export type GetDomainCorCirculoAggregateType<T extends DomainCorCirculoAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainCorCirculo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainCorCirculo[P]>
      : GetScalarType<T[P], AggregateDomainCorCirculo[P]>
  }




  export type DomainCorCirculoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainCorCirculoWhereInput
    orderBy?: DomainCorCirculoOrderByWithAggregationInput | DomainCorCirculoOrderByWithAggregationInput[]
    by: DomainCorCirculoScalarFieldEnum[] | DomainCorCirculoScalarFieldEnum
    having?: DomainCorCirculoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainCorCirculoCountAggregateInputType | true
    _avg?: DomainCorCirculoAvgAggregateInputType
    _sum?: DomainCorCirculoSumAggregateInputType
    _min?: DomainCorCirculoMinAggregateInputType
    _max?: DomainCorCirculoMaxAggregateInputType
  }

  export type DomainCorCirculoGroupByOutputType = {
    id: number
    cor: string
    _count: DomainCorCirculoCountAggregateOutputType | null
    _avg: DomainCorCirculoAvgAggregateOutputType | null
    _sum: DomainCorCirculoSumAggregateOutputType | null
    _min: DomainCorCirculoMinAggregateOutputType | null
    _max: DomainCorCirculoMaxAggregateOutputType | null
  }

  type GetDomainCorCirculoGroupByPayload<T extends DomainCorCirculoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainCorCirculoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainCorCirculoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainCorCirculoGroupByOutputType[P]>
            : GetScalarType<T[P], DomainCorCirculoGroupByOutputType[P]>
        }
      >
    >


  export type DomainCorCirculoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cor?: boolean
    circulo?: boolean | DomainCorCirculo$circuloArgs<ExtArgs>
    _count?: boolean | DomainCorCirculoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainCorCirculo"]>

  export type DomainCorCirculoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cor?: boolean
  }, ExtArgs["result"]["domainCorCirculo"]>

  export type DomainCorCirculoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cor?: boolean
  }, ExtArgs["result"]["domainCorCirculo"]>

  export type DomainCorCirculoSelectScalar = {
    id?: boolean
    cor?: boolean
  }

  export type DomainCorCirculoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cor", ExtArgs["result"]["domainCorCirculo"]>
  export type DomainCorCirculoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    circulo?: boolean | DomainCorCirculo$circuloArgs<ExtArgs>
    _count?: boolean | DomainCorCirculoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainCorCirculoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainCorCirculoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainCorCirculoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainCorCirculo"
    objects: {
      circulo: Prisma.$CirculoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cor: string
    }, ExtArgs["result"]["domainCorCirculo"]>
    composites: {}
  }

  type DomainCorCirculoGetPayload<S extends boolean | null | undefined | DomainCorCirculoDefaultArgs> = $Result.GetResult<Prisma.$DomainCorCirculoPayload, S>

  type DomainCorCirculoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainCorCirculoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainCorCirculoCountAggregateInputType | true
    }

  export interface DomainCorCirculoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainCorCirculo'], meta: { name: 'DomainCorCirculo' } }
    /**
     * Find zero or one DomainCorCirculo that matches the filter.
     * @param {DomainCorCirculoFindUniqueArgs} args - Arguments to find a DomainCorCirculo
     * @example
     * // Get one DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainCorCirculoFindUniqueArgs>(args: SelectSubset<T, DomainCorCirculoFindUniqueArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainCorCirculo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainCorCirculoFindUniqueOrThrowArgs} args - Arguments to find a DomainCorCirculo
     * @example
     * // Get one DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainCorCirculoFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainCorCirculoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainCorCirculo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoFindFirstArgs} args - Arguments to find a DomainCorCirculo
     * @example
     * // Get one DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainCorCirculoFindFirstArgs>(args?: SelectSubset<T, DomainCorCirculoFindFirstArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainCorCirculo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoFindFirstOrThrowArgs} args - Arguments to find a DomainCorCirculo
     * @example
     * // Get one DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainCorCirculoFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainCorCirculoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainCorCirculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainCorCirculos
     * const domainCorCirculos = await prisma.domainCorCirculo.findMany()
     * 
     * // Get first 10 DomainCorCirculos
     * const domainCorCirculos = await prisma.domainCorCirculo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainCorCirculoWithIdOnly = await prisma.domainCorCirculo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainCorCirculoFindManyArgs>(args?: SelectSubset<T, DomainCorCirculoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainCorCirculo.
     * @param {DomainCorCirculoCreateArgs} args - Arguments to create a DomainCorCirculo.
     * @example
     * // Create one DomainCorCirculo
     * const DomainCorCirculo = await prisma.domainCorCirculo.create({
     *   data: {
     *     // ... data to create a DomainCorCirculo
     *   }
     * })
     * 
     */
    create<T extends DomainCorCirculoCreateArgs>(args: SelectSubset<T, DomainCorCirculoCreateArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainCorCirculos.
     * @param {DomainCorCirculoCreateManyArgs} args - Arguments to create many DomainCorCirculos.
     * @example
     * // Create many DomainCorCirculos
     * const domainCorCirculo = await prisma.domainCorCirculo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainCorCirculoCreateManyArgs>(args?: SelectSubset<T, DomainCorCirculoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainCorCirculos and returns the data saved in the database.
     * @param {DomainCorCirculoCreateManyAndReturnArgs} args - Arguments to create many DomainCorCirculos.
     * @example
     * // Create many DomainCorCirculos
     * const domainCorCirculo = await prisma.domainCorCirculo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainCorCirculos and only return the `id`
     * const domainCorCirculoWithIdOnly = await prisma.domainCorCirculo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainCorCirculoCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainCorCirculoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainCorCirculo.
     * @param {DomainCorCirculoDeleteArgs} args - Arguments to delete one DomainCorCirculo.
     * @example
     * // Delete one DomainCorCirculo
     * const DomainCorCirculo = await prisma.domainCorCirculo.delete({
     *   where: {
     *     // ... filter to delete one DomainCorCirculo
     *   }
     * })
     * 
     */
    delete<T extends DomainCorCirculoDeleteArgs>(args: SelectSubset<T, DomainCorCirculoDeleteArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainCorCirculo.
     * @param {DomainCorCirculoUpdateArgs} args - Arguments to update one DomainCorCirculo.
     * @example
     * // Update one DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainCorCirculoUpdateArgs>(args: SelectSubset<T, DomainCorCirculoUpdateArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainCorCirculos.
     * @param {DomainCorCirculoDeleteManyArgs} args - Arguments to filter DomainCorCirculos to delete.
     * @example
     * // Delete a few DomainCorCirculos
     * const { count } = await prisma.domainCorCirculo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainCorCirculoDeleteManyArgs>(args?: SelectSubset<T, DomainCorCirculoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainCorCirculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainCorCirculos
     * const domainCorCirculo = await prisma.domainCorCirculo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainCorCirculoUpdateManyArgs>(args: SelectSubset<T, DomainCorCirculoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainCorCirculos and returns the data updated in the database.
     * @param {DomainCorCirculoUpdateManyAndReturnArgs} args - Arguments to update many DomainCorCirculos.
     * @example
     * // Update many DomainCorCirculos
     * const domainCorCirculo = await prisma.domainCorCirculo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainCorCirculos and only return the `id`
     * const domainCorCirculoWithIdOnly = await prisma.domainCorCirculo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainCorCirculoUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainCorCirculoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainCorCirculo.
     * @param {DomainCorCirculoUpsertArgs} args - Arguments to update or create a DomainCorCirculo.
     * @example
     * // Update or create a DomainCorCirculo
     * const domainCorCirculo = await prisma.domainCorCirculo.upsert({
     *   create: {
     *     // ... data to create a DomainCorCirculo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainCorCirculo we want to update
     *   }
     * })
     */
    upsert<T extends DomainCorCirculoUpsertArgs>(args: SelectSubset<T, DomainCorCirculoUpsertArgs<ExtArgs>>): Prisma__DomainCorCirculoClient<$Result.GetResult<Prisma.$DomainCorCirculoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainCorCirculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoCountArgs} args - Arguments to filter DomainCorCirculos to count.
     * @example
     * // Count the number of DomainCorCirculos
     * const count = await prisma.domainCorCirculo.count({
     *   where: {
     *     // ... the filter for the DomainCorCirculos we want to count
     *   }
     * })
    **/
    count<T extends DomainCorCirculoCountArgs>(
      args?: Subset<T, DomainCorCirculoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainCorCirculoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainCorCirculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainCorCirculoAggregateArgs>(args: Subset<T, DomainCorCirculoAggregateArgs>): Prisma.PrismaPromise<GetDomainCorCirculoAggregateType<T>>

    /**
     * Group by DomainCorCirculo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainCorCirculoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainCorCirculoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainCorCirculoGroupByArgs['orderBy'] }
        : { orderBy?: DomainCorCirculoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainCorCirculoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainCorCirculoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainCorCirculo model
   */
  readonly fields: DomainCorCirculoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainCorCirculo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainCorCirculoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    circulo<T extends DomainCorCirculo$circuloArgs<ExtArgs> = {}>(args?: Subset<T, DomainCorCirculo$circuloArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CirculoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainCorCirculo model
   */
  interface DomainCorCirculoFieldRefs {
    readonly id: FieldRef<"DomainCorCirculo", 'Int'>
    readonly cor: FieldRef<"DomainCorCirculo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainCorCirculo findUnique
   */
  export type DomainCorCirculoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter, which DomainCorCirculo to fetch.
     */
    where: DomainCorCirculoWhereUniqueInput
  }

  /**
   * DomainCorCirculo findUniqueOrThrow
   */
  export type DomainCorCirculoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter, which DomainCorCirculo to fetch.
     */
    where: DomainCorCirculoWhereUniqueInput
  }

  /**
   * DomainCorCirculo findFirst
   */
  export type DomainCorCirculoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter, which DomainCorCirculo to fetch.
     */
    where?: DomainCorCirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainCorCirculos to fetch.
     */
    orderBy?: DomainCorCirculoOrderByWithRelationInput | DomainCorCirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainCorCirculos.
     */
    cursor?: DomainCorCirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainCorCirculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainCorCirculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainCorCirculos.
     */
    distinct?: DomainCorCirculoScalarFieldEnum | DomainCorCirculoScalarFieldEnum[]
  }

  /**
   * DomainCorCirculo findFirstOrThrow
   */
  export type DomainCorCirculoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter, which DomainCorCirculo to fetch.
     */
    where?: DomainCorCirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainCorCirculos to fetch.
     */
    orderBy?: DomainCorCirculoOrderByWithRelationInput | DomainCorCirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainCorCirculos.
     */
    cursor?: DomainCorCirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainCorCirculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainCorCirculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainCorCirculos.
     */
    distinct?: DomainCorCirculoScalarFieldEnum | DomainCorCirculoScalarFieldEnum[]
  }

  /**
   * DomainCorCirculo findMany
   */
  export type DomainCorCirculoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter, which DomainCorCirculos to fetch.
     */
    where?: DomainCorCirculoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainCorCirculos to fetch.
     */
    orderBy?: DomainCorCirculoOrderByWithRelationInput | DomainCorCirculoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainCorCirculos.
     */
    cursor?: DomainCorCirculoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainCorCirculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainCorCirculos.
     */
    skip?: number
    distinct?: DomainCorCirculoScalarFieldEnum | DomainCorCirculoScalarFieldEnum[]
  }

  /**
   * DomainCorCirculo create
   */
  export type DomainCorCirculoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainCorCirculo.
     */
    data: XOR<DomainCorCirculoCreateInput, DomainCorCirculoUncheckedCreateInput>
  }

  /**
   * DomainCorCirculo createMany
   */
  export type DomainCorCirculoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainCorCirculos.
     */
    data: DomainCorCirculoCreateManyInput | DomainCorCirculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainCorCirculo createManyAndReturn
   */
  export type DomainCorCirculoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * The data used to create many DomainCorCirculos.
     */
    data: DomainCorCirculoCreateManyInput | DomainCorCirculoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainCorCirculo update
   */
  export type DomainCorCirculoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainCorCirculo.
     */
    data: XOR<DomainCorCirculoUpdateInput, DomainCorCirculoUncheckedUpdateInput>
    /**
     * Choose, which DomainCorCirculo to update.
     */
    where: DomainCorCirculoWhereUniqueInput
  }

  /**
   * DomainCorCirculo updateMany
   */
  export type DomainCorCirculoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainCorCirculos.
     */
    data: XOR<DomainCorCirculoUpdateManyMutationInput, DomainCorCirculoUncheckedUpdateManyInput>
    /**
     * Filter which DomainCorCirculos to update
     */
    where?: DomainCorCirculoWhereInput
    /**
     * Limit how many DomainCorCirculos to update.
     */
    limit?: number
  }

  /**
   * DomainCorCirculo updateManyAndReturn
   */
  export type DomainCorCirculoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * The data used to update DomainCorCirculos.
     */
    data: XOR<DomainCorCirculoUpdateManyMutationInput, DomainCorCirculoUncheckedUpdateManyInput>
    /**
     * Filter which DomainCorCirculos to update
     */
    where?: DomainCorCirculoWhereInput
    /**
     * Limit how many DomainCorCirculos to update.
     */
    limit?: number
  }

  /**
   * DomainCorCirculo upsert
   */
  export type DomainCorCirculoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainCorCirculo to update in case it exists.
     */
    where: DomainCorCirculoWhereUniqueInput
    /**
     * In case the DomainCorCirculo found by the `where` argument doesn't exist, create a new DomainCorCirculo with this data.
     */
    create: XOR<DomainCorCirculoCreateInput, DomainCorCirculoUncheckedCreateInput>
    /**
     * In case the DomainCorCirculo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainCorCirculoUpdateInput, DomainCorCirculoUncheckedUpdateInput>
  }

  /**
   * DomainCorCirculo delete
   */
  export type DomainCorCirculoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
    /**
     * Filter which DomainCorCirculo to delete.
     */
    where: DomainCorCirculoWhereUniqueInput
  }

  /**
   * DomainCorCirculo deleteMany
   */
  export type DomainCorCirculoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainCorCirculos to delete
     */
    where?: DomainCorCirculoWhereInput
    /**
     * Limit how many DomainCorCirculos to delete.
     */
    limit?: number
  }

  /**
   * DomainCorCirculo.circulo
   */
  export type DomainCorCirculo$circuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Circulo
     */
    select?: CirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Circulo
     */
    omit?: CirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CirculoInclude<ExtArgs> | null
    where?: CirculoWhereInput
    orderBy?: CirculoOrderByWithRelationInput | CirculoOrderByWithRelationInput[]
    cursor?: CirculoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CirculoScalarFieldEnum | CirculoScalarFieldEnum[]
  }

  /**
   * DomainCorCirculo without action
   */
  export type DomainCorCirculoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainCorCirculo
     */
    select?: DomainCorCirculoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainCorCirculo
     */
    omit?: DomainCorCirculoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainCorCirculoInclude<ExtArgs> | null
  }


  /**
   * Model DomainDisponibilidade
   */

  export type AggregateDomainDisponibilidade = {
    _count: DomainDisponibilidadeCountAggregateOutputType | null
    _avg: DomainDisponibilidadeAvgAggregateOutputType | null
    _sum: DomainDisponibilidadeSumAggregateOutputType | null
    _min: DomainDisponibilidadeMinAggregateOutputType | null
    _max: DomainDisponibilidadeMaxAggregateOutputType | null
  }

  export type DomainDisponibilidadeAvgAggregateOutputType = {
    order: number | null
  }

  export type DomainDisponibilidadeSumAggregateOutputType = {
    order: number | null
  }

  export type DomainDisponibilidadeMinAggregateOutputType = {
    id: $Enums.Value_Disponibilidade | null
    order: number | null
    disponibilidade: string | null
    descricao: string | null
  }

  export type DomainDisponibilidadeMaxAggregateOutputType = {
    id: $Enums.Value_Disponibilidade | null
    order: number | null
    disponibilidade: string | null
    descricao: string | null
  }

  export type DomainDisponibilidadeCountAggregateOutputType = {
    id: number
    order: number
    disponibilidade: number
    descricao: number
    _all: number
  }


  export type DomainDisponibilidadeAvgAggregateInputType = {
    order?: true
  }

  export type DomainDisponibilidadeSumAggregateInputType = {
    order?: true
  }

  export type DomainDisponibilidadeMinAggregateInputType = {
    id?: true
    order?: true
    disponibilidade?: true
    descricao?: true
  }

  export type DomainDisponibilidadeMaxAggregateInputType = {
    id?: true
    order?: true
    disponibilidade?: true
    descricao?: true
  }

  export type DomainDisponibilidadeCountAggregateInputType = {
    id?: true
    order?: true
    disponibilidade?: true
    descricao?: true
    _all?: true
  }

  export type DomainDisponibilidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainDisponibilidade to aggregate.
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDisponibilidades to fetch.
     */
    orderBy?: DomainDisponibilidadeOrderByWithRelationInput | DomainDisponibilidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainDisponibilidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDisponibilidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDisponibilidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainDisponibilidades
    **/
    _count?: true | DomainDisponibilidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainDisponibilidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainDisponibilidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainDisponibilidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainDisponibilidadeMaxAggregateInputType
  }

  export type GetDomainDisponibilidadeAggregateType<T extends DomainDisponibilidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainDisponibilidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainDisponibilidade[P]>
      : GetScalarType<T[P], AggregateDomainDisponibilidade[P]>
  }




  export type DomainDisponibilidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainDisponibilidadeWhereInput
    orderBy?: DomainDisponibilidadeOrderByWithAggregationInput | DomainDisponibilidadeOrderByWithAggregationInput[]
    by: DomainDisponibilidadeScalarFieldEnum[] | DomainDisponibilidadeScalarFieldEnum
    having?: DomainDisponibilidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainDisponibilidadeCountAggregateInputType | true
    _avg?: DomainDisponibilidadeAvgAggregateInputType
    _sum?: DomainDisponibilidadeSumAggregateInputType
    _min?: DomainDisponibilidadeMinAggregateInputType
    _max?: DomainDisponibilidadeMaxAggregateInputType
  }

  export type DomainDisponibilidadeGroupByOutputType = {
    id: $Enums.Value_Disponibilidade
    order: number
    disponibilidade: string
    descricao: string
    _count: DomainDisponibilidadeCountAggregateOutputType | null
    _avg: DomainDisponibilidadeAvgAggregateOutputType | null
    _sum: DomainDisponibilidadeSumAggregateOutputType | null
    _min: DomainDisponibilidadeMinAggregateOutputType | null
    _max: DomainDisponibilidadeMaxAggregateOutputType | null
  }

  type GetDomainDisponibilidadeGroupByPayload<T extends DomainDisponibilidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainDisponibilidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainDisponibilidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainDisponibilidadeGroupByOutputType[P]>
            : GetScalarType<T[P], DomainDisponibilidadeGroupByOutputType[P]>
        }
      >
    >


  export type DomainDisponibilidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    disponibilidade?: boolean
    descricao?: boolean
    encontreiro?: boolean | DomainDisponibilidade$encontreiroArgs<ExtArgs>
    _count?: boolean | DomainDisponibilidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainDisponibilidade"]>

  export type DomainDisponibilidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    disponibilidade?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["domainDisponibilidade"]>

  export type DomainDisponibilidadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    disponibilidade?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["domainDisponibilidade"]>

  export type DomainDisponibilidadeSelectScalar = {
    id?: boolean
    order?: boolean
    disponibilidade?: boolean
    descricao?: boolean
  }

  export type DomainDisponibilidadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "disponibilidade" | "descricao", ExtArgs["result"]["domainDisponibilidade"]>
  export type DomainDisponibilidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encontreiro?: boolean | DomainDisponibilidade$encontreiroArgs<ExtArgs>
    _count?: boolean | DomainDisponibilidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainDisponibilidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainDisponibilidadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainDisponibilidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainDisponibilidade"
    objects: {
      encontreiro: Prisma.$EncontreiroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: $Enums.Value_Disponibilidade
      order: number
      disponibilidade: string
      descricao: string
    }, ExtArgs["result"]["domainDisponibilidade"]>
    composites: {}
  }

  type DomainDisponibilidadeGetPayload<S extends boolean | null | undefined | DomainDisponibilidadeDefaultArgs> = $Result.GetResult<Prisma.$DomainDisponibilidadePayload, S>

  type DomainDisponibilidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainDisponibilidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainDisponibilidadeCountAggregateInputType | true
    }

  export interface DomainDisponibilidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainDisponibilidade'], meta: { name: 'DomainDisponibilidade' } }
    /**
     * Find zero or one DomainDisponibilidade that matches the filter.
     * @param {DomainDisponibilidadeFindUniqueArgs} args - Arguments to find a DomainDisponibilidade
     * @example
     * // Get one DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainDisponibilidadeFindUniqueArgs>(args: SelectSubset<T, DomainDisponibilidadeFindUniqueArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainDisponibilidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainDisponibilidadeFindUniqueOrThrowArgs} args - Arguments to find a DomainDisponibilidade
     * @example
     * // Get one DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainDisponibilidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainDisponibilidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainDisponibilidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeFindFirstArgs} args - Arguments to find a DomainDisponibilidade
     * @example
     * // Get one DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainDisponibilidadeFindFirstArgs>(args?: SelectSubset<T, DomainDisponibilidadeFindFirstArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainDisponibilidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeFindFirstOrThrowArgs} args - Arguments to find a DomainDisponibilidade
     * @example
     * // Get one DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainDisponibilidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainDisponibilidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainDisponibilidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainDisponibilidades
     * const domainDisponibilidades = await prisma.domainDisponibilidade.findMany()
     * 
     * // Get first 10 DomainDisponibilidades
     * const domainDisponibilidades = await prisma.domainDisponibilidade.findMany({ take: 10 })
     * 
     * // Only select the `order`
     * const domainDisponibilidadeWithOrderOnly = await prisma.domainDisponibilidade.findMany({ select: { order: true } })
     * 
     */
    findMany<T extends DomainDisponibilidadeFindManyArgs>(args?: SelectSubset<T, DomainDisponibilidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainDisponibilidade.
     * @param {DomainDisponibilidadeCreateArgs} args - Arguments to create a DomainDisponibilidade.
     * @example
     * // Create one DomainDisponibilidade
     * const DomainDisponibilidade = await prisma.domainDisponibilidade.create({
     *   data: {
     *     // ... data to create a DomainDisponibilidade
     *   }
     * })
     * 
     */
    create<T extends DomainDisponibilidadeCreateArgs>(args: SelectSubset<T, DomainDisponibilidadeCreateArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainDisponibilidades.
     * @param {DomainDisponibilidadeCreateManyArgs} args - Arguments to create many DomainDisponibilidades.
     * @example
     * // Create many DomainDisponibilidades
     * const domainDisponibilidade = await prisma.domainDisponibilidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainDisponibilidadeCreateManyArgs>(args?: SelectSubset<T, DomainDisponibilidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainDisponibilidades and returns the data saved in the database.
     * @param {DomainDisponibilidadeCreateManyAndReturnArgs} args - Arguments to create many DomainDisponibilidades.
     * @example
     * // Create many DomainDisponibilidades
     * const domainDisponibilidade = await prisma.domainDisponibilidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainDisponibilidades and only return the `order`
     * const domainDisponibilidadeWithOrderOnly = await prisma.domainDisponibilidade.createManyAndReturn({
     *   select: { order: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainDisponibilidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainDisponibilidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainDisponibilidade.
     * @param {DomainDisponibilidadeDeleteArgs} args - Arguments to delete one DomainDisponibilidade.
     * @example
     * // Delete one DomainDisponibilidade
     * const DomainDisponibilidade = await prisma.domainDisponibilidade.delete({
     *   where: {
     *     // ... filter to delete one DomainDisponibilidade
     *   }
     * })
     * 
     */
    delete<T extends DomainDisponibilidadeDeleteArgs>(args: SelectSubset<T, DomainDisponibilidadeDeleteArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainDisponibilidade.
     * @param {DomainDisponibilidadeUpdateArgs} args - Arguments to update one DomainDisponibilidade.
     * @example
     * // Update one DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainDisponibilidadeUpdateArgs>(args: SelectSubset<T, DomainDisponibilidadeUpdateArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainDisponibilidades.
     * @param {DomainDisponibilidadeDeleteManyArgs} args - Arguments to filter DomainDisponibilidades to delete.
     * @example
     * // Delete a few DomainDisponibilidades
     * const { count } = await prisma.domainDisponibilidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainDisponibilidadeDeleteManyArgs>(args?: SelectSubset<T, DomainDisponibilidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainDisponibilidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainDisponibilidades
     * const domainDisponibilidade = await prisma.domainDisponibilidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainDisponibilidadeUpdateManyArgs>(args: SelectSubset<T, DomainDisponibilidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainDisponibilidades and returns the data updated in the database.
     * @param {DomainDisponibilidadeUpdateManyAndReturnArgs} args - Arguments to update many DomainDisponibilidades.
     * @example
     * // Update many DomainDisponibilidades
     * const domainDisponibilidade = await prisma.domainDisponibilidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainDisponibilidades and only return the `order`
     * const domainDisponibilidadeWithOrderOnly = await prisma.domainDisponibilidade.updateManyAndReturn({
     *   select: { order: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainDisponibilidadeUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainDisponibilidadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainDisponibilidade.
     * @param {DomainDisponibilidadeUpsertArgs} args - Arguments to update or create a DomainDisponibilidade.
     * @example
     * // Update or create a DomainDisponibilidade
     * const domainDisponibilidade = await prisma.domainDisponibilidade.upsert({
     *   create: {
     *     // ... data to create a DomainDisponibilidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainDisponibilidade we want to update
     *   }
     * })
     */
    upsert<T extends DomainDisponibilidadeUpsertArgs>(args: SelectSubset<T, DomainDisponibilidadeUpsertArgs<ExtArgs>>): Prisma__DomainDisponibilidadeClient<$Result.GetResult<Prisma.$DomainDisponibilidadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainDisponibilidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeCountArgs} args - Arguments to filter DomainDisponibilidades to count.
     * @example
     * // Count the number of DomainDisponibilidades
     * const count = await prisma.domainDisponibilidade.count({
     *   where: {
     *     // ... the filter for the DomainDisponibilidades we want to count
     *   }
     * })
    **/
    count<T extends DomainDisponibilidadeCountArgs>(
      args?: Subset<T, DomainDisponibilidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainDisponibilidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainDisponibilidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainDisponibilidadeAggregateArgs>(args: Subset<T, DomainDisponibilidadeAggregateArgs>): Prisma.PrismaPromise<GetDomainDisponibilidadeAggregateType<T>>

    /**
     * Group by DomainDisponibilidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDisponibilidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainDisponibilidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainDisponibilidadeGroupByArgs['orderBy'] }
        : { orderBy?: DomainDisponibilidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainDisponibilidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainDisponibilidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainDisponibilidade model
   */
  readonly fields: DomainDisponibilidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainDisponibilidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainDisponibilidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encontreiro<T extends DomainDisponibilidade$encontreiroArgs<ExtArgs> = {}>(args?: Subset<T, DomainDisponibilidade$encontreiroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncontreiroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainDisponibilidade model
   */
  interface DomainDisponibilidadeFieldRefs {
    readonly id: FieldRef<"DomainDisponibilidade", 'Value_Disponibilidade'>
    readonly order: FieldRef<"DomainDisponibilidade", 'Int'>
    readonly disponibilidade: FieldRef<"DomainDisponibilidade", 'String'>
    readonly descricao: FieldRef<"DomainDisponibilidade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainDisponibilidade findUnique
   */
  export type DomainDisponibilidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter, which DomainDisponibilidade to fetch.
     */
    where: DomainDisponibilidadeWhereUniqueInput
  }

  /**
   * DomainDisponibilidade findUniqueOrThrow
   */
  export type DomainDisponibilidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter, which DomainDisponibilidade to fetch.
     */
    where: DomainDisponibilidadeWhereUniqueInput
  }

  /**
   * DomainDisponibilidade findFirst
   */
  export type DomainDisponibilidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter, which DomainDisponibilidade to fetch.
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDisponibilidades to fetch.
     */
    orderBy?: DomainDisponibilidadeOrderByWithRelationInput | DomainDisponibilidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainDisponibilidades.
     */
    cursor?: DomainDisponibilidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDisponibilidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDisponibilidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainDisponibilidades.
     */
    distinct?: DomainDisponibilidadeScalarFieldEnum | DomainDisponibilidadeScalarFieldEnum[]
  }

  /**
   * DomainDisponibilidade findFirstOrThrow
   */
  export type DomainDisponibilidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter, which DomainDisponibilidade to fetch.
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDisponibilidades to fetch.
     */
    orderBy?: DomainDisponibilidadeOrderByWithRelationInput | DomainDisponibilidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainDisponibilidades.
     */
    cursor?: DomainDisponibilidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDisponibilidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDisponibilidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainDisponibilidades.
     */
    distinct?: DomainDisponibilidadeScalarFieldEnum | DomainDisponibilidadeScalarFieldEnum[]
  }

  /**
   * DomainDisponibilidade findMany
   */
  export type DomainDisponibilidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter, which DomainDisponibilidades to fetch.
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDisponibilidades to fetch.
     */
    orderBy?: DomainDisponibilidadeOrderByWithRelationInput | DomainDisponibilidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainDisponibilidades.
     */
    cursor?: DomainDisponibilidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDisponibilidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDisponibilidades.
     */
    skip?: number
    distinct?: DomainDisponibilidadeScalarFieldEnum | DomainDisponibilidadeScalarFieldEnum[]
  }

  /**
   * DomainDisponibilidade create
   */
  export type DomainDisponibilidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainDisponibilidade.
     */
    data: XOR<DomainDisponibilidadeCreateInput, DomainDisponibilidadeUncheckedCreateInput>
  }

  /**
   * DomainDisponibilidade createMany
   */
  export type DomainDisponibilidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainDisponibilidades.
     */
    data: DomainDisponibilidadeCreateManyInput | DomainDisponibilidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainDisponibilidade createManyAndReturn
   */
  export type DomainDisponibilidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * The data used to create many DomainDisponibilidades.
     */
    data: DomainDisponibilidadeCreateManyInput | DomainDisponibilidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainDisponibilidade update
   */
  export type DomainDisponibilidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainDisponibilidade.
     */
    data: XOR<DomainDisponibilidadeUpdateInput, DomainDisponibilidadeUncheckedUpdateInput>
    /**
     * Choose, which DomainDisponibilidade to update.
     */
    where: DomainDisponibilidadeWhereUniqueInput
  }

  /**
   * DomainDisponibilidade updateMany
   */
  export type DomainDisponibilidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainDisponibilidades.
     */
    data: XOR<DomainDisponibilidadeUpdateManyMutationInput, DomainDisponibilidadeUncheckedUpdateManyInput>
    /**
     * Filter which DomainDisponibilidades to update
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * Limit how many DomainDisponibilidades to update.
     */
    limit?: number
  }

  /**
   * DomainDisponibilidade updateManyAndReturn
   */
  export type DomainDisponibilidadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * The data used to update DomainDisponibilidades.
     */
    data: XOR<DomainDisponibilidadeUpdateManyMutationInput, DomainDisponibilidadeUncheckedUpdateManyInput>
    /**
     * Filter which DomainDisponibilidades to update
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * Limit how many DomainDisponibilidades to update.
     */
    limit?: number
  }

  /**
   * DomainDisponibilidade upsert
   */
  export type DomainDisponibilidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainDisponibilidade to update in case it exists.
     */
    where: DomainDisponibilidadeWhereUniqueInput
    /**
     * In case the DomainDisponibilidade found by the `where` argument doesn't exist, create a new DomainDisponibilidade with this data.
     */
    create: XOR<DomainDisponibilidadeCreateInput, DomainDisponibilidadeUncheckedCreateInput>
    /**
     * In case the DomainDisponibilidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainDisponibilidadeUpdateInput, DomainDisponibilidadeUncheckedUpdateInput>
  }

  /**
   * DomainDisponibilidade delete
   */
  export type DomainDisponibilidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
    /**
     * Filter which DomainDisponibilidade to delete.
     */
    where: DomainDisponibilidadeWhereUniqueInput
  }

  /**
   * DomainDisponibilidade deleteMany
   */
  export type DomainDisponibilidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainDisponibilidades to delete
     */
    where?: DomainDisponibilidadeWhereInput
    /**
     * Limit how many DomainDisponibilidades to delete.
     */
    limit?: number
  }

  /**
   * DomainDisponibilidade.encontreiro
   */
  export type DomainDisponibilidade$encontreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encontreiro
     */
    select?: EncontreiroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encontreiro
     */
    omit?: EncontreiroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncontreiroInclude<ExtArgs> | null
    where?: EncontreiroWhereInput
    orderBy?: EncontreiroOrderByWithRelationInput | EncontreiroOrderByWithRelationInput[]
    cursor?: EncontreiroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncontreiroScalarFieldEnum | EncontreiroScalarFieldEnum[]
  }

  /**
   * DomainDisponibilidade without action
   */
  export type DomainDisponibilidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDisponibilidade
     */
    select?: DomainDisponibilidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainDisponibilidade
     */
    omit?: DomainDisponibilidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainDisponibilidadeInclude<ExtArgs> | null
  }


  /**
   * Model DomainEquipes
   */

  export type AggregateDomainEquipes = {
    _count: DomainEquipesCountAggregateOutputType | null
    _min: DomainEquipesMinAggregateOutputType | null
    _max: DomainEquipesMaxAggregateOutputType | null
  }

  export type DomainEquipesMinAggregateOutputType = {
    equipeLabel: string | null
    equipeValue: string | null
    pastaUrl: string | null
  }

  export type DomainEquipesMaxAggregateOutputType = {
    equipeLabel: string | null
    equipeValue: string | null
    pastaUrl: string | null
  }

  export type DomainEquipesCountAggregateOutputType = {
    equipeLabel: number
    equipeValue: number
    pastaUrl: number
    _all: number
  }


  export type DomainEquipesMinAggregateInputType = {
    equipeLabel?: true
    equipeValue?: true
    pastaUrl?: true
  }

  export type DomainEquipesMaxAggregateInputType = {
    equipeLabel?: true
    equipeValue?: true
    pastaUrl?: true
  }

  export type DomainEquipesCountAggregateInputType = {
    equipeLabel?: true
    equipeValue?: true
    pastaUrl?: true
    _all?: true
  }

  export type DomainEquipesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainEquipes to aggregate.
     */
    where?: DomainEquipesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainEquipes to fetch.
     */
    orderBy?: DomainEquipesOrderByWithRelationInput | DomainEquipesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainEquipesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainEquipes
    **/
    _count?: true | DomainEquipesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainEquipesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainEquipesMaxAggregateInputType
  }

  export type GetDomainEquipesAggregateType<T extends DomainEquipesAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainEquipes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainEquipes[P]>
      : GetScalarType<T[P], AggregateDomainEquipes[P]>
  }




  export type DomainEquipesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainEquipesWhereInput
    orderBy?: DomainEquipesOrderByWithAggregationInput | DomainEquipesOrderByWithAggregationInput[]
    by: DomainEquipesScalarFieldEnum[] | DomainEquipesScalarFieldEnum
    having?: DomainEquipesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainEquipesCountAggregateInputType | true
    _min?: DomainEquipesMinAggregateInputType
    _max?: DomainEquipesMaxAggregateInputType
  }

  export type DomainEquipesGroupByOutputType = {
    equipeLabel: string
    equipeValue: string
    pastaUrl: string | null
    _count: DomainEquipesCountAggregateOutputType | null
    _min: DomainEquipesMinAggregateOutputType | null
    _max: DomainEquipesMaxAggregateOutputType | null
  }

  type GetDomainEquipesGroupByPayload<T extends DomainEquipesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainEquipesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainEquipesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainEquipesGroupByOutputType[P]>
            : GetScalarType<T[P], DomainEquipesGroupByOutputType[P]>
        }
      >
    >


  export type DomainEquipesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeLabel?: boolean
    equipeValue?: boolean
    pastaUrl?: boolean
    EquipeEncontro?: boolean | DomainEquipes$EquipeEncontroArgs<ExtArgs>
    EquipeMontagem?: boolean | DomainEquipes$EquipeMontagemArgs<ExtArgs>
    ListaPreferencia?: boolean | DomainEquipes$ListaPreferenciaArgs<ExtArgs>
    _count?: boolean | DomainEquipesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainEquipes"]>

  export type DomainEquipesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeLabel?: boolean
    equipeValue?: boolean
    pastaUrl?: boolean
  }, ExtArgs["result"]["domainEquipes"]>

  export type DomainEquipesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeLabel?: boolean
    equipeValue?: boolean
    pastaUrl?: boolean
  }, ExtArgs["result"]["domainEquipes"]>

  export type DomainEquipesSelectScalar = {
    equipeLabel?: boolean
    equipeValue?: boolean
    pastaUrl?: boolean
  }

  export type DomainEquipesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipeLabel" | "equipeValue" | "pastaUrl", ExtArgs["result"]["domainEquipes"]>
  export type DomainEquipesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EquipeEncontro?: boolean | DomainEquipes$EquipeEncontroArgs<ExtArgs>
    EquipeMontagem?: boolean | DomainEquipes$EquipeMontagemArgs<ExtArgs>
    ListaPreferencia?: boolean | DomainEquipes$ListaPreferenciaArgs<ExtArgs>
    _count?: boolean | DomainEquipesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainEquipesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DomainEquipesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DomainEquipesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainEquipes"
    objects: {
      EquipeEncontro: Prisma.$EquipeEncontroPayload<ExtArgs>[]
      EquipeMontagem: Prisma.$EquipeMontagemPayload<ExtArgs>[]
      ListaPreferencia: Prisma.$ListaPreferenciaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      equipeLabel: string
      equipeValue: string
      pastaUrl: string | null
    }, ExtArgs["result"]["domainEquipes"]>
    composites: {}
  }

  type DomainEquipesGetPayload<S extends boolean | null | undefined | DomainEquipesDefaultArgs> = $Result.GetResult<Prisma.$DomainEquipesPayload, S>

  type DomainEquipesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainEquipesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainEquipesCountAggregateInputType | true
    }

  export interface DomainEquipesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainEquipes'], meta: { name: 'DomainEquipes' } }
    /**
     * Find zero or one DomainEquipes that matches the filter.
     * @param {DomainEquipesFindUniqueArgs} args - Arguments to find a DomainEquipes
     * @example
     * // Get one DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainEquipesFindUniqueArgs>(args: SelectSubset<T, DomainEquipesFindUniqueArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainEquipes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainEquipesFindUniqueOrThrowArgs} args - Arguments to find a DomainEquipes
     * @example
     * // Get one DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainEquipesFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainEquipesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainEquipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesFindFirstArgs} args - Arguments to find a DomainEquipes
     * @example
     * // Get one DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainEquipesFindFirstArgs>(args?: SelectSubset<T, DomainEquipesFindFirstArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainEquipes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesFindFirstOrThrowArgs} args - Arguments to find a DomainEquipes
     * @example
     * // Get one DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainEquipesFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainEquipesFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainEquipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findMany()
     * 
     * // Get first 10 DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.findMany({ take: 10 })
     * 
     * // Only select the `equipeLabel`
     * const domainEquipesWithEquipeLabelOnly = await prisma.domainEquipes.findMany({ select: { equipeLabel: true } })
     * 
     */
    findMany<T extends DomainEquipesFindManyArgs>(args?: SelectSubset<T, DomainEquipesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainEquipes.
     * @param {DomainEquipesCreateArgs} args - Arguments to create a DomainEquipes.
     * @example
     * // Create one DomainEquipes
     * const DomainEquipes = await prisma.domainEquipes.create({
     *   data: {
     *     // ... data to create a DomainEquipes
     *   }
     * })
     * 
     */
    create<T extends DomainEquipesCreateArgs>(args: SelectSubset<T, DomainEquipesCreateArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainEquipes.
     * @param {DomainEquipesCreateManyArgs} args - Arguments to create many DomainEquipes.
     * @example
     * // Create many DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainEquipesCreateManyArgs>(args?: SelectSubset<T, DomainEquipesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainEquipes and returns the data saved in the database.
     * @param {DomainEquipesCreateManyAndReturnArgs} args - Arguments to create many DomainEquipes.
     * @example
     * // Create many DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainEquipes and only return the `equipeLabel`
     * const domainEquipesWithEquipeLabelOnly = await prisma.domainEquipes.createManyAndReturn({
     *   select: { equipeLabel: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainEquipesCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainEquipesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainEquipes.
     * @param {DomainEquipesDeleteArgs} args - Arguments to delete one DomainEquipes.
     * @example
     * // Delete one DomainEquipes
     * const DomainEquipes = await prisma.domainEquipes.delete({
     *   where: {
     *     // ... filter to delete one DomainEquipes
     *   }
     * })
     * 
     */
    delete<T extends DomainEquipesDeleteArgs>(args: SelectSubset<T, DomainEquipesDeleteArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainEquipes.
     * @param {DomainEquipesUpdateArgs} args - Arguments to update one DomainEquipes.
     * @example
     * // Update one DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainEquipesUpdateArgs>(args: SelectSubset<T, DomainEquipesUpdateArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainEquipes.
     * @param {DomainEquipesDeleteManyArgs} args - Arguments to filter DomainEquipes to delete.
     * @example
     * // Delete a few DomainEquipes
     * const { count } = await prisma.domainEquipes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainEquipesDeleteManyArgs>(args?: SelectSubset<T, DomainEquipesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainEquipesUpdateManyArgs>(args: SelectSubset<T, DomainEquipesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainEquipes and returns the data updated in the database.
     * @param {DomainEquipesUpdateManyAndReturnArgs} args - Arguments to update many DomainEquipes.
     * @example
     * // Update many DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainEquipes and only return the `equipeLabel`
     * const domainEquipesWithEquipeLabelOnly = await prisma.domainEquipes.updateManyAndReturn({
     *   select: { equipeLabel: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainEquipesUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainEquipesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainEquipes.
     * @param {DomainEquipesUpsertArgs} args - Arguments to update or create a DomainEquipes.
     * @example
     * // Update or create a DomainEquipes
     * const domainEquipes = await prisma.domainEquipes.upsert({
     *   create: {
     *     // ... data to create a DomainEquipes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainEquipes we want to update
     *   }
     * })
     */
    upsert<T extends DomainEquipesUpsertArgs>(args: SelectSubset<T, DomainEquipesUpsertArgs<ExtArgs>>): Prisma__DomainEquipesClient<$Result.GetResult<Prisma.$DomainEquipesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesCountArgs} args - Arguments to filter DomainEquipes to count.
     * @example
     * // Count the number of DomainEquipes
     * const count = await prisma.domainEquipes.count({
     *   where: {
     *     // ... the filter for the DomainEquipes we want to count
     *   }
     * })
    **/
    count<T extends DomainEquipesCountArgs>(
      args?: Subset<T, DomainEquipesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainEquipesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainEquipesAggregateArgs>(args: Subset<T, DomainEquipesAggregateArgs>): Prisma.PrismaPromise<GetDomainEquipesAggregateType<T>>

    /**
     * Group by DomainEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainEquipesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainEquipesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainEquipesGroupByArgs['orderBy'] }
        : { orderBy?: DomainEquipesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainEquipesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainEquipesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainEquipes model
   */
  readonly fields: DomainEquipesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainEquipes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainEquipesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EquipeEncontro<T extends DomainEquipes$EquipeEncontroArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipes$EquipeEncontroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeEncontroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EquipeMontagem<T extends DomainEquipes$EquipeMontagemArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipes$EquipeMontagemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipeMontagemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ListaPreferencia<T extends DomainEquipes$ListaPreferenciaArgs<ExtArgs> = {}>(args?: Subset<T, DomainEquipes$ListaPreferenciaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListaPreferenciaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainEquipes model
   */
  interface DomainEquipesFieldRefs {
    readonly equipeLabel: FieldRef<"DomainEquipes", 'String'>
    readonly equipeValue: FieldRef<"DomainEquipes", 'String'>
    readonly pastaUrl: FieldRef<"DomainEquipes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainEquipes findUnique
   */
  export type DomainEquipesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter, which DomainEquipes to fetch.
     */
    where: DomainEquipesWhereUniqueInput
  }

  /**
   * DomainEquipes findUniqueOrThrow
   */
  export type DomainEquipesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter, which DomainEquipes to fetch.
     */
    where: DomainEquipesWhereUniqueInput
  }

  /**
   * DomainEquipes findFirst
   */
  export type DomainEquipesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter, which DomainEquipes to fetch.
     */
    where?: DomainEquipesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainEquipes to fetch.
     */
    orderBy?: DomainEquipesOrderByWithRelationInput | DomainEquipesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainEquipes.
     */
    cursor?: DomainEquipesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainEquipes.
     */
    distinct?: DomainEquipesScalarFieldEnum | DomainEquipesScalarFieldEnum[]
  }

  /**
   * DomainEquipes findFirstOrThrow
   */
  export type DomainEquipesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter, which DomainEquipes to fetch.
     */
    where?: DomainEquipesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainEquipes to fetch.
     */
    orderBy?: DomainEquipesOrderByWithRelationInput | DomainEquipesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainEquipes.
     */
    cursor?: DomainEquipesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainEquipes.
     */
    distinct?: DomainEquipesScalarFieldEnum | DomainEquipesScalarFieldEnum[]
  }

  /**
   * DomainEquipes findMany
   */
  export type DomainEquipesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter, which DomainEquipes to fetch.
     */
    where?: DomainEquipesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainEquipes to fetch.
     */
    orderBy?: DomainEquipesOrderByWithRelationInput | DomainEquipesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainEquipes.
     */
    cursor?: DomainEquipesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainEquipes.
     */
    skip?: number
    distinct?: DomainEquipesScalarFieldEnum | DomainEquipesScalarFieldEnum[]
  }

  /**
   * DomainEquipes create
   */
  export type DomainEquipesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainEquipes.
     */
    data: XOR<DomainEquipesCreateInput, DomainEquipesUncheckedCreateInput>
  }

  /**
   * DomainEquipes createMany
   */
  export type DomainEquipesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainEquipes.
     */
    data: DomainEquipesCreateManyInput | DomainEquipesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainEquipes createManyAndReturn
   */
  export type DomainEquipesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * The data used to create many DomainEquipes.
     */
    data: DomainEquipesCreateManyInput | DomainEquipesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainEquipes update
   */
  export type DomainEquipesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainEquipes.
     */
    data: XOR<DomainEquipesUpdateInput, DomainEquipesUncheckedUpdateInput>
    /**
     * Choose, which DomainEquipes to update.
     */
    where: DomainEquipesWhereUniqueInput
  }

  /**
   * DomainEquipes updateMany
   */
  export type DomainEquipesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainEquipes.
     */
    data: XOR<DomainEquipesUpdateManyMutationInput, DomainEquipesUncheckedUpdateManyInput>
    /**
     * Filter which DomainEquipes to update
     */
    where?: DomainEquipesWhereInput
    /**
     * Limit how many DomainEquipes to update.
     */
    limit?: number
  }

  /**
   * DomainEquipes updateManyAndReturn
   */
  export type DomainEquipesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * The data used to update DomainEquipes.
     */
    data: XOR<DomainEquipesUpdateManyMutationInput, DomainEquipesUncheckedUpdateManyInput>
    /**
     * Filter which DomainEquipes to update
     */
    where?: DomainEquipesWhereInput
    /**
     * Limit how many DomainEquipes to update.
     */
    limit?: number
  }

  /**
   * DomainEquipes upsert
   */
  export type DomainEquipesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainEquipes to update in case it exists.
     */
    where: DomainEquipesWhereUniqueInput
    /**
     * In case the DomainEquipes found by the `where` argument doesn't exist, create a new DomainEquipes with this data.
     */
    create: XOR<DomainEquipesCreateInput, DomainEquipesUncheckedCreateInput>
    /**
     * In case the DomainEquipes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainEquipesUpdateInput, DomainEquipesUncheckedUpdateInput>
  }

  /**
   * DomainEquipes delete
   */
  export type DomainEquipesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
    /**
     * Filter which DomainEquipes to delete.
     */
    where: DomainEquipesWhereUniqueInput
  }

  /**
   * DomainEquipes deleteMany
   */
  export type DomainEquipesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainEquipes to delete
     */
    where?: DomainEquipesWhereInput
    /**
     * Limit how many DomainEquipes to delete.
     */
    limit?: number
  }

  /**
   * DomainEquipes.EquipeEncontro
   */
  export type DomainEquipes$EquipeEncontroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeEncontro
     */
    select?: EquipeEncontroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeEncontro
     */
    omit?: EquipeEncontroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeEncontroInclude<ExtArgs> | null
    where?: EquipeEncontroWhereInput
    orderBy?: EquipeEncontroOrderByWithRelationInput | EquipeEncontroOrderByWithRelationInput[]
    cursor?: EquipeEncontroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeEncontroScalarFieldEnum | EquipeEncontroScalarFieldEnum[]
  }

  /**
   * DomainEquipes.EquipeMontagem
   */
  export type DomainEquipes$EquipeMontagemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeMontagem
     */
    select?: EquipeMontagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipeMontagem
     */
    omit?: EquipeMontagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipeMontagemInclude<ExtArgs> | null
    where?: EquipeMontagemWhereInput
    orderBy?: EquipeMontagemOrderByWithRelationInput | EquipeMontagemOrderByWithRelationInput[]
    cursor?: EquipeMontagemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeMontagemScalarFieldEnum | EquipeMontagemScalarFieldEnum[]
  }

  /**
   * DomainEquipes.ListaPreferencia
   */
  export type DomainEquipes$ListaPreferenciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListaPreferencia
     */
    select?: ListaPreferenciaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ListaPreferencia
     */
    omit?: ListaPreferenciaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListaPreferenciaInclude<ExtArgs> | null
    where?: ListaPreferenciaWhereInput
    orderBy?: ListaPreferenciaOrderByWithRelationInput | ListaPreferenciaOrderByWithRelationInput[]
    cursor?: ListaPreferenciaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListaPreferenciaScalarFieldEnum | ListaPreferenciaScalarFieldEnum[]
  }

  /**
   * DomainEquipes without action
   */
  export type DomainEquipesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainEquipes
     */
    select?: DomainEquipesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainEquipes
     */
    omit?: DomainEquipesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainEquipesInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountSumAggregateOutputType = {
    expiresAt: number | null
  }

  export type AccountMinAggregateOutputType = {
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    type: number
    provider: number
    providerAccountId: number
    refreshToken: number
    accessToken: number
    expiresAt: number
    tokenType: number
    scope: number
    idToken: number
    sessionState: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expiresAt?: true
  }

  export type AccountSumAggregateInputType = {
    expiresAt?: true
  }

  export type AccountMinAggregateInputType = {
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    type?: true
    provider?: true
    providerAccountId?: true
    refreshToken?: true
    accessToken?: true
    expiresAt?: true
    tokenType?: true
    scope?: true
    idToken?: true
    sessionState?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken: string | null
    accessToken: string | null
    expiresAt: number | null
    tokenType: string | null
    scope: string | null
    idToken: string | null
    sessionState: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refreshToken?: boolean
    accessToken?: boolean
    expiresAt?: boolean
    tokenType?: boolean
    scope?: boolean
    idToken?: boolean
    sessionState?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"type" | "provider" | "providerAccountId" | "refreshToken" | "accessToken" | "expiresAt" | "tokenType" | "scope" | "idToken" | "sessionState" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      type: string
      provider: string
      providerAccountId: string
      refreshToken: string | null
      accessToken: string | null
      expiresAt: number | null
      tokenType: string | null
      scope: string | null
      idToken: string | null
      sessionState: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `type`
     * const accountWithTypeOnly = await prisma.account.findMany({ select: { type: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `type`
     * const accountWithTypeOnly = await prisma.account.createManyAndReturn({
     *   select: { type: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `type`
     * const accountWithTypeOnly = await prisma.account.updateManyAndReturn({
     *   select: { type: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly expiresAt: FieldRef<"Account", 'Int'>
    readonly tokenType: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly sessionState: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sessionToken: string | null
    expires: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    sessionToken: string | null
    expires: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    sessionToken: number
    expires: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sessionToken?: true
    expires?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    sessionToken?: true
    expires?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    sessionToken?: true
    expires?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sessionToken: string
    expires: Date
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    expires?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    expires?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionToken?: boolean
    expires?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    sessionToken?: boolean
    expires?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionToken" | "expires" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PessoaDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$PessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionToken: string
      expires: Date
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.findMany({ select: { sessionToken: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionToken: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `sessionToken`
     * const sessionWithSessionTokenOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionToken: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PessoaDefaultArgs<ExtArgs>>): Prisma__PessoaClient<$Result.GetResult<Prisma.$PessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sobrenome: 'sobrenome',
    celular: 'celular',
    telefone: 'telefone',
    email: 'email',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt',
    enderecoCep: 'enderecoCep',
    enderecoNumero: 'enderecoNumero',
    avatarUrl: 'avatarUrl',
    password: 'password',
    changePassword: 'changePassword',
    apelido: 'apelido',
    role: 'role',
    slug: 'slug'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const EncontristaScalarFieldEnum: {
    idPessoa: 'idPessoa',
    endComplemento: 'endComplemento',
    movimentoAnterior: 'movimentoAnterior',
    observacao: 'observacao',
    nomeContato1: 'nomeContato1',
    telContato1: 'telContato1',
    parentescoContato1: 'parentescoContato1',
    nomeContato2: 'nomeContato2',
    telContato2: 'telContato2',
    parentescoContato2: 'parentescoContato2',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt',
    indicadoPorApelido: 'indicadoPorApelido',
    indicadoPorEmail: 'indicadoPorEmail',
    indicadoPorNome: 'indicadoPorNome',
    indicadoPorTel: 'indicadoPorTel',
    isAutofill: 'isAutofill',
    idStatus: 'idStatus',
    idReligiao: 'idReligiao',
    idMoracom: 'idMoracom',
    idStatusPais: 'idStatusPais',
    endNumero: 'endNumero',
    cartasFisicas: 'cartasFisicas',
    idCarroEncontro: 'idCarroEncontro',
    cepEncontro: 'cepEncontro',
    endComplementoEncontro: 'endComplementoEncontro',
    endNumEncontro: 'endNumEncontro',
    obsExternaConhecidos: 'obsExternaConhecidos',
    obsExternaLocalizacao: 'obsExternaLocalizacao',
    obsExternaOutros: 'obsExternaOutros',
    obsExternaSaude: 'obsExternaSaude',
    cartasOk: 'cartasOk',
    generosaOk: 'generosaOk',
    familiaOk: 'familiaOk'
  };

  export type EncontristaScalarFieldEnum = (typeof EncontristaScalarFieldEnum)[keyof typeof EncontristaScalarFieldEnum]


  export const EncontreiroScalarFieldEnum: {
    idPessoa: 'idPessoa',
    dataNasc: 'dataNasc',
    instagram: 'instagram',
    restricaoAlimentar: 'restricaoAlimentar',
    idEncontro: 'idEncontro',
    idCirculo: 'idCirculo',
    idTamanhoCamisa: 'idTamanhoCamisa',
    idDisponibilidade: 'idDisponibilidade',
    obsBanda: 'obsBanda',
    observacoes: 'observacoes',
    statusMontagem: 'statusMontagem'
  };

  export type EncontreiroScalarFieldEnum = (typeof EncontreiroScalarFieldEnum)[keyof typeof EncontreiroScalarFieldEnum]


  export const EncontroScalarFieldEnum: {
    id: 'id',
    numeroEncontro: 'numeroEncontro',
    idLocal: 'idLocal',
    temaEspiritual: 'temaEspiritual',
    temaFantasia: 'temaFantasia',
    numeroCirculos: 'numeroCirculos',
    dataInicio: 'dataInicio',
    dataTema: 'dataTema',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt',
    ordemCirculos: 'ordemCirculos',
    isReceivingCartas: 'isReceivingCartas'
  };

  export type EncontroScalarFieldEnum = (typeof EncontroScalarFieldEnum)[keyof typeof EncontroScalarFieldEnum]


  export const CirculoScalarFieldEnum: {
    id: 'id',
    idCorCirculo: 'idCorCirculo',
    idTioAparente: 'idTioAparente',
    idTioSecreto: 'idTioSecreto',
    idEncontro: 'idEncontro',
    nome: 'nome'
  };

  export type CirculoScalarFieldEnum = (typeof CirculoScalarFieldEnum)[keyof typeof CirculoScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    cep: 'cep',
    estado: 'estado',
    cidade: 'cidade',
    bairro: 'bairro',
    rua: 'rua',
    createdAt: 'createdAt',
    modifiedAt: 'modifiedAt'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const LocalScalarFieldEnum: {
    id: 'id',
    enderecoCep: 'enderecoCep',
    nomeLocal: 'nomeLocal',
    numeroLocal: 'numeroLocal'
  };

  export type LocalScalarFieldEnum = (typeof LocalScalarFieldEnum)[keyof typeof LocalScalarFieldEnum]


  export const CarroScalarFieldEnum: {
    id: 'id',
    idMotorista: 'idMotorista',
    modeloCarro: 'modeloCarro',
    placaCarro: 'placaCarro',
    lugaresCarro: 'lugaresCarro',
    observacaoMotorista: 'observacaoMotorista',
    idCarona: 'idCarona'
  };

  export type CarroScalarFieldEnum = (typeof CarroScalarFieldEnum)[keyof typeof CarroScalarFieldEnum]


  export const CarroEncontroScalarFieldEnum: {
    idCarro: 'idCarro',
    idEncontro: 'idEncontro',
    numeroCarro: 'numeroCarro',
    idExterna: 'idExterna',
    id: 'id',
    observacao: 'observacao'
  };

  export type CarroEncontroScalarFieldEnum = (typeof CarroEncontroScalarFieldEnum)[keyof typeof CarroEncontroScalarFieldEnum]


  export const ResponsavelExternaScalarFieldEnum: {
    idExterna: 'idExterna',
    idEncontrista: 'idEncontrista',
    idEncontro: 'idEncontro'
  };

  export type ResponsavelExternaScalarFieldEnum = (typeof ResponsavelExternaScalarFieldEnum)[keyof typeof ResponsavelExternaScalarFieldEnum]


  export const CartaScalarFieldEnum: {
    id: 'id',
    para: 'para',
    de: 'de',
    conteudo: 'conteudo',
    createdAt: 'createdAt',
    slugEncontrista: 'slugEncontrista',
    isPrinted: 'isPrinted'
  };

  export type CartaScalarFieldEnum = (typeof CartaScalarFieldEnum)[keyof typeof CartaScalarFieldEnum]


  export const ListaPreferenciaScalarFieldEnum: {
    idPessoa: 'idPessoa',
    posicao: 'posicao',
    valueEquipe: 'valueEquipe'
  };

  export type ListaPreferenciaScalarFieldEnum = (typeof ListaPreferenciaScalarFieldEnum)[keyof typeof ListaPreferenciaScalarFieldEnum]


  export const EquipeEncontroScalarFieldEnum: {
    idPessoa: 'idPessoa',
    idEncontro: 'idEncontro',
    idEquipe: 'idEquipe',
    coordenou: 'coordenou',
    fichaPreenchida: 'fichaPreenchida'
  };

  export type EquipeEncontroScalarFieldEnum = (typeof EquipeEncontroScalarFieldEnum)[keyof typeof EquipeEncontroScalarFieldEnum]


  export const EquipeMontagemScalarFieldEnum: {
    valueEquipe: 'valueEquipe',
    coordenando: 'coordenando',
    idEncontreiro: 'idEncontreiro'
  };

  export type EquipeMontagemScalarFieldEnum = (typeof EquipeMontagemScalarFieldEnum)[keyof typeof EquipeMontagemScalarFieldEnum]


  export const DomainStatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type DomainStatusScalarFieldEnum = (typeof DomainStatusScalarFieldEnum)[keyof typeof DomainStatusScalarFieldEnum]


  export const DomainReligiaoScalarFieldEnum: {
    id: 'id',
    religiao: 'religiao'
  };

  export type DomainReligiaoScalarFieldEnum = (typeof DomainReligiaoScalarFieldEnum)[keyof typeof DomainReligiaoScalarFieldEnum]


  export const DomainBairroEncontroScalarFieldEnum: {
    id: 'id',
    value: 'value',
    bairro: 'bairro',
    zona: 'zona'
  };

  export type DomainBairroEncontroScalarFieldEnum = (typeof DomainBairroEncontroScalarFieldEnum)[keyof typeof DomainBairroEncontroScalarFieldEnum]


  export const DomainMoraComScalarFieldEnum: {
    id: 'id',
    moraCom: 'moraCom'
  };

  export type DomainMoraComScalarFieldEnum = (typeof DomainMoraComScalarFieldEnum)[keyof typeof DomainMoraComScalarFieldEnum]


  export const DomainStatusPaisScalarFieldEnum: {
    id: 'id',
    statusPais: 'statusPais'
  };

  export type DomainStatusPaisScalarFieldEnum = (typeof DomainStatusPaisScalarFieldEnum)[keyof typeof DomainStatusPaisScalarFieldEnum]


  export const DomainTamanhoCamisaScalarFieldEnum: {
    id: 'id',
    tamanhoCamisa: 'tamanhoCamisa'
  };

  export type DomainTamanhoCamisaScalarFieldEnum = (typeof DomainTamanhoCamisaScalarFieldEnum)[keyof typeof DomainTamanhoCamisaScalarFieldEnum]


  export const DomainCorCirculoScalarFieldEnum: {
    id: 'id',
    cor: 'cor'
  };

  export type DomainCorCirculoScalarFieldEnum = (typeof DomainCorCirculoScalarFieldEnum)[keyof typeof DomainCorCirculoScalarFieldEnum]


  export const DomainDisponibilidadeScalarFieldEnum: {
    id: 'id',
    order: 'order',
    disponibilidade: 'disponibilidade',
    descricao: 'descricao'
  };

  export type DomainDisponibilidadeScalarFieldEnum = (typeof DomainDisponibilidadeScalarFieldEnum)[keyof typeof DomainDisponibilidadeScalarFieldEnum]


  export const DomainEquipesScalarFieldEnum: {
    equipeLabel: 'equipeLabel',
    equipeValue: 'equipeValue',
    pastaUrl: 'pastaUrl'
  };

  export type DomainEquipesScalarFieldEnum = (typeof DomainEquipesScalarFieldEnum)[keyof typeof DomainEquipesScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refreshToken: 'refreshToken',
    accessToken: 'accessToken',
    expiresAt: 'expiresAt',
    tokenType: 'tokenType',
    scope: 'scope',
    idToken: 'idToken',
    sessionState: 'sessionState',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sessionToken: 'sessionToken',
    expires: 'expires',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Value_Status'
   */
  export type EnumValue_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Status'>
    


  /**
   * Reference to a field of type 'Value_Status[]'
   */
  export type ListEnumValue_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Status[]'>
    


  /**
   * Reference to a field of type 'Value_Religiao'
   */
  export type EnumValue_ReligiaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Religiao'>
    


  /**
   * Reference to a field of type 'Value_Religiao[]'
   */
  export type ListEnumValue_ReligiaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Religiao[]'>
    


  /**
   * Reference to a field of type 'Value_MoraCom'
   */
  export type EnumValue_MoraComFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_MoraCom'>
    


  /**
   * Reference to a field of type 'Value_MoraCom[]'
   */
  export type ListEnumValue_MoraComFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_MoraCom[]'>
    


  /**
   * Reference to a field of type 'Value_StatusPais'
   */
  export type EnumValue_StatusPaisFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_StatusPais'>
    


  /**
   * Reference to a field of type 'Value_StatusPais[]'
   */
  export type ListEnumValue_StatusPaisFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_StatusPais[]'>
    


  /**
   * Reference to a field of type 'Value_TamanhoCamisa'
   */
  export type EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_TamanhoCamisa'>
    


  /**
   * Reference to a field of type 'Value_TamanhoCamisa[]'
   */
  export type ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_TamanhoCamisa[]'>
    


  /**
   * Reference to a field of type 'Value_Disponibilidade'
   */
  export type EnumValue_DisponibilidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Disponibilidade'>
    


  /**
   * Reference to a field of type 'Value_Disponibilidade[]'
   */
  export type ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Value_Disponibilidade[]'>
    


  /**
   * Reference to a field of type 'StatusEncontreiro'
   */
  export type EnumStatusEncontreiroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEncontreiro'>
    


  /**
   * Reference to a field of type 'StatusEncontreiro[]'
   */
  export type ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusEncontreiro[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PessoaWhereInput = {
    AND?: PessoaWhereInput | PessoaWhereInput[]
    OR?: PessoaWhereInput[]
    NOT?: PessoaWhereInput | PessoaWhereInput[]
    id?: StringFilter<"Pessoa"> | string
    nome?: StringFilter<"Pessoa"> | string
    sobrenome?: StringFilter<"Pessoa"> | string
    celular?: StringFilter<"Pessoa"> | string
    telefone?: StringNullableFilter<"Pessoa"> | string | null
    email?: StringFilter<"Pessoa"> | string
    createdAt?: DateTimeFilter<"Pessoa"> | Date | string
    modifiedAt?: DateTimeFilter<"Pessoa"> | Date | string
    enderecoCep?: StringFilter<"Pessoa"> | string
    enderecoNumero?: IntNullableFilter<"Pessoa"> | number | null
    avatarUrl?: StringNullableFilter<"Pessoa"> | string | null
    password?: StringNullableFilter<"Pessoa"> | string | null
    changePassword?: BoolFilter<"Pessoa"> | boolean
    apelido?: StringNullableFilter<"Pessoa"> | string | null
    role?: EnumRoleFilter<"Pessoa"> | $Enums.Role
    slug?: StringFilter<"Pessoa"> | string
    accounts?: AccountListRelationFilter
    pessoaCarona?: CarroListRelationFilter
    pessoaMotorista?: CarroListRelationFilter
    cartasDigitais?: CartaListRelationFilter
    tioAparenteCirculo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    tioSecretoCirculo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    encontreiro?: XOR<EncontreiroNullableScalarRelationFilter, EncontreiroWhereInput> | null
    encontrista?: XOR<EncontristaNullableScalarRelationFilter, EncontristaWhereInput> | null
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    sessions?: SessionListRelationFilter
  }

  export type PessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    celular?: SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    enderecoCep?: SortOrder
    enderecoNumero?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    changePassword?: SortOrder
    apelido?: SortOrderInput | SortOrder
    role?: SortOrder
    slug?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    pessoaCarona?: CarroOrderByRelationAggregateInput
    pessoaMotorista?: CarroOrderByRelationAggregateInput
    cartasDigitais?: CartaOrderByRelationAggregateInput
    tioAparenteCirculo?: CirculoOrderByWithRelationInput
    tioSecretoCirculo?: CirculoOrderByWithRelationInput
    encontreiro?: EncontreiroOrderByWithRelationInput
    encontrista?: EncontristaOrderByWithRelationInput
    endereco?: EnderecoOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type PessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    slug?: string
    AND?: PessoaWhereInput | PessoaWhereInput[]
    OR?: PessoaWhereInput[]
    NOT?: PessoaWhereInput | PessoaWhereInput[]
    nome?: StringFilter<"Pessoa"> | string
    sobrenome?: StringFilter<"Pessoa"> | string
    celular?: StringFilter<"Pessoa"> | string
    telefone?: StringNullableFilter<"Pessoa"> | string | null
    createdAt?: DateTimeFilter<"Pessoa"> | Date | string
    modifiedAt?: DateTimeFilter<"Pessoa"> | Date | string
    enderecoCep?: StringFilter<"Pessoa"> | string
    enderecoNumero?: IntNullableFilter<"Pessoa"> | number | null
    avatarUrl?: StringNullableFilter<"Pessoa"> | string | null
    password?: StringNullableFilter<"Pessoa"> | string | null
    changePassword?: BoolFilter<"Pessoa"> | boolean
    apelido?: StringNullableFilter<"Pessoa"> | string | null
    role?: EnumRoleFilter<"Pessoa"> | $Enums.Role
    accounts?: AccountListRelationFilter
    pessoaCarona?: CarroListRelationFilter
    pessoaMotorista?: CarroListRelationFilter
    cartasDigitais?: CartaListRelationFilter
    tioAparenteCirculo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    tioSecretoCirculo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    encontreiro?: XOR<EncontreiroNullableScalarRelationFilter, EncontreiroWhereInput> | null
    encontrista?: XOR<EncontristaNullableScalarRelationFilter, EncontristaWhereInput> | null
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
    sessions?: SessionListRelationFilter
  }, "id" | "email" | "slug">

  export type PessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    celular?: SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    enderecoCep?: SortOrder
    enderecoNumero?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    changePassword?: SortOrder
    apelido?: SortOrderInput | SortOrder
    role?: SortOrder
    slug?: SortOrder
    _count?: PessoaCountOrderByAggregateInput
    _avg?: PessoaAvgOrderByAggregateInput
    _max?: PessoaMaxOrderByAggregateInput
    _min?: PessoaMinOrderByAggregateInput
    _sum?: PessoaSumOrderByAggregateInput
  }

  export type PessoaScalarWhereWithAggregatesInput = {
    AND?: PessoaScalarWhereWithAggregatesInput | PessoaScalarWhereWithAggregatesInput[]
    OR?: PessoaScalarWhereWithAggregatesInput[]
    NOT?: PessoaScalarWhereWithAggregatesInput | PessoaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pessoa"> | string
    nome?: StringWithAggregatesFilter<"Pessoa"> | string
    sobrenome?: StringWithAggregatesFilter<"Pessoa"> | string
    celular?: StringWithAggregatesFilter<"Pessoa"> | string
    telefone?: StringNullableWithAggregatesFilter<"Pessoa"> | string | null
    email?: StringWithAggregatesFilter<"Pessoa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pessoa"> | Date | string
    modifiedAt?: DateTimeWithAggregatesFilter<"Pessoa"> | Date | string
    enderecoCep?: StringWithAggregatesFilter<"Pessoa"> | string
    enderecoNumero?: IntNullableWithAggregatesFilter<"Pessoa"> | number | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Pessoa"> | string | null
    password?: StringNullableWithAggregatesFilter<"Pessoa"> | string | null
    changePassword?: BoolWithAggregatesFilter<"Pessoa"> | boolean
    apelido?: StringNullableWithAggregatesFilter<"Pessoa"> | string | null
    role?: EnumRoleWithAggregatesFilter<"Pessoa"> | $Enums.Role
    slug?: StringWithAggregatesFilter<"Pessoa"> | string
  }

  export type EncontristaWhereInput = {
    AND?: EncontristaWhereInput | EncontristaWhereInput[]
    OR?: EncontristaWhereInput[]
    NOT?: EncontristaWhereInput | EncontristaWhereInput[]
    idPessoa?: StringFilter<"Encontrista"> | string
    endComplemento?: StringFilter<"Encontrista"> | string
    movimentoAnterior?: StringNullableFilter<"Encontrista"> | string | null
    observacao?: StringNullableFilter<"Encontrista"> | string | null
    nomeContato1?: StringFilter<"Encontrista"> | string
    telContato1?: StringFilter<"Encontrista"> | string
    parentescoContato1?: StringFilter<"Encontrista"> | string
    nomeContato2?: StringNullableFilter<"Encontrista"> | string | null
    telContato2?: StringNullableFilter<"Encontrista"> | string | null
    parentescoContato2?: StringNullableFilter<"Encontrista"> | string | null
    createdAt?: DateTimeFilter<"Encontrista"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontrista"> | Date | string
    indicadoPorApelido?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorEmail?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorNome?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorTel?: StringNullableFilter<"Encontrista"> | string | null
    isAutofill?: BoolFilter<"Encontrista"> | boolean
    idStatus?: EnumValue_StatusFilter<"Encontrista"> | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFilter<"Encontrista"> | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFilter<"Encontrista"> | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFilter<"Encontrista"> | $Enums.Value_StatusPais
    endNumero?: IntFilter<"Encontrista"> | number
    cartasFisicas?: IntFilter<"Encontrista"> | number
    idCarroEncontro?: StringNullableFilter<"Encontrista"> | string | null
    cepEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endComplementoEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endNumEncontro?: IntNullableFilter<"Encontrista"> | number | null
    obsExternaConhecidos?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaLocalizacao?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaOutros?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaSaude?: StringNullableFilter<"Encontrista"> | string | null
    cartasOk?: BoolFilter<"Encontrista"> | boolean
    generosaOk?: BoolFilter<"Encontrista"> | boolean
    familiaOk?: BoolFilter<"Encontrista"> | boolean
    enderecoEncontro?: XOR<EnderecoNullableScalarRelationFilter, EnderecoWhereInput> | null
    carroEncontro?: XOR<CarroEncontroNullableScalarRelationFilter, CarroEncontroWhereInput> | null
    moraCom?: XOR<DomainMoraComScalarRelationFilter, DomainMoraComWhereInput>
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    religiao?: XOR<DomainReligiaoScalarRelationFilter, DomainReligiaoWhereInput>
    statusPais?: XOR<DomainStatusPaisScalarRelationFilter, DomainStatusPaisWhereInput>
    status?: XOR<DomainStatusScalarRelationFilter, DomainStatusWhereInput>
    responsavelExterna?: XOR<ResponsavelExternaNullableScalarRelationFilter, ResponsavelExternaWhereInput> | null
  }

  export type EncontristaOrderByWithRelationInput = {
    idPessoa?: SortOrder
    endComplemento?: SortOrder
    movimentoAnterior?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    nomeContato1?: SortOrder
    telContato1?: SortOrder
    parentescoContato1?: SortOrder
    nomeContato2?: SortOrderInput | SortOrder
    telContato2?: SortOrderInput | SortOrder
    parentescoContato2?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    indicadoPorApelido?: SortOrderInput | SortOrder
    indicadoPorEmail?: SortOrderInput | SortOrder
    indicadoPorNome?: SortOrderInput | SortOrder
    indicadoPorTel?: SortOrderInput | SortOrder
    isAutofill?: SortOrder
    idStatus?: SortOrder
    idReligiao?: SortOrder
    idMoracom?: SortOrder
    idStatusPais?: SortOrder
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    idCarroEncontro?: SortOrderInput | SortOrder
    cepEncontro?: SortOrderInput | SortOrder
    endComplementoEncontro?: SortOrderInput | SortOrder
    endNumEncontro?: SortOrderInput | SortOrder
    obsExternaConhecidos?: SortOrderInput | SortOrder
    obsExternaLocalizacao?: SortOrderInput | SortOrder
    obsExternaOutros?: SortOrderInput | SortOrder
    obsExternaSaude?: SortOrderInput | SortOrder
    cartasOk?: SortOrder
    generosaOk?: SortOrder
    familiaOk?: SortOrder
    enderecoEncontro?: EnderecoOrderByWithRelationInput
    carroEncontro?: CarroEncontroOrderByWithRelationInput
    moraCom?: DomainMoraComOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
    religiao?: DomainReligiaoOrderByWithRelationInput
    statusPais?: DomainStatusPaisOrderByWithRelationInput
    status?: DomainStatusOrderByWithRelationInput
    responsavelExterna?: ResponsavelExternaOrderByWithRelationInput
  }

  export type EncontristaWhereUniqueInput = Prisma.AtLeast<{
    idPessoa?: string
    AND?: EncontristaWhereInput | EncontristaWhereInput[]
    OR?: EncontristaWhereInput[]
    NOT?: EncontristaWhereInput | EncontristaWhereInput[]
    endComplemento?: StringFilter<"Encontrista"> | string
    movimentoAnterior?: StringNullableFilter<"Encontrista"> | string | null
    observacao?: StringNullableFilter<"Encontrista"> | string | null
    nomeContato1?: StringFilter<"Encontrista"> | string
    telContato1?: StringFilter<"Encontrista"> | string
    parentescoContato1?: StringFilter<"Encontrista"> | string
    nomeContato2?: StringNullableFilter<"Encontrista"> | string | null
    telContato2?: StringNullableFilter<"Encontrista"> | string | null
    parentescoContato2?: StringNullableFilter<"Encontrista"> | string | null
    createdAt?: DateTimeFilter<"Encontrista"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontrista"> | Date | string
    indicadoPorApelido?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorEmail?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorNome?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorTel?: StringNullableFilter<"Encontrista"> | string | null
    isAutofill?: BoolFilter<"Encontrista"> | boolean
    idStatus?: EnumValue_StatusFilter<"Encontrista"> | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFilter<"Encontrista"> | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFilter<"Encontrista"> | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFilter<"Encontrista"> | $Enums.Value_StatusPais
    endNumero?: IntFilter<"Encontrista"> | number
    cartasFisicas?: IntFilter<"Encontrista"> | number
    idCarroEncontro?: StringNullableFilter<"Encontrista"> | string | null
    cepEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endComplementoEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endNumEncontro?: IntNullableFilter<"Encontrista"> | number | null
    obsExternaConhecidos?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaLocalizacao?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaOutros?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaSaude?: StringNullableFilter<"Encontrista"> | string | null
    cartasOk?: BoolFilter<"Encontrista"> | boolean
    generosaOk?: BoolFilter<"Encontrista"> | boolean
    familiaOk?: BoolFilter<"Encontrista"> | boolean
    enderecoEncontro?: XOR<EnderecoNullableScalarRelationFilter, EnderecoWhereInput> | null
    carroEncontro?: XOR<CarroEncontroNullableScalarRelationFilter, CarroEncontroWhereInput> | null
    moraCom?: XOR<DomainMoraComScalarRelationFilter, DomainMoraComWhereInput>
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    religiao?: XOR<DomainReligiaoScalarRelationFilter, DomainReligiaoWhereInput>
    statusPais?: XOR<DomainStatusPaisScalarRelationFilter, DomainStatusPaisWhereInput>
    status?: XOR<DomainStatusScalarRelationFilter, DomainStatusWhereInput>
    responsavelExterna?: XOR<ResponsavelExternaNullableScalarRelationFilter, ResponsavelExternaWhereInput> | null
  }, "idPessoa">

  export type EncontristaOrderByWithAggregationInput = {
    idPessoa?: SortOrder
    endComplemento?: SortOrder
    movimentoAnterior?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    nomeContato1?: SortOrder
    telContato1?: SortOrder
    parentescoContato1?: SortOrder
    nomeContato2?: SortOrderInput | SortOrder
    telContato2?: SortOrderInput | SortOrder
    parentescoContato2?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    indicadoPorApelido?: SortOrderInput | SortOrder
    indicadoPorEmail?: SortOrderInput | SortOrder
    indicadoPorNome?: SortOrderInput | SortOrder
    indicadoPorTel?: SortOrderInput | SortOrder
    isAutofill?: SortOrder
    idStatus?: SortOrder
    idReligiao?: SortOrder
    idMoracom?: SortOrder
    idStatusPais?: SortOrder
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    idCarroEncontro?: SortOrderInput | SortOrder
    cepEncontro?: SortOrderInput | SortOrder
    endComplementoEncontro?: SortOrderInput | SortOrder
    endNumEncontro?: SortOrderInput | SortOrder
    obsExternaConhecidos?: SortOrderInput | SortOrder
    obsExternaLocalizacao?: SortOrderInput | SortOrder
    obsExternaOutros?: SortOrderInput | SortOrder
    obsExternaSaude?: SortOrderInput | SortOrder
    cartasOk?: SortOrder
    generosaOk?: SortOrder
    familiaOk?: SortOrder
    _count?: EncontristaCountOrderByAggregateInput
    _avg?: EncontristaAvgOrderByAggregateInput
    _max?: EncontristaMaxOrderByAggregateInput
    _min?: EncontristaMinOrderByAggregateInput
    _sum?: EncontristaSumOrderByAggregateInput
  }

  export type EncontristaScalarWhereWithAggregatesInput = {
    AND?: EncontristaScalarWhereWithAggregatesInput | EncontristaScalarWhereWithAggregatesInput[]
    OR?: EncontristaScalarWhereWithAggregatesInput[]
    NOT?: EncontristaScalarWhereWithAggregatesInput | EncontristaScalarWhereWithAggregatesInput[]
    idPessoa?: StringWithAggregatesFilter<"Encontrista"> | string
    endComplemento?: StringWithAggregatesFilter<"Encontrista"> | string
    movimentoAnterior?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    observacao?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    nomeContato1?: StringWithAggregatesFilter<"Encontrista"> | string
    telContato1?: StringWithAggregatesFilter<"Encontrista"> | string
    parentescoContato1?: StringWithAggregatesFilter<"Encontrista"> | string
    nomeContato2?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    telContato2?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    parentescoContato2?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Encontrista"> | Date | string
    modifiedAt?: DateTimeWithAggregatesFilter<"Encontrista"> | Date | string
    indicadoPorApelido?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    indicadoPorEmail?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    indicadoPorNome?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    indicadoPorTel?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    isAutofill?: BoolWithAggregatesFilter<"Encontrista"> | boolean
    idStatus?: EnumValue_StatusWithAggregatesFilter<"Encontrista"> | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoWithAggregatesFilter<"Encontrista"> | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComWithAggregatesFilter<"Encontrista"> | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisWithAggregatesFilter<"Encontrista"> | $Enums.Value_StatusPais
    endNumero?: IntWithAggregatesFilter<"Encontrista"> | number
    cartasFisicas?: IntWithAggregatesFilter<"Encontrista"> | number
    idCarroEncontro?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    cepEncontro?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    endComplementoEncontro?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    endNumEncontro?: IntNullableWithAggregatesFilter<"Encontrista"> | number | null
    obsExternaConhecidos?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    obsExternaLocalizacao?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    obsExternaOutros?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    obsExternaSaude?: StringNullableWithAggregatesFilter<"Encontrista"> | string | null
    cartasOk?: BoolWithAggregatesFilter<"Encontrista"> | boolean
    generosaOk?: BoolWithAggregatesFilter<"Encontrista"> | boolean
    familiaOk?: BoolWithAggregatesFilter<"Encontrista"> | boolean
  }

  export type EncontreiroWhereInput = {
    AND?: EncontreiroWhereInput | EncontreiroWhereInput[]
    OR?: EncontreiroWhereInput[]
    NOT?: EncontreiroWhereInput | EncontreiroWhereInput[]
    idPessoa?: StringFilter<"Encontreiro"> | string
    dataNasc?: DateTimeFilter<"Encontreiro"> | Date | string
    instagram?: StringNullableFilter<"Encontreiro"> | string | null
    restricaoAlimentar?: StringNullableFilter<"Encontreiro"> | string | null
    idEncontro?: StringNullableFilter<"Encontreiro"> | string | null
    idCirculo?: StringNullableFilter<"Encontreiro"> | string | null
    idTamanhoCamisa?: EnumValue_TamanhoCamisaNullableFilter<"Encontreiro"> | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: EnumValue_DisponibilidadeNullableFilter<"Encontreiro"> | $Enums.Value_Disponibilidade | null
    obsBanda?: StringNullableFilter<"Encontreiro"> | string | null
    observacoes?: StringNullableFilter<"Encontreiro"> | string | null
    statusMontagem?: EnumStatusEncontreiroNullableFilter<"Encontreiro"> | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroListRelationFilter
    circulo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    encontro?: XOR<EncontroNullableScalarRelationFilter, EncontroWhereInput> | null
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    tamanhoCamisa?: XOR<DomainTamanhoCamisaNullableScalarRelationFilter, DomainTamanhoCamisaWhereInput> | null
    disponibilidade?: XOR<DomainDisponibilidadeNullableScalarRelationFilter, DomainDisponibilidadeWhereInput> | null
    equipeEncontro?: EquipeEncontroListRelationFilter
    equipeMontagem?: XOR<EquipeMontagemNullableScalarRelationFilter, EquipeMontagemWhereInput> | null
    listaPreferencias?: ListaPreferenciaListRelationFilter
    responsavelExterna?: ResponsavelExternaListRelationFilter
  }

  export type EncontreiroOrderByWithRelationInput = {
    idPessoa?: SortOrder
    dataNasc?: SortOrder
    instagram?: SortOrderInput | SortOrder
    restricaoAlimentar?: SortOrderInput | SortOrder
    idEncontro?: SortOrderInput | SortOrder
    idCirculo?: SortOrderInput | SortOrder
    idTamanhoCamisa?: SortOrderInput | SortOrder
    idDisponibilidade?: SortOrderInput | SortOrder
    obsBanda?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    statusMontagem?: SortOrderInput | SortOrder
    responsavelCarroExterna?: CarroEncontroOrderByRelationAggregateInput
    circulo?: CirculoOrderByWithRelationInput
    encontro?: EncontroOrderByWithRelationInput
    pessoa?: PessoaOrderByWithRelationInput
    tamanhoCamisa?: DomainTamanhoCamisaOrderByWithRelationInput
    disponibilidade?: DomainDisponibilidadeOrderByWithRelationInput
    equipeEncontro?: EquipeEncontroOrderByRelationAggregateInput
    equipeMontagem?: EquipeMontagemOrderByWithRelationInput
    listaPreferencias?: ListaPreferenciaOrderByRelationAggregateInput
    responsavelExterna?: ResponsavelExternaOrderByRelationAggregateInput
  }

  export type EncontreiroWhereUniqueInput = Prisma.AtLeast<{
    idPessoa?: string
    AND?: EncontreiroWhereInput | EncontreiroWhereInput[]
    OR?: EncontreiroWhereInput[]
    NOT?: EncontreiroWhereInput | EncontreiroWhereInput[]
    dataNasc?: DateTimeFilter<"Encontreiro"> | Date | string
    instagram?: StringNullableFilter<"Encontreiro"> | string | null
    restricaoAlimentar?: StringNullableFilter<"Encontreiro"> | string | null
    idEncontro?: StringNullableFilter<"Encontreiro"> | string | null
    idCirculo?: StringNullableFilter<"Encontreiro"> | string | null
    idTamanhoCamisa?: EnumValue_TamanhoCamisaNullableFilter<"Encontreiro"> | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: EnumValue_DisponibilidadeNullableFilter<"Encontreiro"> | $Enums.Value_Disponibilidade | null
    obsBanda?: StringNullableFilter<"Encontreiro"> | string | null
    observacoes?: StringNullableFilter<"Encontreiro"> | string | null
    statusMontagem?: EnumStatusEncontreiroNullableFilter<"Encontreiro"> | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroListRelationFilter
    circulo?: XOR<CirculoNullableScalarRelationFilter, CirculoWhereInput> | null
    encontro?: XOR<EncontroNullableScalarRelationFilter, EncontroWhereInput> | null
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
    tamanhoCamisa?: XOR<DomainTamanhoCamisaNullableScalarRelationFilter, DomainTamanhoCamisaWhereInput> | null
    disponibilidade?: XOR<DomainDisponibilidadeNullableScalarRelationFilter, DomainDisponibilidadeWhereInput> | null
    equipeEncontro?: EquipeEncontroListRelationFilter
    equipeMontagem?: XOR<EquipeMontagemNullableScalarRelationFilter, EquipeMontagemWhereInput> | null
    listaPreferencias?: ListaPreferenciaListRelationFilter
    responsavelExterna?: ResponsavelExternaListRelationFilter
  }, "idPessoa">

  export type EncontreiroOrderByWithAggregationInput = {
    idPessoa?: SortOrder
    dataNasc?: SortOrder
    instagram?: SortOrderInput | SortOrder
    restricaoAlimentar?: SortOrderInput | SortOrder
    idEncontro?: SortOrderInput | SortOrder
    idCirculo?: SortOrderInput | SortOrder
    idTamanhoCamisa?: SortOrderInput | SortOrder
    idDisponibilidade?: SortOrderInput | SortOrder
    obsBanda?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    statusMontagem?: SortOrderInput | SortOrder
    _count?: EncontreiroCountOrderByAggregateInput
    _max?: EncontreiroMaxOrderByAggregateInput
    _min?: EncontreiroMinOrderByAggregateInput
  }

  export type EncontreiroScalarWhereWithAggregatesInput = {
    AND?: EncontreiroScalarWhereWithAggregatesInput | EncontreiroScalarWhereWithAggregatesInput[]
    OR?: EncontreiroScalarWhereWithAggregatesInput[]
    NOT?: EncontreiroScalarWhereWithAggregatesInput | EncontreiroScalarWhereWithAggregatesInput[]
    idPessoa?: StringWithAggregatesFilter<"Encontreiro"> | string
    dataNasc?: DateTimeWithAggregatesFilter<"Encontreiro"> | Date | string
    instagram?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    restricaoAlimentar?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    idEncontro?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    idCirculo?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    idTamanhoCamisa?: EnumValue_TamanhoCamisaNullableWithAggregatesFilter<"Encontreiro"> | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: EnumValue_DisponibilidadeNullableWithAggregatesFilter<"Encontreiro"> | $Enums.Value_Disponibilidade | null
    obsBanda?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    observacoes?: StringNullableWithAggregatesFilter<"Encontreiro"> | string | null
    statusMontagem?: EnumStatusEncontreiroNullableWithAggregatesFilter<"Encontreiro"> | $Enums.StatusEncontreiro | null
  }

  export type EncontroWhereInput = {
    AND?: EncontroWhereInput | EncontroWhereInput[]
    OR?: EncontroWhereInput[]
    NOT?: EncontroWhereInput | EncontroWhereInput[]
    id?: StringFilter<"Encontro"> | string
    numeroEncontro?: IntFilter<"Encontro"> | number
    idLocal?: StringFilter<"Encontro"> | string
    temaEspiritual?: StringNullableFilter<"Encontro"> | string | null
    temaFantasia?: StringNullableFilter<"Encontro"> | string | null
    numeroCirculos?: IntFilter<"Encontro"> | number
    dataInicio?: DateTimeFilter<"Encontro"> | Date | string
    dataTema?: DateTimeFilter<"Encontro"> | Date | string
    createdAt?: DateTimeFilter<"Encontro"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontro"> | Date | string
    ordemCirculos?: IntFilter<"Encontro"> | number
    isReceivingCartas?: BoolFilter<"Encontro"> | boolean
    carroEncontro?: CarroEncontroListRelationFilter
    circulo?: CirculoListRelationFilter
    encontreiro?: EncontreiroListRelationFilter
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    EquipeEncontro?: EquipeEncontroListRelationFilter
    ResponsavelExterna?: ResponsavelExternaListRelationFilter
  }

  export type EncontroOrderByWithRelationInput = {
    id?: SortOrder
    numeroEncontro?: SortOrder
    idLocal?: SortOrder
    temaEspiritual?: SortOrderInput | SortOrder
    temaFantasia?: SortOrderInput | SortOrder
    numeroCirculos?: SortOrder
    dataInicio?: SortOrder
    dataTema?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    ordemCirculos?: SortOrder
    isReceivingCartas?: SortOrder
    carroEncontro?: CarroEncontroOrderByRelationAggregateInput
    circulo?: CirculoOrderByRelationAggregateInput
    encontreiro?: EncontreiroOrderByRelationAggregateInput
    local?: LocalOrderByWithRelationInput
    EquipeEncontro?: EquipeEncontroOrderByRelationAggregateInput
    ResponsavelExterna?: ResponsavelExternaOrderByRelationAggregateInput
  }

  export type EncontroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroEncontro?: number
    dataInicio?: Date | string
    dataTema?: Date | string
    AND?: EncontroWhereInput | EncontroWhereInput[]
    OR?: EncontroWhereInput[]
    NOT?: EncontroWhereInput | EncontroWhereInput[]
    idLocal?: StringFilter<"Encontro"> | string
    temaEspiritual?: StringNullableFilter<"Encontro"> | string | null
    temaFantasia?: StringNullableFilter<"Encontro"> | string | null
    numeroCirculos?: IntFilter<"Encontro"> | number
    createdAt?: DateTimeFilter<"Encontro"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontro"> | Date | string
    ordemCirculos?: IntFilter<"Encontro"> | number
    isReceivingCartas?: BoolFilter<"Encontro"> | boolean
    carroEncontro?: CarroEncontroListRelationFilter
    circulo?: CirculoListRelationFilter
    encontreiro?: EncontreiroListRelationFilter
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    EquipeEncontro?: EquipeEncontroListRelationFilter
    ResponsavelExterna?: ResponsavelExternaListRelationFilter
  }, "id" | "numeroEncontro" | "dataInicio" | "dataTema">

  export type EncontroOrderByWithAggregationInput = {
    id?: SortOrder
    numeroEncontro?: SortOrder
    idLocal?: SortOrder
    temaEspiritual?: SortOrderInput | SortOrder
    temaFantasia?: SortOrderInput | SortOrder
    numeroCirculos?: SortOrder
    dataInicio?: SortOrder
    dataTema?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    ordemCirculos?: SortOrder
    isReceivingCartas?: SortOrder
    _count?: EncontroCountOrderByAggregateInput
    _avg?: EncontroAvgOrderByAggregateInput
    _max?: EncontroMaxOrderByAggregateInput
    _min?: EncontroMinOrderByAggregateInput
    _sum?: EncontroSumOrderByAggregateInput
  }

  export type EncontroScalarWhereWithAggregatesInput = {
    AND?: EncontroScalarWhereWithAggregatesInput | EncontroScalarWhereWithAggregatesInput[]
    OR?: EncontroScalarWhereWithAggregatesInput[]
    NOT?: EncontroScalarWhereWithAggregatesInput | EncontroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encontro"> | string
    numeroEncontro?: IntWithAggregatesFilter<"Encontro"> | number
    idLocal?: StringWithAggregatesFilter<"Encontro"> | string
    temaEspiritual?: StringNullableWithAggregatesFilter<"Encontro"> | string | null
    temaFantasia?: StringNullableWithAggregatesFilter<"Encontro"> | string | null
    numeroCirculos?: IntWithAggregatesFilter<"Encontro"> | number
    dataInicio?: DateTimeWithAggregatesFilter<"Encontro"> | Date | string
    dataTema?: DateTimeWithAggregatesFilter<"Encontro"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Encontro"> | Date | string
    modifiedAt?: DateTimeWithAggregatesFilter<"Encontro"> | Date | string
    ordemCirculos?: IntWithAggregatesFilter<"Encontro"> | number
    isReceivingCartas?: BoolWithAggregatesFilter<"Encontro"> | boolean
  }

  export type CirculoWhereInput = {
    AND?: CirculoWhereInput | CirculoWhereInput[]
    OR?: CirculoWhereInput[]
    NOT?: CirculoWhereInput | CirculoWhereInput[]
    id?: StringFilter<"Circulo"> | string
    idCorCirculo?: IntFilter<"Circulo"> | number
    idTioAparente?: StringNullableFilter<"Circulo"> | string | null
    idTioSecreto?: StringNullableFilter<"Circulo"> | string | null
    idEncontro?: StringFilter<"Circulo"> | string
    nome?: StringNullableFilter<"Circulo"> | string | null
    corCirculo?: XOR<DomainCorCirculoScalarRelationFilter, DomainCorCirculoWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    tioAparente?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    tioSecreto?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    encontreiro?: EncontreiroListRelationFilter
  }

  export type CirculoOrderByWithRelationInput = {
    id?: SortOrder
    idCorCirculo?: SortOrder
    idTioAparente?: SortOrderInput | SortOrder
    idTioSecreto?: SortOrderInput | SortOrder
    idEncontro?: SortOrder
    nome?: SortOrderInput | SortOrder
    corCirculo?: DomainCorCirculoOrderByWithRelationInput
    encontro?: EncontroOrderByWithRelationInput
    tioAparente?: PessoaOrderByWithRelationInput
    tioSecreto?: PessoaOrderByWithRelationInput
    encontreiro?: EncontreiroOrderByRelationAggregateInput
  }

  export type CirculoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idTioAparente?: string
    idTioSecreto?: string
    AND?: CirculoWhereInput | CirculoWhereInput[]
    OR?: CirculoWhereInput[]
    NOT?: CirculoWhereInput | CirculoWhereInput[]
    idCorCirculo?: IntFilter<"Circulo"> | number
    idEncontro?: StringFilter<"Circulo"> | string
    nome?: StringNullableFilter<"Circulo"> | string | null
    corCirculo?: XOR<DomainCorCirculoScalarRelationFilter, DomainCorCirculoWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    tioAparente?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    tioSecreto?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    encontreiro?: EncontreiroListRelationFilter
  }, "id" | "idTioAparente" | "idTioSecreto">

  export type CirculoOrderByWithAggregationInput = {
    id?: SortOrder
    idCorCirculo?: SortOrder
    idTioAparente?: SortOrderInput | SortOrder
    idTioSecreto?: SortOrderInput | SortOrder
    idEncontro?: SortOrder
    nome?: SortOrderInput | SortOrder
    _count?: CirculoCountOrderByAggregateInput
    _avg?: CirculoAvgOrderByAggregateInput
    _max?: CirculoMaxOrderByAggregateInput
    _min?: CirculoMinOrderByAggregateInput
    _sum?: CirculoSumOrderByAggregateInput
  }

  export type CirculoScalarWhereWithAggregatesInput = {
    AND?: CirculoScalarWhereWithAggregatesInput | CirculoScalarWhereWithAggregatesInput[]
    OR?: CirculoScalarWhereWithAggregatesInput[]
    NOT?: CirculoScalarWhereWithAggregatesInput | CirculoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Circulo"> | string
    idCorCirculo?: IntWithAggregatesFilter<"Circulo"> | number
    idTioAparente?: StringNullableWithAggregatesFilter<"Circulo"> | string | null
    idTioSecreto?: StringNullableWithAggregatesFilter<"Circulo"> | string | null
    idEncontro?: StringWithAggregatesFilter<"Circulo"> | string
    nome?: StringNullableWithAggregatesFilter<"Circulo"> | string | null
  }

  export type EnderecoWhereInput = {
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    cep?: StringFilter<"Endereco"> | string
    estado?: StringFilter<"Endereco"> | string
    cidade?: StringFilter<"Endereco"> | string
    bairro?: StringFilter<"Endereco"> | string
    rua?: StringFilter<"Endereco"> | string
    createdAt?: DateTimeFilter<"Endereco"> | Date | string
    modifiedAt?: DateTimeFilter<"Endereco"> | Date | string
    Encontrista?: EncontristaListRelationFilter
    local?: LocalListRelationFilter
    pessoa?: PessoaListRelationFilter
  }

  export type EnderecoOrderByWithRelationInput = {
    cep?: SortOrder
    estado?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    rua?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    Encontrista?: EncontristaOrderByRelationAggregateInput
    local?: LocalOrderByRelationAggregateInput
    pessoa?: PessoaOrderByRelationAggregateInput
  }

  export type EnderecoWhereUniqueInput = Prisma.AtLeast<{
    cep?: string
    AND?: EnderecoWhereInput | EnderecoWhereInput[]
    OR?: EnderecoWhereInput[]
    NOT?: EnderecoWhereInput | EnderecoWhereInput[]
    estado?: StringFilter<"Endereco"> | string
    cidade?: StringFilter<"Endereco"> | string
    bairro?: StringFilter<"Endereco"> | string
    rua?: StringFilter<"Endereco"> | string
    createdAt?: DateTimeFilter<"Endereco"> | Date | string
    modifiedAt?: DateTimeFilter<"Endereco"> | Date | string
    Encontrista?: EncontristaListRelationFilter
    local?: LocalListRelationFilter
    pessoa?: PessoaListRelationFilter
  }, "cep">

  export type EnderecoOrderByWithAggregationInput = {
    cep?: SortOrder
    estado?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    rua?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    _count?: EnderecoCountOrderByAggregateInput
    _max?: EnderecoMaxOrderByAggregateInput
    _min?: EnderecoMinOrderByAggregateInput
  }

  export type EnderecoScalarWhereWithAggregatesInput = {
    AND?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    OR?: EnderecoScalarWhereWithAggregatesInput[]
    NOT?: EnderecoScalarWhereWithAggregatesInput | EnderecoScalarWhereWithAggregatesInput[]
    cep?: StringWithAggregatesFilter<"Endereco"> | string
    estado?: StringWithAggregatesFilter<"Endereco"> | string
    cidade?: StringWithAggregatesFilter<"Endereco"> | string
    bairro?: StringWithAggregatesFilter<"Endereco"> | string
    rua?: StringWithAggregatesFilter<"Endereco"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Endereco"> | Date | string
    modifiedAt?: DateTimeWithAggregatesFilter<"Endereco"> | Date | string
  }

  export type LocalWhereInput = {
    AND?: LocalWhereInput | LocalWhereInput[]
    OR?: LocalWhereInput[]
    NOT?: LocalWhereInput | LocalWhereInput[]
    id?: StringFilter<"Local"> | string
    enderecoCep?: StringFilter<"Local"> | string
    nomeLocal?: StringFilter<"Local"> | string
    numeroLocal?: StringFilter<"Local"> | string
    encontro?: EncontroListRelationFilter
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
  }

  export type LocalOrderByWithRelationInput = {
    id?: SortOrder
    enderecoCep?: SortOrder
    nomeLocal?: SortOrder
    numeroLocal?: SortOrder
    encontro?: EncontroOrderByRelationAggregateInput
    endereco?: EnderecoOrderByWithRelationInput
  }

  export type LocalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocalWhereInput | LocalWhereInput[]
    OR?: LocalWhereInput[]
    NOT?: LocalWhereInput | LocalWhereInput[]
    enderecoCep?: StringFilter<"Local"> | string
    nomeLocal?: StringFilter<"Local"> | string
    numeroLocal?: StringFilter<"Local"> | string
    encontro?: EncontroListRelationFilter
    endereco?: XOR<EnderecoScalarRelationFilter, EnderecoWhereInput>
  }, "id">

  export type LocalOrderByWithAggregationInput = {
    id?: SortOrder
    enderecoCep?: SortOrder
    nomeLocal?: SortOrder
    numeroLocal?: SortOrder
    _count?: LocalCountOrderByAggregateInput
    _max?: LocalMaxOrderByAggregateInput
    _min?: LocalMinOrderByAggregateInput
  }

  export type LocalScalarWhereWithAggregatesInput = {
    AND?: LocalScalarWhereWithAggregatesInput | LocalScalarWhereWithAggregatesInput[]
    OR?: LocalScalarWhereWithAggregatesInput[]
    NOT?: LocalScalarWhereWithAggregatesInput | LocalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Local"> | string
    enderecoCep?: StringWithAggregatesFilter<"Local"> | string
    nomeLocal?: StringWithAggregatesFilter<"Local"> | string
    numeroLocal?: StringWithAggregatesFilter<"Local"> | string
  }

  export type CarroWhereInput = {
    AND?: CarroWhereInput | CarroWhereInput[]
    OR?: CarroWhereInput[]
    NOT?: CarroWhereInput | CarroWhereInput[]
    id?: StringFilter<"Carro"> | string
    idMotorista?: StringFilter<"Carro"> | string
    modeloCarro?: StringFilter<"Carro"> | string
    placaCarro?: StringFilter<"Carro"> | string
    lugaresCarro?: IntFilter<"Carro"> | number
    observacaoMotorista?: StringFilter<"Carro"> | string
    idCarona?: StringNullableFilter<"Carro"> | string | null
    carroEncontro?: CarroEncontroListRelationFilter
    pessoaCarona?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    pessoaMotorista?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type CarroOrderByWithRelationInput = {
    id?: SortOrder
    idMotorista?: SortOrder
    modeloCarro?: SortOrder
    placaCarro?: SortOrder
    lugaresCarro?: SortOrder
    observacaoMotorista?: SortOrder
    idCarona?: SortOrderInput | SortOrder
    carroEncontro?: CarroEncontroOrderByRelationAggregateInput
    pessoaCarona?: PessoaOrderByWithRelationInput
    pessoaMotorista?: PessoaOrderByWithRelationInput
  }

  export type CarroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idMotorista_placaCarro?: CarroIdMotoristaPlacaCarroCompoundUniqueInput
    AND?: CarroWhereInput | CarroWhereInput[]
    OR?: CarroWhereInput[]
    NOT?: CarroWhereInput | CarroWhereInput[]
    idMotorista?: StringFilter<"Carro"> | string
    modeloCarro?: StringFilter<"Carro"> | string
    placaCarro?: StringFilter<"Carro"> | string
    lugaresCarro?: IntFilter<"Carro"> | number
    observacaoMotorista?: StringFilter<"Carro"> | string
    idCarona?: StringNullableFilter<"Carro"> | string | null
    carroEncontro?: CarroEncontroListRelationFilter
    pessoaCarona?: XOR<PessoaNullableScalarRelationFilter, PessoaWhereInput> | null
    pessoaMotorista?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "id" | "idMotorista_placaCarro">

  export type CarroOrderByWithAggregationInput = {
    id?: SortOrder
    idMotorista?: SortOrder
    modeloCarro?: SortOrder
    placaCarro?: SortOrder
    lugaresCarro?: SortOrder
    observacaoMotorista?: SortOrder
    idCarona?: SortOrderInput | SortOrder
    _count?: CarroCountOrderByAggregateInput
    _avg?: CarroAvgOrderByAggregateInput
    _max?: CarroMaxOrderByAggregateInput
    _min?: CarroMinOrderByAggregateInput
    _sum?: CarroSumOrderByAggregateInput
  }

  export type CarroScalarWhereWithAggregatesInput = {
    AND?: CarroScalarWhereWithAggregatesInput | CarroScalarWhereWithAggregatesInput[]
    OR?: CarroScalarWhereWithAggregatesInput[]
    NOT?: CarroScalarWhereWithAggregatesInput | CarroScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Carro"> | string
    idMotorista?: StringWithAggregatesFilter<"Carro"> | string
    modeloCarro?: StringWithAggregatesFilter<"Carro"> | string
    placaCarro?: StringWithAggregatesFilter<"Carro"> | string
    lugaresCarro?: IntWithAggregatesFilter<"Carro"> | number
    observacaoMotorista?: StringWithAggregatesFilter<"Carro"> | string
    idCarona?: StringNullableWithAggregatesFilter<"Carro"> | string | null
  }

  export type CarroEncontroWhereInput = {
    AND?: CarroEncontroWhereInput | CarroEncontroWhereInput[]
    OR?: CarroEncontroWhereInput[]
    NOT?: CarroEncontroWhereInput | CarroEncontroWhereInput[]
    idCarro?: StringFilter<"CarroEncontro"> | string
    idEncontro?: StringFilter<"CarroEncontro"> | string
    numeroCarro?: IntFilter<"CarroEncontro"> | number
    idExterna?: StringNullableFilter<"CarroEncontro"> | string | null
    id?: StringFilter<"CarroEncontro"> | string
    observacao?: StringNullableFilter<"CarroEncontro"> | string | null
    externa?: XOR<EncontreiroNullableScalarRelationFilter, EncontreiroWhereInput> | null
    carro?: XOR<CarroScalarRelationFilter, CarroWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    encontrista?: EncontristaListRelationFilter
  }

  export type CarroEncontroOrderByWithRelationInput = {
    idCarro?: SortOrder
    idEncontro?: SortOrder
    numeroCarro?: SortOrder
    idExterna?: SortOrderInput | SortOrder
    id?: SortOrder
    observacao?: SortOrderInput | SortOrder
    externa?: EncontreiroOrderByWithRelationInput
    carro?: CarroOrderByWithRelationInput
    encontro?: EncontroOrderByWithRelationInput
    encontrista?: EncontristaOrderByRelationAggregateInput
  }

  export type CarroEncontroWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idCarro_idEncontro?: CarroEncontroIdCarroIdEncontroCompoundUniqueInput
    AND?: CarroEncontroWhereInput | CarroEncontroWhereInput[]
    OR?: CarroEncontroWhereInput[]
    NOT?: CarroEncontroWhereInput | CarroEncontroWhereInput[]
    idCarro?: StringFilter<"CarroEncontro"> | string
    idEncontro?: StringFilter<"CarroEncontro"> | string
    numeroCarro?: IntFilter<"CarroEncontro"> | number
    idExterna?: StringNullableFilter<"CarroEncontro"> | string | null
    observacao?: StringNullableFilter<"CarroEncontro"> | string | null
    externa?: XOR<EncontreiroNullableScalarRelationFilter, EncontreiroWhereInput> | null
    carro?: XOR<CarroScalarRelationFilter, CarroWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    encontrista?: EncontristaListRelationFilter
  }, "id" | "idCarro_idEncontro">

  export type CarroEncontroOrderByWithAggregationInput = {
    idCarro?: SortOrder
    idEncontro?: SortOrder
    numeroCarro?: SortOrder
    idExterna?: SortOrderInput | SortOrder
    id?: SortOrder
    observacao?: SortOrderInput | SortOrder
    _count?: CarroEncontroCountOrderByAggregateInput
    _avg?: CarroEncontroAvgOrderByAggregateInput
    _max?: CarroEncontroMaxOrderByAggregateInput
    _min?: CarroEncontroMinOrderByAggregateInput
    _sum?: CarroEncontroSumOrderByAggregateInput
  }

  export type CarroEncontroScalarWhereWithAggregatesInput = {
    AND?: CarroEncontroScalarWhereWithAggregatesInput | CarroEncontroScalarWhereWithAggregatesInput[]
    OR?: CarroEncontroScalarWhereWithAggregatesInput[]
    NOT?: CarroEncontroScalarWhereWithAggregatesInput | CarroEncontroScalarWhereWithAggregatesInput[]
    idCarro?: StringWithAggregatesFilter<"CarroEncontro"> | string
    idEncontro?: StringWithAggregatesFilter<"CarroEncontro"> | string
    numeroCarro?: IntWithAggregatesFilter<"CarroEncontro"> | number
    idExterna?: StringNullableWithAggregatesFilter<"CarroEncontro"> | string | null
    id?: StringWithAggregatesFilter<"CarroEncontro"> | string
    observacao?: StringNullableWithAggregatesFilter<"CarroEncontro"> | string | null
  }

  export type ResponsavelExternaWhereInput = {
    AND?: ResponsavelExternaWhereInput | ResponsavelExternaWhereInput[]
    OR?: ResponsavelExternaWhereInput[]
    NOT?: ResponsavelExternaWhereInput | ResponsavelExternaWhereInput[]
    idExterna?: StringFilter<"ResponsavelExterna"> | string
    idEncontrista?: StringFilter<"ResponsavelExterna"> | string
    idEncontro?: StringFilter<"ResponsavelExterna"> | string
    encontrista?: XOR<EncontristaScalarRelationFilter, EncontristaWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    externa?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
  }

  export type ResponsavelExternaOrderByWithRelationInput = {
    idExterna?: SortOrder
    idEncontrista?: SortOrder
    idEncontro?: SortOrder
    encontrista?: EncontristaOrderByWithRelationInput
    encontro?: EncontroOrderByWithRelationInput
    externa?: EncontreiroOrderByWithRelationInput
  }

  export type ResponsavelExternaWhereUniqueInput = Prisma.AtLeast<{
    idEncontrista?: string
    idEncontrista_idEncontro?: ResponsavelExternaIdEncontristaIdEncontroCompoundUniqueInput
    AND?: ResponsavelExternaWhereInput | ResponsavelExternaWhereInput[]
    OR?: ResponsavelExternaWhereInput[]
    NOT?: ResponsavelExternaWhereInput | ResponsavelExternaWhereInput[]
    idExterna?: StringFilter<"ResponsavelExterna"> | string
    idEncontro?: StringFilter<"ResponsavelExterna"> | string
    encontrista?: XOR<EncontristaScalarRelationFilter, EncontristaWhereInput>
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    externa?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
  }, "idEncontrista_idEncontro" | "idEncontrista">

  export type ResponsavelExternaOrderByWithAggregationInput = {
    idExterna?: SortOrder
    idEncontrista?: SortOrder
    idEncontro?: SortOrder
    _count?: ResponsavelExternaCountOrderByAggregateInput
    _max?: ResponsavelExternaMaxOrderByAggregateInput
    _min?: ResponsavelExternaMinOrderByAggregateInput
  }

  export type ResponsavelExternaScalarWhereWithAggregatesInput = {
    AND?: ResponsavelExternaScalarWhereWithAggregatesInput | ResponsavelExternaScalarWhereWithAggregatesInput[]
    OR?: ResponsavelExternaScalarWhereWithAggregatesInput[]
    NOT?: ResponsavelExternaScalarWhereWithAggregatesInput | ResponsavelExternaScalarWhereWithAggregatesInput[]
    idExterna?: StringWithAggregatesFilter<"ResponsavelExterna"> | string
    idEncontrista?: StringWithAggregatesFilter<"ResponsavelExterna"> | string
    idEncontro?: StringWithAggregatesFilter<"ResponsavelExterna"> | string
  }

  export type CartaWhereInput = {
    AND?: CartaWhereInput | CartaWhereInput[]
    OR?: CartaWhereInput[]
    NOT?: CartaWhereInput | CartaWhereInput[]
    id?: StringFilter<"Carta"> | string
    para?: StringFilter<"Carta"> | string
    de?: StringFilter<"Carta"> | string
    conteudo?: StringFilter<"Carta"> | string
    createdAt?: DateTimeFilter<"Carta"> | Date | string
    slugEncontrista?: StringFilter<"Carta"> | string
    isPrinted?: BoolFilter<"Carta"> | boolean
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type CartaOrderByWithRelationInput = {
    id?: SortOrder
    para?: SortOrder
    de?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    slugEncontrista?: SortOrder
    isPrinted?: SortOrder
    pessoa?: PessoaOrderByWithRelationInput
  }

  export type CartaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartaWhereInput | CartaWhereInput[]
    OR?: CartaWhereInput[]
    NOT?: CartaWhereInput | CartaWhereInput[]
    para?: StringFilter<"Carta"> | string
    de?: StringFilter<"Carta"> | string
    conteudo?: StringFilter<"Carta"> | string
    createdAt?: DateTimeFilter<"Carta"> | Date | string
    slugEncontrista?: StringFilter<"Carta"> | string
    isPrinted?: BoolFilter<"Carta"> | boolean
    pessoa?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "id">

  export type CartaOrderByWithAggregationInput = {
    id?: SortOrder
    para?: SortOrder
    de?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    slugEncontrista?: SortOrder
    isPrinted?: SortOrder
    _count?: CartaCountOrderByAggregateInput
    _max?: CartaMaxOrderByAggregateInput
    _min?: CartaMinOrderByAggregateInput
  }

  export type CartaScalarWhereWithAggregatesInput = {
    AND?: CartaScalarWhereWithAggregatesInput | CartaScalarWhereWithAggregatesInput[]
    OR?: CartaScalarWhereWithAggregatesInput[]
    NOT?: CartaScalarWhereWithAggregatesInput | CartaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Carta"> | string
    para?: StringWithAggregatesFilter<"Carta"> | string
    de?: StringWithAggregatesFilter<"Carta"> | string
    conteudo?: StringWithAggregatesFilter<"Carta"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Carta"> | Date | string
    slugEncontrista?: StringWithAggregatesFilter<"Carta"> | string
    isPrinted?: BoolWithAggregatesFilter<"Carta"> | boolean
  }

  export type ListaPreferenciaWhereInput = {
    AND?: ListaPreferenciaWhereInput | ListaPreferenciaWhereInput[]
    OR?: ListaPreferenciaWhereInput[]
    NOT?: ListaPreferenciaWhereInput | ListaPreferenciaWhereInput[]
    idPessoa?: StringFilter<"ListaPreferencia"> | string
    posicao?: IntFilter<"ListaPreferencia"> | number
    valueEquipe?: StringFilter<"ListaPreferencia"> | string
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
  }

  export type ListaPreferenciaOrderByWithRelationInput = {
    idPessoa?: SortOrder
    posicao?: SortOrder
    valueEquipe?: SortOrder
    encontreiro?: EncontreiroOrderByWithRelationInput
    equipe?: DomainEquipesOrderByWithRelationInput
  }

  export type ListaPreferenciaWhereUniqueInput = Prisma.AtLeast<{
    idPessoa_posicao?: ListaPreferenciaIdPessoaPosicaoCompoundUniqueInput
    AND?: ListaPreferenciaWhereInput | ListaPreferenciaWhereInput[]
    OR?: ListaPreferenciaWhereInput[]
    NOT?: ListaPreferenciaWhereInput | ListaPreferenciaWhereInput[]
    idPessoa?: StringFilter<"ListaPreferencia"> | string
    posicao?: IntFilter<"ListaPreferencia"> | number
    valueEquipe?: StringFilter<"ListaPreferencia"> | string
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
  }, "idPessoa_posicao">

  export type ListaPreferenciaOrderByWithAggregationInput = {
    idPessoa?: SortOrder
    posicao?: SortOrder
    valueEquipe?: SortOrder
    _count?: ListaPreferenciaCountOrderByAggregateInput
    _avg?: ListaPreferenciaAvgOrderByAggregateInput
    _max?: ListaPreferenciaMaxOrderByAggregateInput
    _min?: ListaPreferenciaMinOrderByAggregateInput
    _sum?: ListaPreferenciaSumOrderByAggregateInput
  }

  export type ListaPreferenciaScalarWhereWithAggregatesInput = {
    AND?: ListaPreferenciaScalarWhereWithAggregatesInput | ListaPreferenciaScalarWhereWithAggregatesInput[]
    OR?: ListaPreferenciaScalarWhereWithAggregatesInput[]
    NOT?: ListaPreferenciaScalarWhereWithAggregatesInput | ListaPreferenciaScalarWhereWithAggregatesInput[]
    idPessoa?: StringWithAggregatesFilter<"ListaPreferencia"> | string
    posicao?: IntWithAggregatesFilter<"ListaPreferencia"> | number
    valueEquipe?: StringWithAggregatesFilter<"ListaPreferencia"> | string
  }

  export type EquipeEncontroWhereInput = {
    AND?: EquipeEncontroWhereInput | EquipeEncontroWhereInput[]
    OR?: EquipeEncontroWhereInput[]
    NOT?: EquipeEncontroWhereInput | EquipeEncontroWhereInput[]
    idPessoa?: StringFilter<"EquipeEncontro"> | string
    idEncontro?: StringFilter<"EquipeEncontro"> | string
    idEquipe?: StringFilter<"EquipeEncontro"> | string
    coordenou?: BoolFilter<"EquipeEncontro"> | boolean
    fichaPreenchida?: BoolFilter<"EquipeEncontro"> | boolean
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
  }

  export type EquipeEncontroOrderByWithRelationInput = {
    idPessoa?: SortOrder
    idEncontro?: SortOrder
    idEquipe?: SortOrder
    coordenou?: SortOrder
    fichaPreenchida?: SortOrder
    encontro?: EncontroOrderByWithRelationInput
    equipe?: DomainEquipesOrderByWithRelationInput
    encontreiro?: EncontreiroOrderByWithRelationInput
  }

  export type EquipeEncontroWhereUniqueInput = Prisma.AtLeast<{
    idPessoa_idEncontro?: EquipeEncontroIdPessoaIdEncontroCompoundUniqueInput
    AND?: EquipeEncontroWhereInput | EquipeEncontroWhereInput[]
    OR?: EquipeEncontroWhereInput[]
    NOT?: EquipeEncontroWhereInput | EquipeEncontroWhereInput[]
    idPessoa?: StringFilter<"EquipeEncontro"> | string
    idEncontro?: StringFilter<"EquipeEncontro"> | string
    idEquipe?: StringFilter<"EquipeEncontro"> | string
    coordenou?: BoolFilter<"EquipeEncontro"> | boolean
    fichaPreenchida?: BoolFilter<"EquipeEncontro"> | boolean
    encontro?: XOR<EncontroScalarRelationFilter, EncontroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
  }, "idPessoa_idEncontro">

  export type EquipeEncontroOrderByWithAggregationInput = {
    idPessoa?: SortOrder
    idEncontro?: SortOrder
    idEquipe?: SortOrder
    coordenou?: SortOrder
    fichaPreenchida?: SortOrder
    _count?: EquipeEncontroCountOrderByAggregateInput
    _max?: EquipeEncontroMaxOrderByAggregateInput
    _min?: EquipeEncontroMinOrderByAggregateInput
  }

  export type EquipeEncontroScalarWhereWithAggregatesInput = {
    AND?: EquipeEncontroScalarWhereWithAggregatesInput | EquipeEncontroScalarWhereWithAggregatesInput[]
    OR?: EquipeEncontroScalarWhereWithAggregatesInput[]
    NOT?: EquipeEncontroScalarWhereWithAggregatesInput | EquipeEncontroScalarWhereWithAggregatesInput[]
    idPessoa?: StringWithAggregatesFilter<"EquipeEncontro"> | string
    idEncontro?: StringWithAggregatesFilter<"EquipeEncontro"> | string
    idEquipe?: StringWithAggregatesFilter<"EquipeEncontro"> | string
    coordenou?: BoolWithAggregatesFilter<"EquipeEncontro"> | boolean
    fichaPreenchida?: BoolWithAggregatesFilter<"EquipeEncontro"> | boolean
  }

  export type EquipeMontagemWhereInput = {
    AND?: EquipeMontagemWhereInput | EquipeMontagemWhereInput[]
    OR?: EquipeMontagemWhereInput[]
    NOT?: EquipeMontagemWhereInput | EquipeMontagemWhereInput[]
    valueEquipe?: StringFilter<"EquipeMontagem"> | string
    coordenando?: BoolFilter<"EquipeMontagem"> | boolean
    idEncontreiro?: StringFilter<"EquipeMontagem"> | string
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
  }

  export type EquipeMontagemOrderByWithRelationInput = {
    valueEquipe?: SortOrder
    coordenando?: SortOrder
    idEncontreiro?: SortOrder
    encontreiro?: EncontreiroOrderByWithRelationInput
    equipe?: DomainEquipesOrderByWithRelationInput
  }

  export type EquipeMontagemWhereUniqueInput = Prisma.AtLeast<{
    idEncontreiro?: string
    AND?: EquipeMontagemWhereInput | EquipeMontagemWhereInput[]
    OR?: EquipeMontagemWhereInput[]
    NOT?: EquipeMontagemWhereInput | EquipeMontagemWhereInput[]
    valueEquipe?: StringFilter<"EquipeMontagem"> | string
    coordenando?: BoolFilter<"EquipeMontagem"> | boolean
    encontreiro?: XOR<EncontreiroScalarRelationFilter, EncontreiroWhereInput>
    equipe?: XOR<DomainEquipesScalarRelationFilter, DomainEquipesWhereInput>
  }, "idEncontreiro">

  export type EquipeMontagemOrderByWithAggregationInput = {
    valueEquipe?: SortOrder
    coordenando?: SortOrder
    idEncontreiro?: SortOrder
    _count?: EquipeMontagemCountOrderByAggregateInput
    _max?: EquipeMontagemMaxOrderByAggregateInput
    _min?: EquipeMontagemMinOrderByAggregateInput
  }

  export type EquipeMontagemScalarWhereWithAggregatesInput = {
    AND?: EquipeMontagemScalarWhereWithAggregatesInput | EquipeMontagemScalarWhereWithAggregatesInput[]
    OR?: EquipeMontagemScalarWhereWithAggregatesInput[]
    NOT?: EquipeMontagemScalarWhereWithAggregatesInput | EquipeMontagemScalarWhereWithAggregatesInput[]
    valueEquipe?: StringWithAggregatesFilter<"EquipeMontagem"> | string
    coordenando?: BoolWithAggregatesFilter<"EquipeMontagem"> | boolean
    idEncontreiro?: StringWithAggregatesFilter<"EquipeMontagem"> | string
  }

  export type DomainStatusWhereInput = {
    AND?: DomainStatusWhereInput | DomainStatusWhereInput[]
    OR?: DomainStatusWhereInput[]
    NOT?: DomainStatusWhereInput | DomainStatusWhereInput[]
    id?: EnumValue_StatusFilter<"DomainStatus"> | $Enums.Value_Status
    status?: StringFilter<"DomainStatus"> | string
    encontrista?: EncontristaListRelationFilter
  }

  export type DomainStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    encontrista?: EncontristaOrderByRelationAggregateInput
  }

  export type DomainStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_Status
    status?: string
    AND?: DomainStatusWhereInput | DomainStatusWhereInput[]
    OR?: DomainStatusWhereInput[]
    NOT?: DomainStatusWhereInput | DomainStatusWhereInput[]
    encontrista?: EncontristaListRelationFilter
  }, "id" | "id" | "status">

  export type DomainStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: DomainStatusCountOrderByAggregateInput
    _max?: DomainStatusMaxOrderByAggregateInput
    _min?: DomainStatusMinOrderByAggregateInput
  }

  export type DomainStatusScalarWhereWithAggregatesInput = {
    AND?: DomainStatusScalarWhereWithAggregatesInput | DomainStatusScalarWhereWithAggregatesInput[]
    OR?: DomainStatusScalarWhereWithAggregatesInput[]
    NOT?: DomainStatusScalarWhereWithAggregatesInput | DomainStatusScalarWhereWithAggregatesInput[]
    id?: EnumValue_StatusWithAggregatesFilter<"DomainStatus"> | $Enums.Value_Status
    status?: StringWithAggregatesFilter<"DomainStatus"> | string
  }

  export type DomainReligiaoWhereInput = {
    AND?: DomainReligiaoWhereInput | DomainReligiaoWhereInput[]
    OR?: DomainReligiaoWhereInput[]
    NOT?: DomainReligiaoWhereInput | DomainReligiaoWhereInput[]
    id?: EnumValue_ReligiaoFilter<"DomainReligiao"> | $Enums.Value_Religiao
    religiao?: StringFilter<"DomainReligiao"> | string
    encontrista?: EncontristaListRelationFilter
  }

  export type DomainReligiaoOrderByWithRelationInput = {
    id?: SortOrder
    religiao?: SortOrder
    encontrista?: EncontristaOrderByRelationAggregateInput
  }

  export type DomainReligiaoWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_Religiao
    religiao?: string
    AND?: DomainReligiaoWhereInput | DomainReligiaoWhereInput[]
    OR?: DomainReligiaoWhereInput[]
    NOT?: DomainReligiaoWhereInput | DomainReligiaoWhereInput[]
    encontrista?: EncontristaListRelationFilter
  }, "id" | "id" | "religiao">

  export type DomainReligiaoOrderByWithAggregationInput = {
    id?: SortOrder
    religiao?: SortOrder
    _count?: DomainReligiaoCountOrderByAggregateInput
    _max?: DomainReligiaoMaxOrderByAggregateInput
    _min?: DomainReligiaoMinOrderByAggregateInput
  }

  export type DomainReligiaoScalarWhereWithAggregatesInput = {
    AND?: DomainReligiaoScalarWhereWithAggregatesInput | DomainReligiaoScalarWhereWithAggregatesInput[]
    OR?: DomainReligiaoScalarWhereWithAggregatesInput[]
    NOT?: DomainReligiaoScalarWhereWithAggregatesInput | DomainReligiaoScalarWhereWithAggregatesInput[]
    id?: EnumValue_ReligiaoWithAggregatesFilter<"DomainReligiao"> | $Enums.Value_Religiao
    religiao?: StringWithAggregatesFilter<"DomainReligiao"> | string
  }

  export type DomainBairroEncontroWhereInput = {
    AND?: DomainBairroEncontroWhereInput | DomainBairroEncontroWhereInput[]
    OR?: DomainBairroEncontroWhereInput[]
    NOT?: DomainBairroEncontroWhereInput | DomainBairroEncontroWhereInput[]
    id?: IntFilter<"DomainBairroEncontro"> | number
    value?: StringFilter<"DomainBairroEncontro"> | string
    bairro?: StringFilter<"DomainBairroEncontro"> | string
    zona?: StringFilter<"DomainBairroEncontro"> | string
  }

  export type DomainBairroEncontroOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    bairro?: SortOrder
    zona?: SortOrder
  }

  export type DomainBairroEncontroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    bairro?: string
    AND?: DomainBairroEncontroWhereInput | DomainBairroEncontroWhereInput[]
    OR?: DomainBairroEncontroWhereInput[]
    NOT?: DomainBairroEncontroWhereInput | DomainBairroEncontroWhereInput[]
    zona?: StringFilter<"DomainBairroEncontro"> | string
  }, "id" | "value" | "bairro">

  export type DomainBairroEncontroOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    bairro?: SortOrder
    zona?: SortOrder
    _count?: DomainBairroEncontroCountOrderByAggregateInput
    _avg?: DomainBairroEncontroAvgOrderByAggregateInput
    _max?: DomainBairroEncontroMaxOrderByAggregateInput
    _min?: DomainBairroEncontroMinOrderByAggregateInput
    _sum?: DomainBairroEncontroSumOrderByAggregateInput
  }

  export type DomainBairroEncontroScalarWhereWithAggregatesInput = {
    AND?: DomainBairroEncontroScalarWhereWithAggregatesInput | DomainBairroEncontroScalarWhereWithAggregatesInput[]
    OR?: DomainBairroEncontroScalarWhereWithAggregatesInput[]
    NOT?: DomainBairroEncontroScalarWhereWithAggregatesInput | DomainBairroEncontroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DomainBairroEncontro"> | number
    value?: StringWithAggregatesFilter<"DomainBairroEncontro"> | string
    bairro?: StringWithAggregatesFilter<"DomainBairroEncontro"> | string
    zona?: StringWithAggregatesFilter<"DomainBairroEncontro"> | string
  }

  export type DomainMoraComWhereInput = {
    AND?: DomainMoraComWhereInput | DomainMoraComWhereInput[]
    OR?: DomainMoraComWhereInput[]
    NOT?: DomainMoraComWhereInput | DomainMoraComWhereInput[]
    id?: EnumValue_MoraComFilter<"DomainMoraCom"> | $Enums.Value_MoraCom
    moraCom?: StringFilter<"DomainMoraCom"> | string
    encontrista?: EncontristaListRelationFilter
  }

  export type DomainMoraComOrderByWithRelationInput = {
    id?: SortOrder
    moraCom?: SortOrder
    encontrista?: EncontristaOrderByRelationAggregateInput
  }

  export type DomainMoraComWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_MoraCom
    moraCom?: string
    AND?: DomainMoraComWhereInput | DomainMoraComWhereInput[]
    OR?: DomainMoraComWhereInput[]
    NOT?: DomainMoraComWhereInput | DomainMoraComWhereInput[]
    encontrista?: EncontristaListRelationFilter
  }, "id" | "id" | "moraCom">

  export type DomainMoraComOrderByWithAggregationInput = {
    id?: SortOrder
    moraCom?: SortOrder
    _count?: DomainMoraComCountOrderByAggregateInput
    _max?: DomainMoraComMaxOrderByAggregateInput
    _min?: DomainMoraComMinOrderByAggregateInput
  }

  export type DomainMoraComScalarWhereWithAggregatesInput = {
    AND?: DomainMoraComScalarWhereWithAggregatesInput | DomainMoraComScalarWhereWithAggregatesInput[]
    OR?: DomainMoraComScalarWhereWithAggregatesInput[]
    NOT?: DomainMoraComScalarWhereWithAggregatesInput | DomainMoraComScalarWhereWithAggregatesInput[]
    id?: EnumValue_MoraComWithAggregatesFilter<"DomainMoraCom"> | $Enums.Value_MoraCom
    moraCom?: StringWithAggregatesFilter<"DomainMoraCom"> | string
  }

  export type DomainStatusPaisWhereInput = {
    AND?: DomainStatusPaisWhereInput | DomainStatusPaisWhereInput[]
    OR?: DomainStatusPaisWhereInput[]
    NOT?: DomainStatusPaisWhereInput | DomainStatusPaisWhereInput[]
    id?: EnumValue_StatusPaisFilter<"DomainStatusPais"> | $Enums.Value_StatusPais
    statusPais?: StringFilter<"DomainStatusPais"> | string
    encontrista?: EncontristaListRelationFilter
  }

  export type DomainStatusPaisOrderByWithRelationInput = {
    id?: SortOrder
    statusPais?: SortOrder
    encontrista?: EncontristaOrderByRelationAggregateInput
  }

  export type DomainStatusPaisWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_StatusPais
    statusPais?: string
    AND?: DomainStatusPaisWhereInput | DomainStatusPaisWhereInput[]
    OR?: DomainStatusPaisWhereInput[]
    NOT?: DomainStatusPaisWhereInput | DomainStatusPaisWhereInput[]
    encontrista?: EncontristaListRelationFilter
  }, "id" | "id" | "statusPais">

  export type DomainStatusPaisOrderByWithAggregationInput = {
    id?: SortOrder
    statusPais?: SortOrder
    _count?: DomainStatusPaisCountOrderByAggregateInput
    _max?: DomainStatusPaisMaxOrderByAggregateInput
    _min?: DomainStatusPaisMinOrderByAggregateInput
  }

  export type DomainStatusPaisScalarWhereWithAggregatesInput = {
    AND?: DomainStatusPaisScalarWhereWithAggregatesInput | DomainStatusPaisScalarWhereWithAggregatesInput[]
    OR?: DomainStatusPaisScalarWhereWithAggregatesInput[]
    NOT?: DomainStatusPaisScalarWhereWithAggregatesInput | DomainStatusPaisScalarWhereWithAggregatesInput[]
    id?: EnumValue_StatusPaisWithAggregatesFilter<"DomainStatusPais"> | $Enums.Value_StatusPais
    statusPais?: StringWithAggregatesFilter<"DomainStatusPais"> | string
  }

  export type DomainTamanhoCamisaWhereInput = {
    AND?: DomainTamanhoCamisaWhereInput | DomainTamanhoCamisaWhereInput[]
    OR?: DomainTamanhoCamisaWhereInput[]
    NOT?: DomainTamanhoCamisaWhereInput | DomainTamanhoCamisaWhereInput[]
    id?: EnumValue_TamanhoCamisaFilter<"DomainTamanhoCamisa"> | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFilter<"DomainTamanhoCamisa"> | string
    encontreiro?: EncontreiroListRelationFilter
  }

  export type DomainTamanhoCamisaOrderByWithRelationInput = {
    id?: SortOrder
    tamanhoCamisa?: SortOrder
    encontreiro?: EncontreiroOrderByRelationAggregateInput
  }

  export type DomainTamanhoCamisaWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: string
    AND?: DomainTamanhoCamisaWhereInput | DomainTamanhoCamisaWhereInput[]
    OR?: DomainTamanhoCamisaWhereInput[]
    NOT?: DomainTamanhoCamisaWhereInput | DomainTamanhoCamisaWhereInput[]
    encontreiro?: EncontreiroListRelationFilter
  }, "id" | "id" | "tamanhoCamisa">

  export type DomainTamanhoCamisaOrderByWithAggregationInput = {
    id?: SortOrder
    tamanhoCamisa?: SortOrder
    _count?: DomainTamanhoCamisaCountOrderByAggregateInput
    _max?: DomainTamanhoCamisaMaxOrderByAggregateInput
    _min?: DomainTamanhoCamisaMinOrderByAggregateInput
  }

  export type DomainTamanhoCamisaScalarWhereWithAggregatesInput = {
    AND?: DomainTamanhoCamisaScalarWhereWithAggregatesInput | DomainTamanhoCamisaScalarWhereWithAggregatesInput[]
    OR?: DomainTamanhoCamisaScalarWhereWithAggregatesInput[]
    NOT?: DomainTamanhoCamisaScalarWhereWithAggregatesInput | DomainTamanhoCamisaScalarWhereWithAggregatesInput[]
    id?: EnumValue_TamanhoCamisaWithAggregatesFilter<"DomainTamanhoCamisa"> | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringWithAggregatesFilter<"DomainTamanhoCamisa"> | string
  }

  export type DomainCorCirculoWhereInput = {
    AND?: DomainCorCirculoWhereInput | DomainCorCirculoWhereInput[]
    OR?: DomainCorCirculoWhereInput[]
    NOT?: DomainCorCirculoWhereInput | DomainCorCirculoWhereInput[]
    id?: IntFilter<"DomainCorCirculo"> | number
    cor?: StringFilter<"DomainCorCirculo"> | string
    circulo?: CirculoListRelationFilter
  }

  export type DomainCorCirculoOrderByWithRelationInput = {
    id?: SortOrder
    cor?: SortOrder
    circulo?: CirculoOrderByRelationAggregateInput
  }

  export type DomainCorCirculoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cor?: string
    AND?: DomainCorCirculoWhereInput | DomainCorCirculoWhereInput[]
    OR?: DomainCorCirculoWhereInput[]
    NOT?: DomainCorCirculoWhereInput | DomainCorCirculoWhereInput[]
    circulo?: CirculoListRelationFilter
  }, "id" | "cor">

  export type DomainCorCirculoOrderByWithAggregationInput = {
    id?: SortOrder
    cor?: SortOrder
    _count?: DomainCorCirculoCountOrderByAggregateInput
    _avg?: DomainCorCirculoAvgOrderByAggregateInput
    _max?: DomainCorCirculoMaxOrderByAggregateInput
    _min?: DomainCorCirculoMinOrderByAggregateInput
    _sum?: DomainCorCirculoSumOrderByAggregateInput
  }

  export type DomainCorCirculoScalarWhereWithAggregatesInput = {
    AND?: DomainCorCirculoScalarWhereWithAggregatesInput | DomainCorCirculoScalarWhereWithAggregatesInput[]
    OR?: DomainCorCirculoScalarWhereWithAggregatesInput[]
    NOT?: DomainCorCirculoScalarWhereWithAggregatesInput | DomainCorCirculoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DomainCorCirculo"> | number
    cor?: StringWithAggregatesFilter<"DomainCorCirculo"> | string
  }

  export type DomainDisponibilidadeWhereInput = {
    AND?: DomainDisponibilidadeWhereInput | DomainDisponibilidadeWhereInput[]
    OR?: DomainDisponibilidadeWhereInput[]
    NOT?: DomainDisponibilidadeWhereInput | DomainDisponibilidadeWhereInput[]
    id?: EnumValue_DisponibilidadeFilter<"DomainDisponibilidade"> | $Enums.Value_Disponibilidade
    order?: IntFilter<"DomainDisponibilidade"> | number
    disponibilidade?: StringFilter<"DomainDisponibilidade"> | string
    descricao?: StringFilter<"DomainDisponibilidade"> | string
    encontreiro?: EncontreiroListRelationFilter
  }

  export type DomainDisponibilidadeOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    disponibilidade?: SortOrder
    descricao?: SortOrder
    encontreiro?: EncontreiroOrderByRelationAggregateInput
  }

  export type DomainDisponibilidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: $Enums.Value_Disponibilidade
    disponibilidade?: string
    AND?: DomainDisponibilidadeWhereInput | DomainDisponibilidadeWhereInput[]
    OR?: DomainDisponibilidadeWhereInput[]
    NOT?: DomainDisponibilidadeWhereInput | DomainDisponibilidadeWhereInput[]
    order?: IntFilter<"DomainDisponibilidade"> | number
    descricao?: StringFilter<"DomainDisponibilidade"> | string
    encontreiro?: EncontreiroListRelationFilter
  }, "id" | "id" | "disponibilidade">

  export type DomainDisponibilidadeOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    disponibilidade?: SortOrder
    descricao?: SortOrder
    _count?: DomainDisponibilidadeCountOrderByAggregateInput
    _avg?: DomainDisponibilidadeAvgOrderByAggregateInput
    _max?: DomainDisponibilidadeMaxOrderByAggregateInput
    _min?: DomainDisponibilidadeMinOrderByAggregateInput
    _sum?: DomainDisponibilidadeSumOrderByAggregateInput
  }

  export type DomainDisponibilidadeScalarWhereWithAggregatesInput = {
    AND?: DomainDisponibilidadeScalarWhereWithAggregatesInput | DomainDisponibilidadeScalarWhereWithAggregatesInput[]
    OR?: DomainDisponibilidadeScalarWhereWithAggregatesInput[]
    NOT?: DomainDisponibilidadeScalarWhereWithAggregatesInput | DomainDisponibilidadeScalarWhereWithAggregatesInput[]
    id?: EnumValue_DisponibilidadeWithAggregatesFilter<"DomainDisponibilidade"> | $Enums.Value_Disponibilidade
    order?: IntWithAggregatesFilter<"DomainDisponibilidade"> | number
    disponibilidade?: StringWithAggregatesFilter<"DomainDisponibilidade"> | string
    descricao?: StringWithAggregatesFilter<"DomainDisponibilidade"> | string
  }

  export type DomainEquipesWhereInput = {
    AND?: DomainEquipesWhereInput | DomainEquipesWhereInput[]
    OR?: DomainEquipesWhereInput[]
    NOT?: DomainEquipesWhereInput | DomainEquipesWhereInput[]
    equipeLabel?: StringFilter<"DomainEquipes"> | string
    equipeValue?: StringFilter<"DomainEquipes"> | string
    pastaUrl?: StringNullableFilter<"DomainEquipes"> | string | null
    EquipeEncontro?: EquipeEncontroListRelationFilter
    EquipeMontagem?: EquipeMontagemListRelationFilter
    ListaPreferencia?: ListaPreferenciaListRelationFilter
  }

  export type DomainEquipesOrderByWithRelationInput = {
    equipeLabel?: SortOrder
    equipeValue?: SortOrder
    pastaUrl?: SortOrderInput | SortOrder
    EquipeEncontro?: EquipeEncontroOrderByRelationAggregateInput
    EquipeMontagem?: EquipeMontagemOrderByRelationAggregateInput
    ListaPreferencia?: ListaPreferenciaOrderByRelationAggregateInput
  }

  export type DomainEquipesWhereUniqueInput = Prisma.AtLeast<{
    equipeLabel?: string
    equipeValue?: string
    AND?: DomainEquipesWhereInput | DomainEquipesWhereInput[]
    OR?: DomainEquipesWhereInput[]
    NOT?: DomainEquipesWhereInput | DomainEquipesWhereInput[]
    pastaUrl?: StringNullableFilter<"DomainEquipes"> | string | null
    EquipeEncontro?: EquipeEncontroListRelationFilter
    EquipeMontagem?: EquipeMontagemListRelationFilter
    ListaPreferencia?: ListaPreferenciaListRelationFilter
  }, "equipeValue" | "equipeLabel">

  export type DomainEquipesOrderByWithAggregationInput = {
    equipeLabel?: SortOrder
    equipeValue?: SortOrder
    pastaUrl?: SortOrderInput | SortOrder
    _count?: DomainEquipesCountOrderByAggregateInput
    _max?: DomainEquipesMaxOrderByAggregateInput
    _min?: DomainEquipesMinOrderByAggregateInput
  }

  export type DomainEquipesScalarWhereWithAggregatesInput = {
    AND?: DomainEquipesScalarWhereWithAggregatesInput | DomainEquipesScalarWhereWithAggregatesInput[]
    OR?: DomainEquipesScalarWhereWithAggregatesInput[]
    NOT?: DomainEquipesScalarWhereWithAggregatesInput | DomainEquipesScalarWhereWithAggregatesInput[]
    equipeLabel?: StringWithAggregatesFilter<"DomainEquipes"> | string
    equipeValue?: StringWithAggregatesFilter<"DomainEquipes"> | string
    pastaUrl?: StringNullableWithAggregatesFilter<"DomainEquipes"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    sessionState?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: PessoaOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    sessionState?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expiresAt?: IntNullableWithAggregatesFilter<"Account"> | number | null
    tokenType?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    sessionState?: StringNullableWithAggregatesFilter<"Account"> | string | null
    userId?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    sessionToken?: SortOrder
    expires?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: PessoaOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expires?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<PessoaScalarRelationFilter, PessoaWhereInput>
  }, "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    sessionToken?: SortOrder
    expires?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type PessoaCreateInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaCreateManyInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
  }

  export type PessoaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type EncontristaCreateInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUpdateInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaCreateManyInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateManyMutationInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontristaUncheckedUpdateManyInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontreiroCreateInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUpdateInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroCreateManyInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroUpdateManyMutationInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type EncontreiroUncheckedUpdateManyInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type EncontroCreateInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroCreateManyInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
  }

  export type EncontroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CirculoCreateInput = {
    id?: string
    nome?: string | null
    corCirculo: DomainCorCirculoCreateNestedOneWithoutCirculoInput
    encontro: EncontroCreateNestedOneWithoutCirculoInput
    tioAparente?: PessoaCreateNestedOneWithoutTioAparenteCirculoInput
    tioSecreto?: PessoaCreateNestedOneWithoutTioSecretoCirculoInput
    encontreiro?: EncontreiroCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUncheckedCreateInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    corCirculo?: DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCirculoNestedInput
    tioAparente?: PessoaUpdateOneWithoutTioAparenteCirculoNestedInput
    tioSecreto?: PessoaUpdateOneWithoutTioSecretoCirculoNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoCreateManyInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
  }

  export type CirculoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CirculoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnderecoCreateInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaCreateNestedManyWithoutEnderecoEncontroInput
    local?: LocalCreateNestedManyWithoutEnderecoInput
    pessoa?: PessoaCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaUncheckedCreateNestedManyWithoutEnderecoEncontroInput
    local?: LocalUncheckedCreateNestedManyWithoutEnderecoInput
    pessoa?: PessoaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUpdateInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUpdateManyWithoutEnderecoEncontroNestedInput
    local?: LocalUpdateManyWithoutEnderecoNestedInput
    pessoa?: PessoaUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUncheckedUpdateManyWithoutEnderecoEncontroNestedInput
    local?: LocalUncheckedUpdateManyWithoutEnderecoNestedInput
    pessoa?: PessoaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoCreateManyInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
  }

  export type EnderecoUpdateManyMutationInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnderecoUncheckedUpdateManyInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalCreateInput = {
    id?: string
    nomeLocal: string
    numeroLocal: string
    encontro?: EncontroCreateNestedManyWithoutLocalInput
    endereco: EnderecoCreateNestedOneWithoutLocalInput
  }

  export type LocalUncheckedCreateInput = {
    id?: string
    enderecoCep: string
    nomeLocal: string
    numeroLocal: string
    encontro?: EncontroUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
    encontro?: EncontroUpdateManyWithoutLocalNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
    encontro?: EncontroUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type LocalCreateManyInput = {
    id?: string
    enderecoCep: string
    nomeLocal: string
    numeroLocal: string
  }

  export type LocalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
  }

  export type LocalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
  }

  export type CarroCreateInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    carroEncontro?: CarroEncontroCreateNestedManyWithoutCarroInput
    pessoaCarona?: PessoaCreateNestedOneWithoutPessoaCaronaInput
    pessoaMotorista: PessoaCreateNestedOneWithoutPessoaMotoristaInput
  }

  export type CarroUncheckedCreateInput = {
    id?: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona?: string | null
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutCarroInput
  }

  export type CarroUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    carroEncontro?: CarroEncontroUpdateManyWithoutCarroNestedInput
    pessoaCarona?: PessoaUpdateOneWithoutPessoaCaronaNestedInput
    pessoaMotorista?: PessoaUpdateOneRequiredWithoutPessoaMotoristaNestedInput
  }

  export type CarroUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idMotorista?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    idCarona?: NullableStringFieldUpdateOperationsInput | string | null
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutCarroNestedInput
  }

  export type CarroCreateManyInput = {
    id?: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona?: string | null
  }

  export type CarroUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
  }

  export type CarroUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idMotorista?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    idCarona?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarroEncontroCreateInput = {
    numeroCarro: number
    id?: string
    observacao?: string | null
    externa?: EncontreiroCreateNestedOneWithoutResponsavelCarroExternaInput
    carro: CarroCreateNestedOneWithoutCarroEncontroInput
    encontro: EncontroCreateNestedOneWithoutCarroEncontroInput
    encontrista?: EncontristaCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroUncheckedCreateInput = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroUpdateInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    externa?: EncontreiroUpdateOneWithoutResponsavelCarroExternaNestedInput
    carro?: CarroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontrista?: EncontristaUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    encontrista?: EncontristaUncheckedUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroCreateManyInput = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
  }

  export type CarroEncontroUpdateManyMutationInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CarroEncontroUncheckedUpdateManyInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponsavelExternaCreateInput = {
    encontrista: EncontristaCreateNestedOneWithoutResponsavelExternaInput
    encontro: EncontroCreateNestedOneWithoutResponsavelExternaInput
    externa: EncontreiroCreateNestedOneWithoutResponsavelExternaInput
  }

  export type ResponsavelExternaUncheckedCreateInput = {
    idExterna: string
    idEncontrista: string
    idEncontro: string
  }

  export type ResponsavelExternaUpdateInput = {
    encontrista?: EncontristaUpdateOneRequiredWithoutResponsavelExternaNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutResponsavelExternaNestedInput
    externa?: EncontreiroUpdateOneRequiredWithoutResponsavelExternaNestedInput
  }

  export type ResponsavelExternaUncheckedUpdateInput = {
    idExterna?: StringFieldUpdateOperationsInput | string
    idEncontrista?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
  }

  export type ResponsavelExternaCreateManyInput = {
    idExterna: string
    idEncontrista: string
    idEncontro: string
  }

  export type ResponsavelExternaUpdateManyMutationInput = {

  }

  export type ResponsavelExternaUncheckedUpdateManyInput = {
    idExterna?: StringFieldUpdateOperationsInput | string
    idEncontrista?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
  }

  export type CartaCreateInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    isPrinted?: boolean
    pessoa: PessoaCreateNestedOneWithoutCartasDigitaisInput
  }

  export type CartaUncheckedCreateInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    slugEncontrista: string
    isPrinted?: boolean
  }

  export type CartaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
    pessoa?: PessoaUpdateOneRequiredWithoutCartasDigitaisNestedInput
  }

  export type CartaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slugEncontrista?: StringFieldUpdateOperationsInput | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartaCreateManyInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    slugEncontrista: string
    isPrinted?: boolean
  }

  export type CartaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slugEncontrista?: StringFieldUpdateOperationsInput | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListaPreferenciaCreateInput = {
    posicao: number
    encontreiro: EncontreiroCreateNestedOneWithoutListaPreferenciasInput
    equipe: DomainEquipesCreateNestedOneWithoutListaPreferenciaInput
  }

  export type ListaPreferenciaUncheckedCreateInput = {
    idPessoa: string
    posicao: number
    valueEquipe: string
  }

  export type ListaPreferenciaUpdateInput = {
    posicao?: IntFieldUpdateOperationsInput | number
    encontreiro?: EncontreiroUpdateOneRequiredWithoutListaPreferenciasNestedInput
    equipe?: DomainEquipesUpdateOneRequiredWithoutListaPreferenciaNestedInput
  }

  export type ListaPreferenciaUncheckedUpdateInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    posicao?: IntFieldUpdateOperationsInput | number
    valueEquipe?: StringFieldUpdateOperationsInput | string
  }

  export type ListaPreferenciaCreateManyInput = {
    idPessoa: string
    posicao: number
    valueEquipe: string
  }

  export type ListaPreferenciaUpdateManyMutationInput = {
    posicao?: IntFieldUpdateOperationsInput | number
  }

  export type ListaPreferenciaUncheckedUpdateManyInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    posicao?: IntFieldUpdateOperationsInput | number
    valueEquipe?: StringFieldUpdateOperationsInput | string
  }

  export type EquipeEncontroCreateInput = {
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro: EncontroCreateNestedOneWithoutEquipeEncontroInput
    equipe: DomainEquipesCreateNestedOneWithoutEquipeEncontroInput
    encontreiro: EncontreiroCreateNestedOneWithoutEquipeEncontroInput
  }

  export type EquipeEncontroUncheckedCreateInput = {
    idPessoa: string
    idEncontro: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroUpdateInput = {
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
    encontro?: EncontroUpdateOneRequiredWithoutEquipeEncontroNestedInput
    equipe?: DomainEquipesUpdateOneRequiredWithoutEquipeEncontroNestedInput
    encontreiro?: EncontreiroUpdateOneRequiredWithoutEquipeEncontroNestedInput
  }

  export type EquipeEncontroUncheckedUpdateInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeEncontroCreateManyInput = {
    idPessoa: string
    idEncontro: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroUpdateManyMutationInput = {
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeEncontroUncheckedUpdateManyInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeMontagemCreateInput = {
    coordenando: boolean
    encontreiro: EncontreiroCreateNestedOneWithoutEquipeMontagemInput
    equipe: DomainEquipesCreateNestedOneWithoutEquipeMontagemInput
  }

  export type EquipeMontagemUncheckedCreateInput = {
    valueEquipe: string
    coordenando: boolean
    idEncontreiro: string
  }

  export type EquipeMontagemUpdateInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    encontreiro?: EncontreiroUpdateOneRequiredWithoutEquipeMontagemNestedInput
    equipe?: DomainEquipesUpdateOneRequiredWithoutEquipeMontagemNestedInput
  }

  export type EquipeMontagemUncheckedUpdateInput = {
    valueEquipe?: StringFieldUpdateOperationsInput | string
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    idEncontreiro?: StringFieldUpdateOperationsInput | string
  }

  export type EquipeMontagemCreateManyInput = {
    valueEquipe: string
    coordenando: boolean
    idEncontreiro: string
  }

  export type EquipeMontagemUpdateManyMutationInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeMontagemUncheckedUpdateManyInput = {
    valueEquipe?: StringFieldUpdateOperationsInput | string
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    idEncontreiro?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusCreateInput = {
    id: $Enums.Value_Status
    status: string
    encontrista?: EncontristaCreateNestedManyWithoutStatusInput
  }

  export type DomainStatusUncheckedCreateInput = {
    id: $Enums.Value_Status
    status: string
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutStatusInput
  }

  export type DomainStatusUpdateInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUpdateManyWithoutStatusNestedInput
  }

  export type DomainStatusUncheckedUpdateInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type DomainStatusCreateManyInput = {
    id: $Enums.Value_Status
    status: string
  }

  export type DomainStatusUpdateManyMutationInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusUncheckedUpdateManyInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainReligiaoCreateInput = {
    id: $Enums.Value_Religiao
    religiao: string
    encontrista?: EncontristaCreateNestedManyWithoutReligiaoInput
  }

  export type DomainReligiaoUncheckedCreateInput = {
    id: $Enums.Value_Religiao
    religiao: string
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutReligiaoInput
  }

  export type DomainReligiaoUpdateInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUpdateManyWithoutReligiaoNestedInput
  }

  export type DomainReligiaoUncheckedUpdateInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUncheckedUpdateManyWithoutReligiaoNestedInput
  }

  export type DomainReligiaoCreateManyInput = {
    id: $Enums.Value_Religiao
    religiao: string
  }

  export type DomainReligiaoUpdateManyMutationInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainReligiaoUncheckedUpdateManyInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainBairroEncontroCreateInput = {
    id: number
    value: string
    bairro: string
    zona: string
  }

  export type DomainBairroEncontroUncheckedCreateInput = {
    id: number
    value: string
    bairro: string
    zona: string
  }

  export type DomainBairroEncontroUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    zona?: StringFieldUpdateOperationsInput | string
  }

  export type DomainBairroEncontroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    zona?: StringFieldUpdateOperationsInput | string
  }

  export type DomainBairroEncontroCreateManyInput = {
    id: number
    value: string
    bairro: string
    zona: string
  }

  export type DomainBairroEncontroUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    zona?: StringFieldUpdateOperationsInput | string
  }

  export type DomainBairroEncontroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    zona?: StringFieldUpdateOperationsInput | string
  }

  export type DomainMoraComCreateInput = {
    id: $Enums.Value_MoraCom
    moraCom: string
    encontrista?: EncontristaCreateNestedManyWithoutMoraComInput
  }

  export type DomainMoraComUncheckedCreateInput = {
    id: $Enums.Value_MoraCom
    moraCom: string
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutMoraComInput
  }

  export type DomainMoraComUpdateInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUpdateManyWithoutMoraComNestedInput
  }

  export type DomainMoraComUncheckedUpdateInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUncheckedUpdateManyWithoutMoraComNestedInput
  }

  export type DomainMoraComCreateManyInput = {
    id: $Enums.Value_MoraCom
    moraCom: string
  }

  export type DomainMoraComUpdateManyMutationInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
  }

  export type DomainMoraComUncheckedUpdateManyInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusPaisCreateInput = {
    id: $Enums.Value_StatusPais
    statusPais: string
    encontrista?: EncontristaCreateNestedManyWithoutStatusPaisInput
  }

  export type DomainStatusPaisUncheckedCreateInput = {
    id: $Enums.Value_StatusPais
    statusPais: string
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutStatusPaisInput
  }

  export type DomainStatusPaisUpdateInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUpdateManyWithoutStatusPaisNestedInput
  }

  export type DomainStatusPaisUncheckedUpdateInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
    encontrista?: EncontristaUncheckedUpdateManyWithoutStatusPaisNestedInput
  }

  export type DomainStatusPaisCreateManyInput = {
    id: $Enums.Value_StatusPais
    statusPais: string
  }

  export type DomainStatusPaisUpdateManyMutationInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusPaisUncheckedUpdateManyInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
  }

  export type DomainTamanhoCamisaCreateInput = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
    encontreiro?: EncontreiroCreateNestedManyWithoutTamanhoCamisaInput
  }

  export type DomainTamanhoCamisaUncheckedCreateInput = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutTamanhoCamisaInput
  }

  export type DomainTamanhoCamisaUpdateInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
    encontreiro?: EncontreiroUpdateManyWithoutTamanhoCamisaNestedInput
  }

  export type DomainTamanhoCamisaUncheckedUpdateInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutTamanhoCamisaNestedInput
  }

  export type DomainTamanhoCamisaCreateManyInput = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
  }

  export type DomainTamanhoCamisaUpdateManyMutationInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
  }

  export type DomainTamanhoCamisaUncheckedUpdateManyInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
  }

  export type DomainCorCirculoCreateInput = {
    cor: string
    circulo?: CirculoCreateNestedManyWithoutCorCirculoInput
  }

  export type DomainCorCirculoUncheckedCreateInput = {
    id?: number
    cor: string
    circulo?: CirculoUncheckedCreateNestedManyWithoutCorCirculoInput
  }

  export type DomainCorCirculoUpdateInput = {
    cor?: StringFieldUpdateOperationsInput | string
    circulo?: CirculoUpdateManyWithoutCorCirculoNestedInput
  }

  export type DomainCorCirculoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    circulo?: CirculoUncheckedUpdateManyWithoutCorCirculoNestedInput
  }

  export type DomainCorCirculoCreateManyInput = {
    id?: number
    cor: string
  }

  export type DomainCorCirculoUpdateManyMutationInput = {
    cor?: StringFieldUpdateOperationsInput | string
  }

  export type DomainCorCirculoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
  }

  export type DomainDisponibilidadeCreateInput = {
    id: $Enums.Value_Disponibilidade
    order?: number
    disponibilidade: string
    descricao?: string
    encontreiro?: EncontreiroCreateNestedManyWithoutDisponibilidadeInput
  }

  export type DomainDisponibilidadeUncheckedCreateInput = {
    id: $Enums.Value_Disponibilidade
    order?: number
    disponibilidade: string
    descricao?: string
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutDisponibilidadeInput
  }

  export type DomainDisponibilidadeUpdateInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    encontreiro?: EncontreiroUpdateManyWithoutDisponibilidadeNestedInput
  }

  export type DomainDisponibilidadeUncheckedUpdateInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutDisponibilidadeNestedInput
  }

  export type DomainDisponibilidadeCreateManyInput = {
    id: $Enums.Value_Disponibilidade
    order?: number
    disponibilidade: string
    descricao?: string
  }

  export type DomainDisponibilidadeUpdateManyMutationInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainDisponibilidadeUncheckedUpdateManyInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainEquipesCreateInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEquipeInput
    EquipeMontagem?: EquipeMontagemCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesUncheckedCreateInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEquipeInput
    EquipeMontagem?: EquipeMontagemUncheckedCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesUpdateInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEquipeNestedInput
    EquipeMontagem?: EquipeMontagemUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUpdateManyWithoutEquipeNestedInput
  }

  export type DomainEquipesUncheckedUpdateInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEquipeNestedInput
    EquipeMontagem?: EquipeMontagemUncheckedUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type DomainEquipesCreateManyInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
  }

  export type DomainEquipesUpdateManyMutationInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainEquipesUncheckedUpdateManyInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: PessoaCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: PessoaUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: PessoaCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    sessionToken: string
    expires: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: PessoaUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    sessionToken: string
    expires: Date | string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type CarroListRelationFilter = {
    every?: CarroWhereInput
    some?: CarroWhereInput
    none?: CarroWhereInput
  }

  export type CartaListRelationFilter = {
    every?: CartaWhereInput
    some?: CartaWhereInput
    none?: CartaWhereInput
  }

  export type CirculoNullableScalarRelationFilter = {
    is?: CirculoWhereInput | null
    isNot?: CirculoWhereInput | null
  }

  export type EncontreiroNullableScalarRelationFilter = {
    is?: EncontreiroWhereInput | null
    isNot?: EncontreiroWhereInput | null
  }

  export type EncontristaNullableScalarRelationFilter = {
    is?: EncontristaWhereInput | null
    isNot?: EncontristaWhereInput | null
  }

  export type EnderecoScalarRelationFilter = {
    is?: EnderecoWhereInput
    isNot?: EnderecoWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    celular?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    enderecoCep?: SortOrder
    enderecoNumero?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    changePassword?: SortOrder
    apelido?: SortOrder
    role?: SortOrder
    slug?: SortOrder
  }

  export type PessoaAvgOrderByAggregateInput = {
    enderecoNumero?: SortOrder
  }

  export type PessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    celular?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    enderecoCep?: SortOrder
    enderecoNumero?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    changePassword?: SortOrder
    apelido?: SortOrder
    role?: SortOrder
    slug?: SortOrder
  }

  export type PessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    celular?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    enderecoCep?: SortOrder
    enderecoNumero?: SortOrder
    avatarUrl?: SortOrder
    password?: SortOrder
    changePassword?: SortOrder
    apelido?: SortOrder
    role?: SortOrder
    slug?: SortOrder
  }

  export type PessoaSumOrderByAggregateInput = {
    enderecoNumero?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumValue_StatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Status | EnumValue_StatusFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusFilter<$PrismaModel> | $Enums.Value_Status
  }

  export type EnumValue_ReligiaoFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Religiao | EnumValue_ReligiaoFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_ReligiaoFilter<$PrismaModel> | $Enums.Value_Religiao
  }

  export type EnumValue_MoraComFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_MoraCom | EnumValue_MoraComFieldRefInput<$PrismaModel>
    in?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_MoraComFilter<$PrismaModel> | $Enums.Value_MoraCom
  }

  export type EnumValue_StatusPaisFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_StatusPais | EnumValue_StatusPaisFieldRefInput<$PrismaModel>
    in?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusPaisFilter<$PrismaModel> | $Enums.Value_StatusPais
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnderecoNullableScalarRelationFilter = {
    is?: EnderecoWhereInput | null
    isNot?: EnderecoWhereInput | null
  }

  export type CarroEncontroNullableScalarRelationFilter = {
    is?: CarroEncontroWhereInput | null
    isNot?: CarroEncontroWhereInput | null
  }

  export type DomainMoraComScalarRelationFilter = {
    is?: DomainMoraComWhereInput
    isNot?: DomainMoraComWhereInput
  }

  export type PessoaScalarRelationFilter = {
    is?: PessoaWhereInput
    isNot?: PessoaWhereInput
  }

  export type DomainReligiaoScalarRelationFilter = {
    is?: DomainReligiaoWhereInput
    isNot?: DomainReligiaoWhereInput
  }

  export type DomainStatusPaisScalarRelationFilter = {
    is?: DomainStatusPaisWhereInput
    isNot?: DomainStatusPaisWhereInput
  }

  export type DomainStatusScalarRelationFilter = {
    is?: DomainStatusWhereInput
    isNot?: DomainStatusWhereInput
  }

  export type ResponsavelExternaNullableScalarRelationFilter = {
    is?: ResponsavelExternaWhereInput | null
    isNot?: ResponsavelExternaWhereInput | null
  }

  export type EncontristaCountOrderByAggregateInput = {
    idPessoa?: SortOrder
    endComplemento?: SortOrder
    movimentoAnterior?: SortOrder
    observacao?: SortOrder
    nomeContato1?: SortOrder
    telContato1?: SortOrder
    parentescoContato1?: SortOrder
    nomeContato2?: SortOrder
    telContato2?: SortOrder
    parentescoContato2?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    indicadoPorApelido?: SortOrder
    indicadoPorEmail?: SortOrder
    indicadoPorNome?: SortOrder
    indicadoPorTel?: SortOrder
    isAutofill?: SortOrder
    idStatus?: SortOrder
    idReligiao?: SortOrder
    idMoracom?: SortOrder
    idStatusPais?: SortOrder
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    idCarroEncontro?: SortOrder
    cepEncontro?: SortOrder
    endComplementoEncontro?: SortOrder
    endNumEncontro?: SortOrder
    obsExternaConhecidos?: SortOrder
    obsExternaLocalizacao?: SortOrder
    obsExternaOutros?: SortOrder
    obsExternaSaude?: SortOrder
    cartasOk?: SortOrder
    generosaOk?: SortOrder
    familiaOk?: SortOrder
  }

  export type EncontristaAvgOrderByAggregateInput = {
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    endNumEncontro?: SortOrder
  }

  export type EncontristaMaxOrderByAggregateInput = {
    idPessoa?: SortOrder
    endComplemento?: SortOrder
    movimentoAnterior?: SortOrder
    observacao?: SortOrder
    nomeContato1?: SortOrder
    telContato1?: SortOrder
    parentescoContato1?: SortOrder
    nomeContato2?: SortOrder
    telContato2?: SortOrder
    parentescoContato2?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    indicadoPorApelido?: SortOrder
    indicadoPorEmail?: SortOrder
    indicadoPorNome?: SortOrder
    indicadoPorTel?: SortOrder
    isAutofill?: SortOrder
    idStatus?: SortOrder
    idReligiao?: SortOrder
    idMoracom?: SortOrder
    idStatusPais?: SortOrder
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    idCarroEncontro?: SortOrder
    cepEncontro?: SortOrder
    endComplementoEncontro?: SortOrder
    endNumEncontro?: SortOrder
    obsExternaConhecidos?: SortOrder
    obsExternaLocalizacao?: SortOrder
    obsExternaOutros?: SortOrder
    obsExternaSaude?: SortOrder
    cartasOk?: SortOrder
    generosaOk?: SortOrder
    familiaOk?: SortOrder
  }

  export type EncontristaMinOrderByAggregateInput = {
    idPessoa?: SortOrder
    endComplemento?: SortOrder
    movimentoAnterior?: SortOrder
    observacao?: SortOrder
    nomeContato1?: SortOrder
    telContato1?: SortOrder
    parentescoContato1?: SortOrder
    nomeContato2?: SortOrder
    telContato2?: SortOrder
    parentescoContato2?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    indicadoPorApelido?: SortOrder
    indicadoPorEmail?: SortOrder
    indicadoPorNome?: SortOrder
    indicadoPorTel?: SortOrder
    isAutofill?: SortOrder
    idStatus?: SortOrder
    idReligiao?: SortOrder
    idMoracom?: SortOrder
    idStatusPais?: SortOrder
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    idCarroEncontro?: SortOrder
    cepEncontro?: SortOrder
    endComplementoEncontro?: SortOrder
    endNumEncontro?: SortOrder
    obsExternaConhecidos?: SortOrder
    obsExternaLocalizacao?: SortOrder
    obsExternaOutros?: SortOrder
    obsExternaSaude?: SortOrder
    cartasOk?: SortOrder
    generosaOk?: SortOrder
    familiaOk?: SortOrder
  }

  export type EncontristaSumOrderByAggregateInput = {
    endNumero?: SortOrder
    cartasFisicas?: SortOrder
    endNumEncontro?: SortOrder
  }

  export type EnumValue_StatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Status | EnumValue_StatusFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusWithAggregatesFilter<$PrismaModel> | $Enums.Value_Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_StatusFilter<$PrismaModel>
    _max?: NestedEnumValue_StatusFilter<$PrismaModel>
  }

  export type EnumValue_ReligiaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Religiao | EnumValue_ReligiaoFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_ReligiaoWithAggregatesFilter<$PrismaModel> | $Enums.Value_Religiao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_ReligiaoFilter<$PrismaModel>
    _max?: NestedEnumValue_ReligiaoFilter<$PrismaModel>
  }

  export type EnumValue_MoraComWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_MoraCom | EnumValue_MoraComFieldRefInput<$PrismaModel>
    in?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_MoraComWithAggregatesFilter<$PrismaModel> | $Enums.Value_MoraCom
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_MoraComFilter<$PrismaModel>
    _max?: NestedEnumValue_MoraComFilter<$PrismaModel>
  }

  export type EnumValue_StatusPaisWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_StatusPais | EnumValue_StatusPaisFieldRefInput<$PrismaModel>
    in?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusPaisWithAggregatesFilter<$PrismaModel> | $Enums.Value_StatusPais
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_StatusPaisFilter<$PrismaModel>
    _max?: NestedEnumValue_StatusPaisFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumValue_TamanhoCamisaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa | null
  }

  export type EnumValue_DisponibilidadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel> | $Enums.Value_Disponibilidade | null
  }

  export type EnumStatusEncontreiroNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEncontreiro | EnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel> | $Enums.StatusEncontreiro | null
  }

  export type CarroEncontroListRelationFilter = {
    every?: CarroEncontroWhereInput
    some?: CarroEncontroWhereInput
    none?: CarroEncontroWhereInput
  }

  export type EncontroNullableScalarRelationFilter = {
    is?: EncontroWhereInput | null
    isNot?: EncontroWhereInput | null
  }

  export type DomainTamanhoCamisaNullableScalarRelationFilter = {
    is?: DomainTamanhoCamisaWhereInput | null
    isNot?: DomainTamanhoCamisaWhereInput | null
  }

  export type DomainDisponibilidadeNullableScalarRelationFilter = {
    is?: DomainDisponibilidadeWhereInput | null
    isNot?: DomainDisponibilidadeWhereInput | null
  }

  export type EquipeEncontroListRelationFilter = {
    every?: EquipeEncontroWhereInput
    some?: EquipeEncontroWhereInput
    none?: EquipeEncontroWhereInput
  }

  export type EquipeMontagemNullableScalarRelationFilter = {
    is?: EquipeMontagemWhereInput | null
    isNot?: EquipeMontagemWhereInput | null
  }

  export type ListaPreferenciaListRelationFilter = {
    every?: ListaPreferenciaWhereInput
    some?: ListaPreferenciaWhereInput
    none?: ListaPreferenciaWhereInput
  }

  export type ResponsavelExternaListRelationFilter = {
    every?: ResponsavelExternaWhereInput
    some?: ResponsavelExternaWhereInput
    none?: ResponsavelExternaWhereInput
  }

  export type CarroEncontroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipeEncontroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListaPreferenciaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponsavelExternaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncontreiroCountOrderByAggregateInput = {
    idPessoa?: SortOrder
    dataNasc?: SortOrder
    instagram?: SortOrder
    restricaoAlimentar?: SortOrder
    idEncontro?: SortOrder
    idCirculo?: SortOrder
    idTamanhoCamisa?: SortOrder
    idDisponibilidade?: SortOrder
    obsBanda?: SortOrder
    observacoes?: SortOrder
    statusMontagem?: SortOrder
  }

  export type EncontreiroMaxOrderByAggregateInput = {
    idPessoa?: SortOrder
    dataNasc?: SortOrder
    instagram?: SortOrder
    restricaoAlimentar?: SortOrder
    idEncontro?: SortOrder
    idCirculo?: SortOrder
    idTamanhoCamisa?: SortOrder
    idDisponibilidade?: SortOrder
    obsBanda?: SortOrder
    observacoes?: SortOrder
    statusMontagem?: SortOrder
  }

  export type EncontreiroMinOrderByAggregateInput = {
    idPessoa?: SortOrder
    dataNasc?: SortOrder
    instagram?: SortOrder
    restricaoAlimentar?: SortOrder
    idEncontro?: SortOrder
    idCirculo?: SortOrder
    idTamanhoCamisa?: SortOrder
    idDisponibilidade?: SortOrder
    obsBanda?: SortOrder
    observacoes?: SortOrder
    statusMontagem?: SortOrder
  }

  export type EnumValue_TamanhoCamisaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_TamanhoCamisaNullableWithAggregatesFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel>
    _max?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel>
  }

  export type EnumValue_DisponibilidadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_DisponibilidadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Value_Disponibilidade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel>
    _max?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel>
  }

  export type EnumStatusEncontreiroNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEncontreiro | EnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusEncontreiroNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatusEncontreiro | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel>
  }

  export type CirculoListRelationFilter = {
    every?: CirculoWhereInput
    some?: CirculoWhereInput
    none?: CirculoWhereInput
  }

  export type EncontreiroListRelationFilter = {
    every?: EncontreiroWhereInput
    some?: EncontreiroWhereInput
    none?: EncontreiroWhereInput
  }

  export type LocalScalarRelationFilter = {
    is?: LocalWhereInput
    isNot?: LocalWhereInput
  }

  export type CirculoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncontreiroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncontroCountOrderByAggregateInput = {
    id?: SortOrder
    numeroEncontro?: SortOrder
    idLocal?: SortOrder
    temaEspiritual?: SortOrder
    temaFantasia?: SortOrder
    numeroCirculos?: SortOrder
    dataInicio?: SortOrder
    dataTema?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    ordemCirculos?: SortOrder
    isReceivingCartas?: SortOrder
  }

  export type EncontroAvgOrderByAggregateInput = {
    numeroEncontro?: SortOrder
    numeroCirculos?: SortOrder
    ordemCirculos?: SortOrder
  }

  export type EncontroMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroEncontro?: SortOrder
    idLocal?: SortOrder
    temaEspiritual?: SortOrder
    temaFantasia?: SortOrder
    numeroCirculos?: SortOrder
    dataInicio?: SortOrder
    dataTema?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    ordemCirculos?: SortOrder
    isReceivingCartas?: SortOrder
  }

  export type EncontroMinOrderByAggregateInput = {
    id?: SortOrder
    numeroEncontro?: SortOrder
    idLocal?: SortOrder
    temaEspiritual?: SortOrder
    temaFantasia?: SortOrder
    numeroCirculos?: SortOrder
    dataInicio?: SortOrder
    dataTema?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
    ordemCirculos?: SortOrder
    isReceivingCartas?: SortOrder
  }

  export type EncontroSumOrderByAggregateInput = {
    numeroEncontro?: SortOrder
    numeroCirculos?: SortOrder
    ordemCirculos?: SortOrder
  }

  export type DomainCorCirculoScalarRelationFilter = {
    is?: DomainCorCirculoWhereInput
    isNot?: DomainCorCirculoWhereInput
  }

  export type EncontroScalarRelationFilter = {
    is?: EncontroWhereInput
    isNot?: EncontroWhereInput
  }

  export type PessoaNullableScalarRelationFilter = {
    is?: PessoaWhereInput | null
    isNot?: PessoaWhereInput | null
  }

  export type CirculoCountOrderByAggregateInput = {
    id?: SortOrder
    idCorCirculo?: SortOrder
    idTioAparente?: SortOrder
    idTioSecreto?: SortOrder
    idEncontro?: SortOrder
    nome?: SortOrder
  }

  export type CirculoAvgOrderByAggregateInput = {
    idCorCirculo?: SortOrder
  }

  export type CirculoMaxOrderByAggregateInput = {
    id?: SortOrder
    idCorCirculo?: SortOrder
    idTioAparente?: SortOrder
    idTioSecreto?: SortOrder
    idEncontro?: SortOrder
    nome?: SortOrder
  }

  export type CirculoMinOrderByAggregateInput = {
    id?: SortOrder
    idCorCirculo?: SortOrder
    idTioAparente?: SortOrder
    idTioSecreto?: SortOrder
    idEncontro?: SortOrder
    nome?: SortOrder
  }

  export type CirculoSumOrderByAggregateInput = {
    idCorCirculo?: SortOrder
  }

  export type EncontristaListRelationFilter = {
    every?: EncontristaWhereInput
    some?: EncontristaWhereInput
    none?: EncontristaWhereInput
  }

  export type LocalListRelationFilter = {
    every?: LocalWhereInput
    some?: LocalWhereInput
    none?: LocalWhereInput
  }

  export type PessoaListRelationFilter = {
    every?: PessoaWhereInput
    some?: PessoaWhereInput
    none?: PessoaWhereInput
  }

  export type EncontristaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnderecoCountOrderByAggregateInput = {
    cep?: SortOrder
    estado?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    rua?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type EnderecoMaxOrderByAggregateInput = {
    cep?: SortOrder
    estado?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    rua?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type EnderecoMinOrderByAggregateInput = {
    cep?: SortOrder
    estado?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    rua?: SortOrder
    createdAt?: SortOrder
    modifiedAt?: SortOrder
  }

  export type EncontroListRelationFilter = {
    every?: EncontroWhereInput
    some?: EncontroWhereInput
    none?: EncontroWhereInput
  }

  export type EncontroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalCountOrderByAggregateInput = {
    id?: SortOrder
    enderecoCep?: SortOrder
    nomeLocal?: SortOrder
    numeroLocal?: SortOrder
  }

  export type LocalMaxOrderByAggregateInput = {
    id?: SortOrder
    enderecoCep?: SortOrder
    nomeLocal?: SortOrder
    numeroLocal?: SortOrder
  }

  export type LocalMinOrderByAggregateInput = {
    id?: SortOrder
    enderecoCep?: SortOrder
    nomeLocal?: SortOrder
    numeroLocal?: SortOrder
  }

  export type CarroIdMotoristaPlacaCarroCompoundUniqueInput = {
    idMotorista: string
    placaCarro: string
  }

  export type CarroCountOrderByAggregateInput = {
    id?: SortOrder
    idMotorista?: SortOrder
    modeloCarro?: SortOrder
    placaCarro?: SortOrder
    lugaresCarro?: SortOrder
    observacaoMotorista?: SortOrder
    idCarona?: SortOrder
  }

  export type CarroAvgOrderByAggregateInput = {
    lugaresCarro?: SortOrder
  }

  export type CarroMaxOrderByAggregateInput = {
    id?: SortOrder
    idMotorista?: SortOrder
    modeloCarro?: SortOrder
    placaCarro?: SortOrder
    lugaresCarro?: SortOrder
    observacaoMotorista?: SortOrder
    idCarona?: SortOrder
  }

  export type CarroMinOrderByAggregateInput = {
    id?: SortOrder
    idMotorista?: SortOrder
    modeloCarro?: SortOrder
    placaCarro?: SortOrder
    lugaresCarro?: SortOrder
    observacaoMotorista?: SortOrder
    idCarona?: SortOrder
  }

  export type CarroSumOrderByAggregateInput = {
    lugaresCarro?: SortOrder
  }

  export type CarroScalarRelationFilter = {
    is?: CarroWhereInput
    isNot?: CarroWhereInput
  }

  export type CarroEncontroIdCarroIdEncontroCompoundUniqueInput = {
    idCarro: string
    idEncontro: string
  }

  export type CarroEncontroCountOrderByAggregateInput = {
    idCarro?: SortOrder
    idEncontro?: SortOrder
    numeroCarro?: SortOrder
    idExterna?: SortOrder
    id?: SortOrder
    observacao?: SortOrder
  }

  export type CarroEncontroAvgOrderByAggregateInput = {
    numeroCarro?: SortOrder
  }

  export type CarroEncontroMaxOrderByAggregateInput = {
    idCarro?: SortOrder
    idEncontro?: SortOrder
    numeroCarro?: SortOrder
    idExterna?: SortOrder
    id?: SortOrder
    observacao?: SortOrder
  }

  export type CarroEncontroMinOrderByAggregateInput = {
    idCarro?: SortOrder
    idEncontro?: SortOrder
    numeroCarro?: SortOrder
    idExterna?: SortOrder
    id?: SortOrder
    observacao?: SortOrder
  }

  export type CarroEncontroSumOrderByAggregateInput = {
    numeroCarro?: SortOrder
  }

  export type EncontristaScalarRelationFilter = {
    is?: EncontristaWhereInput
    isNot?: EncontristaWhereInput
  }

  export type EncontreiroScalarRelationFilter = {
    is?: EncontreiroWhereInput
    isNot?: EncontreiroWhereInput
  }

  export type ResponsavelExternaIdEncontristaIdEncontroCompoundUniqueInput = {
    idEncontrista: string
    idEncontro: string
  }

  export type ResponsavelExternaCountOrderByAggregateInput = {
    idExterna?: SortOrder
    idEncontrista?: SortOrder
    idEncontro?: SortOrder
  }

  export type ResponsavelExternaMaxOrderByAggregateInput = {
    idExterna?: SortOrder
    idEncontrista?: SortOrder
    idEncontro?: SortOrder
  }

  export type ResponsavelExternaMinOrderByAggregateInput = {
    idExterna?: SortOrder
    idEncontrista?: SortOrder
    idEncontro?: SortOrder
  }

  export type CartaCountOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    de?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    slugEncontrista?: SortOrder
    isPrinted?: SortOrder
  }

  export type CartaMaxOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    de?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    slugEncontrista?: SortOrder
    isPrinted?: SortOrder
  }

  export type CartaMinOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    de?: SortOrder
    conteudo?: SortOrder
    createdAt?: SortOrder
    slugEncontrista?: SortOrder
    isPrinted?: SortOrder
  }

  export type DomainEquipesScalarRelationFilter = {
    is?: DomainEquipesWhereInput
    isNot?: DomainEquipesWhereInput
  }

  export type ListaPreferenciaIdPessoaPosicaoCompoundUniqueInput = {
    idPessoa: string
    posicao: number
  }

  export type ListaPreferenciaCountOrderByAggregateInput = {
    idPessoa?: SortOrder
    posicao?: SortOrder
    valueEquipe?: SortOrder
  }

  export type ListaPreferenciaAvgOrderByAggregateInput = {
    posicao?: SortOrder
  }

  export type ListaPreferenciaMaxOrderByAggregateInput = {
    idPessoa?: SortOrder
    posicao?: SortOrder
    valueEquipe?: SortOrder
  }

  export type ListaPreferenciaMinOrderByAggregateInput = {
    idPessoa?: SortOrder
    posicao?: SortOrder
    valueEquipe?: SortOrder
  }

  export type ListaPreferenciaSumOrderByAggregateInput = {
    posicao?: SortOrder
  }

  export type EquipeEncontroIdPessoaIdEncontroCompoundUniqueInput = {
    idPessoa: string
    idEncontro: string
  }

  export type EquipeEncontroCountOrderByAggregateInput = {
    idPessoa?: SortOrder
    idEncontro?: SortOrder
    idEquipe?: SortOrder
    coordenou?: SortOrder
    fichaPreenchida?: SortOrder
  }

  export type EquipeEncontroMaxOrderByAggregateInput = {
    idPessoa?: SortOrder
    idEncontro?: SortOrder
    idEquipe?: SortOrder
    coordenou?: SortOrder
    fichaPreenchida?: SortOrder
  }

  export type EquipeEncontroMinOrderByAggregateInput = {
    idPessoa?: SortOrder
    idEncontro?: SortOrder
    idEquipe?: SortOrder
    coordenou?: SortOrder
    fichaPreenchida?: SortOrder
  }

  export type EquipeMontagemCountOrderByAggregateInput = {
    valueEquipe?: SortOrder
    coordenando?: SortOrder
    idEncontreiro?: SortOrder
  }

  export type EquipeMontagemMaxOrderByAggregateInput = {
    valueEquipe?: SortOrder
    coordenando?: SortOrder
    idEncontreiro?: SortOrder
  }

  export type EquipeMontagemMinOrderByAggregateInput = {
    valueEquipe?: SortOrder
    coordenando?: SortOrder
    idEncontreiro?: SortOrder
  }

  export type DomainStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type DomainStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type DomainStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type DomainReligiaoCountOrderByAggregateInput = {
    id?: SortOrder
    religiao?: SortOrder
  }

  export type DomainReligiaoMaxOrderByAggregateInput = {
    id?: SortOrder
    religiao?: SortOrder
  }

  export type DomainReligiaoMinOrderByAggregateInput = {
    id?: SortOrder
    religiao?: SortOrder
  }

  export type DomainBairroEncontroCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    bairro?: SortOrder
    zona?: SortOrder
  }

  export type DomainBairroEncontroAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DomainBairroEncontroMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    bairro?: SortOrder
    zona?: SortOrder
  }

  export type DomainBairroEncontroMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    bairro?: SortOrder
    zona?: SortOrder
  }

  export type DomainBairroEncontroSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DomainMoraComCountOrderByAggregateInput = {
    id?: SortOrder
    moraCom?: SortOrder
  }

  export type DomainMoraComMaxOrderByAggregateInput = {
    id?: SortOrder
    moraCom?: SortOrder
  }

  export type DomainMoraComMinOrderByAggregateInput = {
    id?: SortOrder
    moraCom?: SortOrder
  }

  export type DomainStatusPaisCountOrderByAggregateInput = {
    id?: SortOrder
    statusPais?: SortOrder
  }

  export type DomainStatusPaisMaxOrderByAggregateInput = {
    id?: SortOrder
    statusPais?: SortOrder
  }

  export type DomainStatusPaisMinOrderByAggregateInput = {
    id?: SortOrder
    statusPais?: SortOrder
  }

  export type EnumValue_TamanhoCamisaFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa
  }

  export type DomainTamanhoCamisaCountOrderByAggregateInput = {
    id?: SortOrder
    tamanhoCamisa?: SortOrder
  }

  export type DomainTamanhoCamisaMaxOrderByAggregateInput = {
    id?: SortOrder
    tamanhoCamisa?: SortOrder
  }

  export type DomainTamanhoCamisaMinOrderByAggregateInput = {
    id?: SortOrder
    tamanhoCamisa?: SortOrder
  }

  export type EnumValue_TamanhoCamisaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_TamanhoCamisaWithAggregatesFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel>
    _max?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel>
  }

  export type DomainCorCirculoCountOrderByAggregateInput = {
    id?: SortOrder
    cor?: SortOrder
  }

  export type DomainCorCirculoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DomainCorCirculoMaxOrderByAggregateInput = {
    id?: SortOrder
    cor?: SortOrder
  }

  export type DomainCorCirculoMinOrderByAggregateInput = {
    id?: SortOrder
    cor?: SortOrder
  }

  export type DomainCorCirculoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumValue_DisponibilidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel> | $Enums.Value_Disponibilidade
  }

  export type DomainDisponibilidadeCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    disponibilidade?: SortOrder
    descricao?: SortOrder
  }

  export type DomainDisponibilidadeAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DomainDisponibilidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    disponibilidade?: SortOrder
    descricao?: SortOrder
  }

  export type DomainDisponibilidadeMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    disponibilidade?: SortOrder
    descricao?: SortOrder
  }

  export type DomainDisponibilidadeSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumValue_DisponibilidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_DisponibilidadeWithAggregatesFilter<$PrismaModel> | $Enums.Value_Disponibilidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel>
    _max?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel>
  }

  export type EquipeMontagemListRelationFilter = {
    every?: EquipeMontagemWhereInput
    some?: EquipeMontagemWhereInput
    none?: EquipeMontagemWhereInput
  }

  export type EquipeMontagemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainEquipesCountOrderByAggregateInput = {
    equipeLabel?: SortOrder
    equipeValue?: SortOrder
    pastaUrl?: SortOrder
  }

  export type DomainEquipesMaxOrderByAggregateInput = {
    equipeLabel?: SortOrder
    equipeValue?: SortOrder
    pastaUrl?: SortOrder
  }

  export type DomainEquipesMinOrderByAggregateInput = {
    equipeLabel?: SortOrder
    equipeValue?: SortOrder
    pastaUrl?: SortOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refreshToken?: SortOrder
    accessToken?: SortOrder
    expiresAt?: SortOrder
    tokenType?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    sessionState?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    sessionToken?: SortOrder
    expires?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    sessionToken?: SortOrder
    expires?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    sessionToken?: SortOrder
    expires?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CarroCreateNestedManyWithoutPessoaCaronaInput = {
    create?: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput> | CarroCreateWithoutPessoaCaronaInput[] | CarroUncheckedCreateWithoutPessoaCaronaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaCaronaInput | CarroCreateOrConnectWithoutPessoaCaronaInput[]
    createMany?: CarroCreateManyPessoaCaronaInputEnvelope
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
  }

  export type CarroCreateNestedManyWithoutPessoaMotoristaInput = {
    create?: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput> | CarroCreateWithoutPessoaMotoristaInput[] | CarroUncheckedCreateWithoutPessoaMotoristaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaMotoristaInput | CarroCreateOrConnectWithoutPessoaMotoristaInput[]
    createMany?: CarroCreateManyPessoaMotoristaInputEnvelope
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
  }

  export type CartaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput> | CartaCreateWithoutPessoaInput[] | CartaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: CartaCreateOrConnectWithoutPessoaInput | CartaCreateOrConnectWithoutPessoaInput[]
    createMany?: CartaCreateManyPessoaInputEnvelope
    connect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
  }

  export type CirculoCreateNestedOneWithoutTioAparenteInput = {
    create?: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioAparenteInput
    connect?: CirculoWhereUniqueInput
  }

  export type CirculoCreateNestedOneWithoutTioSecretoInput = {
    create?: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioSecretoInput
    connect?: CirculoWhereUniqueInput
  }

  export type EncontreiroCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutPessoaInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type EncontristaCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutPessoaInput
    connect?: EncontristaWhereUniqueInput
  }

  export type EnderecoCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutPessoaInput
    connect?: EnderecoWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput = {
    create?: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput> | CarroCreateWithoutPessoaCaronaInput[] | CarroUncheckedCreateWithoutPessoaCaronaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaCaronaInput | CarroCreateOrConnectWithoutPessoaCaronaInput[]
    createMany?: CarroCreateManyPessoaCaronaInputEnvelope
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
  }

  export type CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput = {
    create?: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput> | CarroCreateWithoutPessoaMotoristaInput[] | CarroUncheckedCreateWithoutPessoaMotoristaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaMotoristaInput | CarroCreateOrConnectWithoutPessoaMotoristaInput[]
    createMany?: CarroCreateManyPessoaMotoristaInputEnvelope
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
  }

  export type CartaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput> | CartaCreateWithoutPessoaInput[] | CartaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: CartaCreateOrConnectWithoutPessoaInput | CartaCreateOrConnectWithoutPessoaInput[]
    createMany?: CartaCreateManyPessoaInputEnvelope
    connect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
  }

  export type CirculoUncheckedCreateNestedOneWithoutTioAparenteInput = {
    create?: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioAparenteInput
    connect?: CirculoWhereUniqueInput
  }

  export type CirculoUncheckedCreateNestedOneWithoutTioSecretoInput = {
    create?: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioSecretoInput
    connect?: CirculoWhereUniqueInput
  }

  export type EncontreiroUncheckedCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutPessoaInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type EncontristaUncheckedCreateNestedOneWithoutPessoaInput = {
    create?: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutPessoaInput
    connect?: EncontristaWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CarroUpdateManyWithoutPessoaCaronaNestedInput = {
    create?: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput> | CarroCreateWithoutPessoaCaronaInput[] | CarroUncheckedCreateWithoutPessoaCaronaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaCaronaInput | CarroCreateOrConnectWithoutPessoaCaronaInput[]
    upsert?: CarroUpsertWithWhereUniqueWithoutPessoaCaronaInput | CarroUpsertWithWhereUniqueWithoutPessoaCaronaInput[]
    createMany?: CarroCreateManyPessoaCaronaInputEnvelope
    set?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    disconnect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    delete?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    update?: CarroUpdateWithWhereUniqueWithoutPessoaCaronaInput | CarroUpdateWithWhereUniqueWithoutPessoaCaronaInput[]
    updateMany?: CarroUpdateManyWithWhereWithoutPessoaCaronaInput | CarroUpdateManyWithWhereWithoutPessoaCaronaInput[]
    deleteMany?: CarroScalarWhereInput | CarroScalarWhereInput[]
  }

  export type CarroUpdateManyWithoutPessoaMotoristaNestedInput = {
    create?: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput> | CarroCreateWithoutPessoaMotoristaInput[] | CarroUncheckedCreateWithoutPessoaMotoristaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaMotoristaInput | CarroCreateOrConnectWithoutPessoaMotoristaInput[]
    upsert?: CarroUpsertWithWhereUniqueWithoutPessoaMotoristaInput | CarroUpsertWithWhereUniqueWithoutPessoaMotoristaInput[]
    createMany?: CarroCreateManyPessoaMotoristaInputEnvelope
    set?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    disconnect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    delete?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    update?: CarroUpdateWithWhereUniqueWithoutPessoaMotoristaInput | CarroUpdateWithWhereUniqueWithoutPessoaMotoristaInput[]
    updateMany?: CarroUpdateManyWithWhereWithoutPessoaMotoristaInput | CarroUpdateManyWithWhereWithoutPessoaMotoristaInput[]
    deleteMany?: CarroScalarWhereInput | CarroScalarWhereInput[]
  }

  export type CartaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput> | CartaCreateWithoutPessoaInput[] | CartaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: CartaCreateOrConnectWithoutPessoaInput | CartaCreateOrConnectWithoutPessoaInput[]
    upsert?: CartaUpsertWithWhereUniqueWithoutPessoaInput | CartaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: CartaCreateManyPessoaInputEnvelope
    set?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    disconnect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    delete?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    connect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    update?: CartaUpdateWithWhereUniqueWithoutPessoaInput | CartaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: CartaUpdateManyWithWhereWithoutPessoaInput | CartaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: CartaScalarWhereInput | CartaScalarWhereInput[]
  }

  export type CirculoUpdateOneWithoutTioAparenteNestedInput = {
    create?: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioAparenteInput
    upsert?: CirculoUpsertWithoutTioAparenteInput
    disconnect?: CirculoWhereInput | boolean
    delete?: CirculoWhereInput | boolean
    connect?: CirculoWhereUniqueInput
    update?: XOR<XOR<CirculoUpdateToOneWithWhereWithoutTioAparenteInput, CirculoUpdateWithoutTioAparenteInput>, CirculoUncheckedUpdateWithoutTioAparenteInput>
  }

  export type CirculoUpdateOneWithoutTioSecretoNestedInput = {
    create?: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioSecretoInput
    upsert?: CirculoUpsertWithoutTioSecretoInput
    disconnect?: CirculoWhereInput | boolean
    delete?: CirculoWhereInput | boolean
    connect?: CirculoWhereUniqueInput
    update?: XOR<XOR<CirculoUpdateToOneWithWhereWithoutTioSecretoInput, CirculoUpdateWithoutTioSecretoInput>, CirculoUncheckedUpdateWithoutTioSecretoInput>
  }

  export type EncontreiroUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutPessoaInput
    upsert?: EncontreiroUpsertWithoutPessoaInput
    disconnect?: EncontreiroWhereInput | boolean
    delete?: EncontreiroWhereInput | boolean
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutPessoaInput, EncontreiroUpdateWithoutPessoaInput>, EncontreiroUncheckedUpdateWithoutPessoaInput>
  }

  export type EncontristaUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutPessoaInput
    upsert?: EncontristaUpsertWithoutPessoaInput
    disconnect?: EncontristaWhereInput | boolean
    delete?: EncontristaWhereInput | boolean
    connect?: EncontristaWhereUniqueInput
    update?: XOR<XOR<EncontristaUpdateToOneWithWhereWithoutPessoaInput, EncontristaUpdateWithoutPessoaInput>, EncontristaUncheckedUpdateWithoutPessoaInput>
  }

  export type EnderecoUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutPessoaInput
    upsert?: EnderecoUpsertWithoutPessoaInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutPessoaInput, EnderecoUpdateWithoutPessoaInput>, EnderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput = {
    create?: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput> | CarroCreateWithoutPessoaCaronaInput[] | CarroUncheckedCreateWithoutPessoaCaronaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaCaronaInput | CarroCreateOrConnectWithoutPessoaCaronaInput[]
    upsert?: CarroUpsertWithWhereUniqueWithoutPessoaCaronaInput | CarroUpsertWithWhereUniqueWithoutPessoaCaronaInput[]
    createMany?: CarroCreateManyPessoaCaronaInputEnvelope
    set?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    disconnect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    delete?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    update?: CarroUpdateWithWhereUniqueWithoutPessoaCaronaInput | CarroUpdateWithWhereUniqueWithoutPessoaCaronaInput[]
    updateMany?: CarroUpdateManyWithWhereWithoutPessoaCaronaInput | CarroUpdateManyWithWhereWithoutPessoaCaronaInput[]
    deleteMany?: CarroScalarWhereInput | CarroScalarWhereInput[]
  }

  export type CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput = {
    create?: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput> | CarroCreateWithoutPessoaMotoristaInput[] | CarroUncheckedCreateWithoutPessoaMotoristaInput[]
    connectOrCreate?: CarroCreateOrConnectWithoutPessoaMotoristaInput | CarroCreateOrConnectWithoutPessoaMotoristaInput[]
    upsert?: CarroUpsertWithWhereUniqueWithoutPessoaMotoristaInput | CarroUpsertWithWhereUniqueWithoutPessoaMotoristaInput[]
    createMany?: CarroCreateManyPessoaMotoristaInputEnvelope
    set?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    disconnect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    delete?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    connect?: CarroWhereUniqueInput | CarroWhereUniqueInput[]
    update?: CarroUpdateWithWhereUniqueWithoutPessoaMotoristaInput | CarroUpdateWithWhereUniqueWithoutPessoaMotoristaInput[]
    updateMany?: CarroUpdateManyWithWhereWithoutPessoaMotoristaInput | CarroUpdateManyWithWhereWithoutPessoaMotoristaInput[]
    deleteMany?: CarroScalarWhereInput | CarroScalarWhereInput[]
  }

  export type CartaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput> | CartaCreateWithoutPessoaInput[] | CartaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: CartaCreateOrConnectWithoutPessoaInput | CartaCreateOrConnectWithoutPessoaInput[]
    upsert?: CartaUpsertWithWhereUniqueWithoutPessoaInput | CartaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: CartaCreateManyPessoaInputEnvelope
    set?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    disconnect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    delete?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    connect?: CartaWhereUniqueInput | CartaWhereUniqueInput[]
    update?: CartaUpdateWithWhereUniqueWithoutPessoaInput | CartaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: CartaUpdateManyWithWhereWithoutPessoaInput | CartaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: CartaScalarWhereInput | CartaScalarWhereInput[]
  }

  export type CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput = {
    create?: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioAparenteInput
    upsert?: CirculoUpsertWithoutTioAparenteInput
    disconnect?: CirculoWhereInput | boolean
    delete?: CirculoWhereInput | boolean
    connect?: CirculoWhereUniqueInput
    update?: XOR<XOR<CirculoUpdateToOneWithWhereWithoutTioAparenteInput, CirculoUpdateWithoutTioAparenteInput>, CirculoUncheckedUpdateWithoutTioAparenteInput>
  }

  export type CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput = {
    create?: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutTioSecretoInput
    upsert?: CirculoUpsertWithoutTioSecretoInput
    disconnect?: CirculoWhereInput | boolean
    delete?: CirculoWhereInput | boolean
    connect?: CirculoWhereUniqueInput
    update?: XOR<XOR<CirculoUpdateToOneWithWhereWithoutTioSecretoInput, CirculoUpdateWithoutTioSecretoInput>, CirculoUncheckedUpdateWithoutTioSecretoInput>
  }

  export type EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutPessoaInput
    upsert?: EncontreiroUpsertWithoutPessoaInput
    disconnect?: EncontreiroWhereInput | boolean
    delete?: EncontreiroWhereInput | boolean
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutPessoaInput, EncontreiroUpdateWithoutPessoaInput>, EncontreiroUncheckedUpdateWithoutPessoaInput>
  }

  export type EncontristaUncheckedUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutPessoaInput
    upsert?: EncontristaUpsertWithoutPessoaInput
    disconnect?: EncontristaWhereInput | boolean
    delete?: EncontristaWhereInput | boolean
    connect?: EncontristaWhereUniqueInput
    update?: XOR<XOR<EncontristaUpdateToOneWithWhereWithoutPessoaInput, EncontristaUpdateWithoutPessoaInput>, EncontristaUncheckedUpdateWithoutPessoaInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EnderecoCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<EnderecoCreateWithoutEncontristaInput, EnderecoUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEncontristaInput
    connect?: EnderecoWhereUniqueInput
  }

  export type CarroEncontroCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontristaInput, CarroEncontroUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontristaInput
    connect?: CarroEncontroWhereUniqueInput
  }

  export type DomainMoraComCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<DomainMoraComCreateWithoutEncontristaInput, DomainMoraComUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainMoraComCreateOrConnectWithoutEncontristaInput
    connect?: DomainMoraComWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<PessoaCreateWithoutEncontristaInput, PessoaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEncontristaInput
    connect?: PessoaWhereUniqueInput
  }

  export type DomainReligiaoCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<DomainReligiaoCreateWithoutEncontristaInput, DomainReligiaoUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainReligiaoCreateOrConnectWithoutEncontristaInput
    connect?: DomainReligiaoWhereUniqueInput
  }

  export type DomainStatusPaisCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<DomainStatusPaisCreateWithoutEncontristaInput, DomainStatusPaisUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainStatusPaisCreateOrConnectWithoutEncontristaInput
    connect?: DomainStatusPaisWhereUniqueInput
  }

  export type DomainStatusCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<DomainStatusCreateWithoutEncontristaInput, DomainStatusUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainStatusCreateOrConnectWithoutEncontristaInput
    connect?: DomainStatusWhereUniqueInput
  }

  export type ResponsavelExternaCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontristaInput
    connect?: ResponsavelExternaWhereUniqueInput
  }

  export type ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontristaInput
    connect?: ResponsavelExternaWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnderecoUpdateOneWithoutEncontristaNestedInput = {
    create?: XOR<EnderecoCreateWithoutEncontristaInput, EnderecoUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutEncontristaInput
    upsert?: EnderecoUpsertWithoutEncontristaInput
    disconnect?: EnderecoWhereInput | boolean
    delete?: EnderecoWhereInput | boolean
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutEncontristaInput, EnderecoUpdateWithoutEncontristaInput>, EnderecoUncheckedUpdateWithoutEncontristaInput>
  }

  export type CarroEncontroUpdateOneWithoutEncontristaNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontristaInput, CarroEncontroUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontristaInput
    upsert?: CarroEncontroUpsertWithoutEncontristaInput
    disconnect?: CarroEncontroWhereInput | boolean
    delete?: CarroEncontroWhereInput | boolean
    connect?: CarroEncontroWhereUniqueInput
    update?: XOR<XOR<CarroEncontroUpdateToOneWithWhereWithoutEncontristaInput, CarroEncontroUpdateWithoutEncontristaInput>, CarroEncontroUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput = {
    create?: XOR<DomainMoraComCreateWithoutEncontristaInput, DomainMoraComUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainMoraComCreateOrConnectWithoutEncontristaInput
    upsert?: DomainMoraComUpsertWithoutEncontristaInput
    connect?: DomainMoraComWhereUniqueInput
    update?: XOR<XOR<DomainMoraComUpdateToOneWithWhereWithoutEncontristaInput, DomainMoraComUpdateWithoutEncontristaInput>, DomainMoraComUncheckedUpdateWithoutEncontristaInput>
  }

  export type PessoaUpdateOneRequiredWithoutEncontristaNestedInput = {
    create?: XOR<PessoaCreateWithoutEncontristaInput, PessoaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEncontristaInput
    upsert?: PessoaUpsertWithoutEncontristaInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutEncontristaInput, PessoaUpdateWithoutEncontristaInput>, PessoaUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput = {
    create?: XOR<DomainReligiaoCreateWithoutEncontristaInput, DomainReligiaoUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainReligiaoCreateOrConnectWithoutEncontristaInput
    upsert?: DomainReligiaoUpsertWithoutEncontristaInput
    connect?: DomainReligiaoWhereUniqueInput
    update?: XOR<XOR<DomainReligiaoUpdateToOneWithWhereWithoutEncontristaInput, DomainReligiaoUpdateWithoutEncontristaInput>, DomainReligiaoUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput = {
    create?: XOR<DomainStatusPaisCreateWithoutEncontristaInput, DomainStatusPaisUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainStatusPaisCreateOrConnectWithoutEncontristaInput
    upsert?: DomainStatusPaisUpsertWithoutEncontristaInput
    connect?: DomainStatusPaisWhereUniqueInput
    update?: XOR<XOR<DomainStatusPaisUpdateToOneWithWhereWithoutEncontristaInput, DomainStatusPaisUpdateWithoutEncontristaInput>, DomainStatusPaisUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput = {
    create?: XOR<DomainStatusCreateWithoutEncontristaInput, DomainStatusUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: DomainStatusCreateOrConnectWithoutEncontristaInput
    upsert?: DomainStatusUpsertWithoutEncontristaInput
    connect?: DomainStatusWhereUniqueInput
    update?: XOR<XOR<DomainStatusUpdateToOneWithWhereWithoutEncontristaInput, DomainStatusUpdateWithoutEncontristaInput>, DomainStatusUncheckedUpdateWithoutEncontristaInput>
  }

  export type ResponsavelExternaUpdateOneWithoutEncontristaNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontristaInput
    upsert?: ResponsavelExternaUpsertWithoutEncontristaInput
    disconnect?: ResponsavelExternaWhereInput | boolean
    delete?: ResponsavelExternaWhereInput | boolean
    connect?: ResponsavelExternaWhereUniqueInput
    update?: XOR<XOR<ResponsavelExternaUpdateToOneWithWhereWithoutEncontristaInput, ResponsavelExternaUpdateWithoutEncontristaInput>, ResponsavelExternaUncheckedUpdateWithoutEncontristaInput>
  }

  export type EnumValue_StatusFieldUpdateOperationsInput = {
    set?: $Enums.Value_Status
  }

  export type EnumValue_ReligiaoFieldUpdateOperationsInput = {
    set?: $Enums.Value_Religiao
  }

  export type EnumValue_MoraComFieldUpdateOperationsInput = {
    set?: $Enums.Value_MoraCom
  }

  export type EnumValue_StatusPaisFieldUpdateOperationsInput = {
    set?: $Enums.Value_StatusPais
  }

  export type ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontristaInput
    upsert?: ResponsavelExternaUpsertWithoutEncontristaInput
    disconnect?: ResponsavelExternaWhereInput | boolean
    delete?: ResponsavelExternaWhereInput | boolean
    connect?: ResponsavelExternaWhereUniqueInput
    update?: XOR<XOR<ResponsavelExternaUpdateToOneWithWhereWithoutEncontristaInput, ResponsavelExternaUpdateWithoutEncontristaInput>, ResponsavelExternaUncheckedUpdateWithoutEncontristaInput>
  }

  export type CarroEncontroCreateNestedManyWithoutExternaInput = {
    create?: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput> | CarroEncontroCreateWithoutExternaInput[] | CarroEncontroUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutExternaInput | CarroEncontroCreateOrConnectWithoutExternaInput[]
    createMany?: CarroEncontroCreateManyExternaInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type CirculoCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<CirculoCreateWithoutEncontreiroInput, CirculoUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontreiroInput
    connect?: CirculoWhereUniqueInput
  }

  export type EncontroCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<EncontroCreateWithoutEncontreiroInput, EncontroUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutEncontreiroInput
    connect?: EncontroWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<PessoaCreateWithoutEncontreiroInput, PessoaUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEncontreiroInput
    connect?: PessoaWhereUniqueInput
  }

  export type DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<DomainTamanhoCamisaCreateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: DomainTamanhoCamisaCreateOrConnectWithoutEncontreiroInput
    connect?: DomainTamanhoCamisaWhereUniqueInput
  }

  export type DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<DomainDisponibilidadeCreateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: DomainDisponibilidadeCreateOrConnectWithoutEncontreiroInput
    connect?: DomainDisponibilidadeWhereUniqueInput
  }

  export type EquipeEncontroCreateNestedManyWithoutEncontreiroInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput> | EquipeEncontroCreateWithoutEncontreiroInput[] | EquipeEncontroUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontreiroInput | EquipeEncontroCreateOrConnectWithoutEncontreiroInput[]
    createMany?: EquipeEncontroCreateManyEncontreiroInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type EquipeMontagemCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEncontreiroInput
    connect?: EquipeMontagemWhereUniqueInput
  }

  export type ListaPreferenciaCreateNestedManyWithoutEncontreiroInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput> | ListaPreferenciaCreateWithoutEncontreiroInput[] | ListaPreferenciaUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEncontreiroInput | ListaPreferenciaCreateOrConnectWithoutEncontreiroInput[]
    createMany?: ListaPreferenciaCreateManyEncontreiroInputEnvelope
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
  }

  export type ResponsavelExternaCreateNestedManyWithoutExternaInput = {
    create?: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput> | ResponsavelExternaCreateWithoutExternaInput[] | ResponsavelExternaUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutExternaInput | ResponsavelExternaCreateOrConnectWithoutExternaInput[]
    createMany?: ResponsavelExternaCreateManyExternaInputEnvelope
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
  }

  export type CarroEncontroUncheckedCreateNestedManyWithoutExternaInput = {
    create?: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput> | CarroEncontroCreateWithoutExternaInput[] | CarroEncontroUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutExternaInput | CarroEncontroCreateOrConnectWithoutExternaInput[]
    createMany?: CarroEncontroCreateManyExternaInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput> | EquipeEncontroCreateWithoutEncontreiroInput[] | EquipeEncontroUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontreiroInput | EquipeEncontroCreateOrConnectWithoutEncontreiroInput[]
    createMany?: EquipeEncontroCreateManyEncontreiroInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput = {
    create?: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEncontreiroInput
    connect?: EquipeMontagemWhereUniqueInput
  }

  export type ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput> | ListaPreferenciaCreateWithoutEncontreiroInput[] | ListaPreferenciaUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEncontreiroInput | ListaPreferenciaCreateOrConnectWithoutEncontreiroInput[]
    createMany?: ListaPreferenciaCreateManyEncontreiroInputEnvelope
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
  }

  export type ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput = {
    create?: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput> | ResponsavelExternaCreateWithoutExternaInput[] | ResponsavelExternaUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutExternaInput | ResponsavelExternaCreateOrConnectWithoutExternaInput[]
    createMany?: ResponsavelExternaCreateManyExternaInputEnvelope
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
  }

  export type NullableEnumStatusEncontreiroFieldUpdateOperationsInput = {
    set?: $Enums.StatusEncontreiro | null
  }

  export type CarroEncontroUpdateManyWithoutExternaNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput> | CarroEncontroCreateWithoutExternaInput[] | CarroEncontroUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutExternaInput | CarroEncontroCreateOrConnectWithoutExternaInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutExternaInput | CarroEncontroUpsertWithWhereUniqueWithoutExternaInput[]
    createMany?: CarroEncontroCreateManyExternaInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutExternaInput | CarroEncontroUpdateWithWhereUniqueWithoutExternaInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutExternaInput | CarroEncontroUpdateManyWithWhereWithoutExternaInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type CirculoUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<CirculoCreateWithoutEncontreiroInput, CirculoUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontreiroInput
    upsert?: CirculoUpsertWithoutEncontreiroInput
    disconnect?: CirculoWhereInput | boolean
    delete?: CirculoWhereInput | boolean
    connect?: CirculoWhereUniqueInput
    update?: XOR<XOR<CirculoUpdateToOneWithWhereWithoutEncontreiroInput, CirculoUpdateWithoutEncontreiroInput>, CirculoUncheckedUpdateWithoutEncontreiroInput>
  }

  export type EncontroUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<EncontroCreateWithoutEncontreiroInput, EncontroUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutEncontreiroInput
    upsert?: EncontroUpsertWithoutEncontreiroInput
    disconnect?: EncontroWhereInput | boolean
    delete?: EncontroWhereInput | boolean
    connect?: EncontroWhereUniqueInput
    update?: XOR<XOR<EncontroUpdateToOneWithWhereWithoutEncontreiroInput, EncontroUpdateWithoutEncontreiroInput>, EncontroUncheckedUpdateWithoutEncontreiroInput>
  }

  export type PessoaUpdateOneRequiredWithoutEncontreiroNestedInput = {
    create?: XOR<PessoaCreateWithoutEncontreiroInput, PessoaUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutEncontreiroInput
    upsert?: PessoaUpsertWithoutEncontreiroInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutEncontreiroInput, PessoaUpdateWithoutEncontreiroInput>, PessoaUncheckedUpdateWithoutEncontreiroInput>
  }

  export type DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<DomainTamanhoCamisaCreateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: DomainTamanhoCamisaCreateOrConnectWithoutEncontreiroInput
    upsert?: DomainTamanhoCamisaUpsertWithoutEncontreiroInput
    disconnect?: DomainTamanhoCamisaWhereInput | boolean
    delete?: DomainTamanhoCamisaWhereInput | boolean
    connect?: DomainTamanhoCamisaWhereUniqueInput
    update?: XOR<XOR<DomainTamanhoCamisaUpdateToOneWithWhereWithoutEncontreiroInput, DomainTamanhoCamisaUpdateWithoutEncontreiroInput>, DomainTamanhoCamisaUncheckedUpdateWithoutEncontreiroInput>
  }

  export type DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<DomainDisponibilidadeCreateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: DomainDisponibilidadeCreateOrConnectWithoutEncontreiroInput
    upsert?: DomainDisponibilidadeUpsertWithoutEncontreiroInput
    disconnect?: DomainDisponibilidadeWhereInput | boolean
    delete?: DomainDisponibilidadeWhereInput | boolean
    connect?: DomainDisponibilidadeWhereUniqueInput
    update?: XOR<XOR<DomainDisponibilidadeUpdateToOneWithWhereWithoutEncontreiroInput, DomainDisponibilidadeUpdateWithoutEncontreiroInput>, DomainDisponibilidadeUncheckedUpdateWithoutEncontreiroInput>
  }

  export type EquipeEncontroUpdateManyWithoutEncontreiroNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput> | EquipeEncontroCreateWithoutEncontreiroInput[] | EquipeEncontroUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontreiroInput | EquipeEncontroCreateOrConnectWithoutEncontreiroInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEncontreiroInput | EquipeEncontroUpsertWithWhereUniqueWithoutEncontreiroInput[]
    createMany?: EquipeEncontroCreateManyEncontreiroInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEncontreiroInput | EquipeEncontroUpdateWithWhereUniqueWithoutEncontreiroInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEncontreiroInput | EquipeEncontroUpdateManyWithWhereWithoutEncontreiroInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type EquipeMontagemUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEncontreiroInput
    upsert?: EquipeMontagemUpsertWithoutEncontreiroInput
    disconnect?: EquipeMontagemWhereInput | boolean
    delete?: EquipeMontagemWhereInput | boolean
    connect?: EquipeMontagemWhereUniqueInput
    update?: XOR<XOR<EquipeMontagemUpdateToOneWithWhereWithoutEncontreiroInput, EquipeMontagemUpdateWithoutEncontreiroInput>, EquipeMontagemUncheckedUpdateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput> | ListaPreferenciaCreateWithoutEncontreiroInput[] | ListaPreferenciaUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEncontreiroInput | ListaPreferenciaCreateOrConnectWithoutEncontreiroInput[]
    upsert?: ListaPreferenciaUpsertWithWhereUniqueWithoutEncontreiroInput | ListaPreferenciaUpsertWithWhereUniqueWithoutEncontreiroInput[]
    createMany?: ListaPreferenciaCreateManyEncontreiroInputEnvelope
    set?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    disconnect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    delete?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    update?: ListaPreferenciaUpdateWithWhereUniqueWithoutEncontreiroInput | ListaPreferenciaUpdateWithWhereUniqueWithoutEncontreiroInput[]
    updateMany?: ListaPreferenciaUpdateManyWithWhereWithoutEncontreiroInput | ListaPreferenciaUpdateManyWithWhereWithoutEncontreiroInput[]
    deleteMany?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
  }

  export type ResponsavelExternaUpdateManyWithoutExternaNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput> | ResponsavelExternaCreateWithoutExternaInput[] | ResponsavelExternaUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutExternaInput | ResponsavelExternaCreateOrConnectWithoutExternaInput[]
    upsert?: ResponsavelExternaUpsertWithWhereUniqueWithoutExternaInput | ResponsavelExternaUpsertWithWhereUniqueWithoutExternaInput[]
    createMany?: ResponsavelExternaCreateManyExternaInputEnvelope
    set?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    disconnect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    delete?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    update?: ResponsavelExternaUpdateWithWhereUniqueWithoutExternaInput | ResponsavelExternaUpdateWithWhereUniqueWithoutExternaInput[]
    updateMany?: ResponsavelExternaUpdateManyWithWhereWithoutExternaInput | ResponsavelExternaUpdateManyWithWhereWithoutExternaInput[]
    deleteMany?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
  }

  export type NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput = {
    set?: $Enums.Value_TamanhoCamisa | null
  }

  export type NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput = {
    set?: $Enums.Value_Disponibilidade | null
  }

  export type CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput> | CarroEncontroCreateWithoutExternaInput[] | CarroEncontroUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutExternaInput | CarroEncontroCreateOrConnectWithoutExternaInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutExternaInput | CarroEncontroUpsertWithWhereUniqueWithoutExternaInput[]
    createMany?: CarroEncontroCreateManyExternaInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutExternaInput | CarroEncontroUpdateWithWhereUniqueWithoutExternaInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutExternaInput | CarroEncontroUpdateManyWithWhereWithoutExternaInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput> | EquipeEncontroCreateWithoutEncontreiroInput[] | EquipeEncontroUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontreiroInput | EquipeEncontroCreateOrConnectWithoutEncontreiroInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEncontreiroInput | EquipeEncontroUpsertWithWhereUniqueWithoutEncontreiroInput[]
    createMany?: EquipeEncontroCreateManyEncontreiroInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEncontreiroInput | EquipeEncontroUpdateWithWhereUniqueWithoutEncontreiroInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEncontreiroInput | EquipeEncontroUpdateManyWithWhereWithoutEncontreiroInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput = {
    create?: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEncontreiroInput
    upsert?: EquipeMontagemUpsertWithoutEncontreiroInput
    disconnect?: EquipeMontagemWhereInput | boolean
    delete?: EquipeMontagemWhereInput | boolean
    connect?: EquipeMontagemWhereUniqueInput
    update?: XOR<XOR<EquipeMontagemUpdateToOneWithWhereWithoutEncontreiroInput, EquipeMontagemUpdateWithoutEncontreiroInput>, EquipeMontagemUncheckedUpdateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput> | ListaPreferenciaCreateWithoutEncontreiroInput[] | ListaPreferenciaUncheckedCreateWithoutEncontreiroInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEncontreiroInput | ListaPreferenciaCreateOrConnectWithoutEncontreiroInput[]
    upsert?: ListaPreferenciaUpsertWithWhereUniqueWithoutEncontreiroInput | ListaPreferenciaUpsertWithWhereUniqueWithoutEncontreiroInput[]
    createMany?: ListaPreferenciaCreateManyEncontreiroInputEnvelope
    set?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    disconnect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    delete?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    update?: ListaPreferenciaUpdateWithWhereUniqueWithoutEncontreiroInput | ListaPreferenciaUpdateWithWhereUniqueWithoutEncontreiroInput[]
    updateMany?: ListaPreferenciaUpdateManyWithWhereWithoutEncontreiroInput | ListaPreferenciaUpdateManyWithWhereWithoutEncontreiroInput[]
    deleteMany?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
  }

  export type ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput> | ResponsavelExternaCreateWithoutExternaInput[] | ResponsavelExternaUncheckedCreateWithoutExternaInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutExternaInput | ResponsavelExternaCreateOrConnectWithoutExternaInput[]
    upsert?: ResponsavelExternaUpsertWithWhereUniqueWithoutExternaInput | ResponsavelExternaUpsertWithWhereUniqueWithoutExternaInput[]
    createMany?: ResponsavelExternaCreateManyExternaInputEnvelope
    set?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    disconnect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    delete?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    update?: ResponsavelExternaUpdateWithWhereUniqueWithoutExternaInput | ResponsavelExternaUpdateWithWhereUniqueWithoutExternaInput[]
    updateMany?: ResponsavelExternaUpdateManyWithWhereWithoutExternaInput | ResponsavelExternaUpdateManyWithWhereWithoutExternaInput[]
    deleteMany?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
  }

  export type CarroEncontroCreateNestedManyWithoutEncontroInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput> | CarroEncontroCreateWithoutEncontroInput[] | CarroEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontroInput | CarroEncontroCreateOrConnectWithoutEncontroInput[]
    createMany?: CarroEncontroCreateManyEncontroInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type CirculoCreateNestedManyWithoutEncontroInput = {
    create?: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput> | CirculoCreateWithoutEncontroInput[] | CirculoUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontroInput | CirculoCreateOrConnectWithoutEncontroInput[]
    createMany?: CirculoCreateManyEncontroInputEnvelope
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
  }

  export type EncontreiroCreateNestedManyWithoutEncontroInput = {
    create?: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput> | EncontreiroCreateWithoutEncontroInput[] | EncontreiroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEncontroInput | EncontreiroCreateOrConnectWithoutEncontroInput[]
    createMany?: EncontreiroCreateManyEncontroInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type LocalCreateNestedOneWithoutEncontroInput = {
    create?: XOR<LocalCreateWithoutEncontroInput, LocalUncheckedCreateWithoutEncontroInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEncontroInput
    connect?: LocalWhereUniqueInput
  }

  export type EquipeEncontroCreateNestedManyWithoutEncontroInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput> | EquipeEncontroCreateWithoutEncontroInput[] | EquipeEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontroInput | EquipeEncontroCreateOrConnectWithoutEncontroInput[]
    createMany?: EquipeEncontroCreateManyEncontroInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type ResponsavelExternaCreateNestedManyWithoutEncontroInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput> | ResponsavelExternaCreateWithoutEncontroInput[] | ResponsavelExternaUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontroInput | ResponsavelExternaCreateOrConnectWithoutEncontroInput[]
    createMany?: ResponsavelExternaCreateManyEncontroInputEnvelope
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
  }

  export type CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput> | CarroEncontroCreateWithoutEncontroInput[] | CarroEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontroInput | CarroEncontroCreateOrConnectWithoutEncontroInput[]
    createMany?: CarroEncontroCreateManyEncontroInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type CirculoUncheckedCreateNestedManyWithoutEncontroInput = {
    create?: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput> | CirculoCreateWithoutEncontroInput[] | CirculoUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontroInput | CirculoCreateOrConnectWithoutEncontroInput[]
    createMany?: CirculoCreateManyEncontroInputEnvelope
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
  }

  export type EncontreiroUncheckedCreateNestedManyWithoutEncontroInput = {
    create?: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput> | EncontreiroCreateWithoutEncontroInput[] | EncontreiroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEncontroInput | EncontreiroCreateOrConnectWithoutEncontroInput[]
    createMany?: EncontreiroCreateManyEncontroInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput> | EquipeEncontroCreateWithoutEncontroInput[] | EquipeEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontroInput | EquipeEncontroCreateOrConnectWithoutEncontroInput[]
    createMany?: EquipeEncontroCreateManyEncontroInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput> | ResponsavelExternaCreateWithoutEncontroInput[] | ResponsavelExternaUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontroInput | ResponsavelExternaCreateOrConnectWithoutEncontroInput[]
    createMany?: ResponsavelExternaCreateManyEncontroInputEnvelope
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
  }

  export type CarroEncontroUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput> | CarroEncontroCreateWithoutEncontroInput[] | CarroEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontroInput | CarroEncontroCreateOrConnectWithoutEncontroInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutEncontroInput | CarroEncontroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: CarroEncontroCreateManyEncontroInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutEncontroInput | CarroEncontroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutEncontroInput | CarroEncontroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type CirculoUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput> | CirculoCreateWithoutEncontroInput[] | CirculoUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontroInput | CirculoCreateOrConnectWithoutEncontroInput[]
    upsert?: CirculoUpsertWithWhereUniqueWithoutEncontroInput | CirculoUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: CirculoCreateManyEncontroInputEnvelope
    set?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    disconnect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    delete?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    update?: CirculoUpdateWithWhereUniqueWithoutEncontroInput | CirculoUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: CirculoUpdateManyWithWhereWithoutEncontroInput | CirculoUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
  }

  export type EncontreiroUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput> | EncontreiroCreateWithoutEncontroInput[] | EncontreiroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEncontroInput | EncontreiroCreateOrConnectWithoutEncontroInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutEncontroInput | EncontreiroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: EncontreiroCreateManyEncontroInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutEncontroInput | EncontreiroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutEncontroInput | EncontreiroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type LocalUpdateOneRequiredWithoutEncontroNestedInput = {
    create?: XOR<LocalCreateWithoutEncontroInput, LocalUncheckedCreateWithoutEncontroInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEncontroInput
    upsert?: LocalUpsertWithoutEncontroInput
    connect?: LocalWhereUniqueInput
    update?: XOR<XOR<LocalUpdateToOneWithWhereWithoutEncontroInput, LocalUpdateWithoutEncontroInput>, LocalUncheckedUpdateWithoutEncontroInput>
  }

  export type EquipeEncontroUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput> | EquipeEncontroCreateWithoutEncontroInput[] | EquipeEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontroInput | EquipeEncontroCreateOrConnectWithoutEncontroInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEncontroInput | EquipeEncontroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: EquipeEncontroCreateManyEncontroInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEncontroInput | EquipeEncontroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEncontroInput | EquipeEncontroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type ResponsavelExternaUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput> | ResponsavelExternaCreateWithoutEncontroInput[] | ResponsavelExternaUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontroInput | ResponsavelExternaCreateOrConnectWithoutEncontroInput[]
    upsert?: ResponsavelExternaUpsertWithWhereUniqueWithoutEncontroInput | ResponsavelExternaUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: ResponsavelExternaCreateManyEncontroInputEnvelope
    set?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    disconnect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    delete?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    update?: ResponsavelExternaUpdateWithWhereUniqueWithoutEncontroInput | ResponsavelExternaUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: ResponsavelExternaUpdateManyWithWhereWithoutEncontroInput | ResponsavelExternaUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
  }

  export type CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput> | CarroEncontroCreateWithoutEncontroInput[] | CarroEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutEncontroInput | CarroEncontroCreateOrConnectWithoutEncontroInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutEncontroInput | CarroEncontroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: CarroEncontroCreateManyEncontroInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutEncontroInput | CarroEncontroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutEncontroInput | CarroEncontroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type CirculoUncheckedUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput> | CirculoCreateWithoutEncontroInput[] | CirculoUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutEncontroInput | CirculoCreateOrConnectWithoutEncontroInput[]
    upsert?: CirculoUpsertWithWhereUniqueWithoutEncontroInput | CirculoUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: CirculoCreateManyEncontroInputEnvelope
    set?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    disconnect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    delete?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    update?: CirculoUpdateWithWhereUniqueWithoutEncontroInput | CirculoUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: CirculoUpdateManyWithWhereWithoutEncontroInput | CirculoUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
  }

  export type EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput> | EncontreiroCreateWithoutEncontroInput[] | EncontreiroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEncontroInput | EncontreiroCreateOrConnectWithoutEncontroInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutEncontroInput | EncontreiroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: EncontreiroCreateManyEncontroInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutEncontroInput | EncontreiroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutEncontroInput | EncontreiroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput> | EquipeEncontroCreateWithoutEncontroInput[] | EquipeEncontroUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEncontroInput | EquipeEncontroCreateOrConnectWithoutEncontroInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEncontroInput | EquipeEncontroUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: EquipeEncontroCreateManyEncontroInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEncontroInput | EquipeEncontroUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEncontroInput | EquipeEncontroUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput = {
    create?: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput> | ResponsavelExternaCreateWithoutEncontroInput[] | ResponsavelExternaUncheckedCreateWithoutEncontroInput[]
    connectOrCreate?: ResponsavelExternaCreateOrConnectWithoutEncontroInput | ResponsavelExternaCreateOrConnectWithoutEncontroInput[]
    upsert?: ResponsavelExternaUpsertWithWhereUniqueWithoutEncontroInput | ResponsavelExternaUpsertWithWhereUniqueWithoutEncontroInput[]
    createMany?: ResponsavelExternaCreateManyEncontroInputEnvelope
    set?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    disconnect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    delete?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    connect?: ResponsavelExternaWhereUniqueInput | ResponsavelExternaWhereUniqueInput[]
    update?: ResponsavelExternaUpdateWithWhereUniqueWithoutEncontroInput | ResponsavelExternaUpdateWithWhereUniqueWithoutEncontroInput[]
    updateMany?: ResponsavelExternaUpdateManyWithWhereWithoutEncontroInput | ResponsavelExternaUpdateManyWithWhereWithoutEncontroInput[]
    deleteMany?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
  }

  export type DomainCorCirculoCreateNestedOneWithoutCirculoInput = {
    create?: XOR<DomainCorCirculoCreateWithoutCirculoInput, DomainCorCirculoUncheckedCreateWithoutCirculoInput>
    connectOrCreate?: DomainCorCirculoCreateOrConnectWithoutCirculoInput
    connect?: DomainCorCirculoWhereUniqueInput
  }

  export type EncontroCreateNestedOneWithoutCirculoInput = {
    create?: XOR<EncontroCreateWithoutCirculoInput, EncontroUncheckedCreateWithoutCirculoInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutCirculoInput
    connect?: EncontroWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutTioAparenteCirculoInput = {
    create?: XOR<PessoaCreateWithoutTioAparenteCirculoInput, PessoaUncheckedCreateWithoutTioAparenteCirculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutTioAparenteCirculoInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutTioSecretoCirculoInput = {
    create?: XOR<PessoaCreateWithoutTioSecretoCirculoInput, PessoaUncheckedCreateWithoutTioSecretoCirculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutTioSecretoCirculoInput
    connect?: PessoaWhereUniqueInput
  }

  export type EncontreiroCreateNestedManyWithoutCirculoInput = {
    create?: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput> | EncontreiroCreateWithoutCirculoInput[] | EncontreiroUncheckedCreateWithoutCirculoInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutCirculoInput | EncontreiroCreateOrConnectWithoutCirculoInput[]
    createMany?: EncontreiroCreateManyCirculoInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EncontreiroUncheckedCreateNestedManyWithoutCirculoInput = {
    create?: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput> | EncontreiroCreateWithoutCirculoInput[] | EncontreiroUncheckedCreateWithoutCirculoInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutCirculoInput | EncontreiroCreateOrConnectWithoutCirculoInput[]
    createMany?: EncontreiroCreateManyCirculoInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput = {
    create?: XOR<DomainCorCirculoCreateWithoutCirculoInput, DomainCorCirculoUncheckedCreateWithoutCirculoInput>
    connectOrCreate?: DomainCorCirculoCreateOrConnectWithoutCirculoInput
    upsert?: DomainCorCirculoUpsertWithoutCirculoInput
    connect?: DomainCorCirculoWhereUniqueInput
    update?: XOR<XOR<DomainCorCirculoUpdateToOneWithWhereWithoutCirculoInput, DomainCorCirculoUpdateWithoutCirculoInput>, DomainCorCirculoUncheckedUpdateWithoutCirculoInput>
  }

  export type EncontroUpdateOneRequiredWithoutCirculoNestedInput = {
    create?: XOR<EncontroCreateWithoutCirculoInput, EncontroUncheckedCreateWithoutCirculoInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutCirculoInput
    upsert?: EncontroUpsertWithoutCirculoInput
    connect?: EncontroWhereUniqueInput
    update?: XOR<XOR<EncontroUpdateToOneWithWhereWithoutCirculoInput, EncontroUpdateWithoutCirculoInput>, EncontroUncheckedUpdateWithoutCirculoInput>
  }

  export type PessoaUpdateOneWithoutTioAparenteCirculoNestedInput = {
    create?: XOR<PessoaCreateWithoutTioAparenteCirculoInput, PessoaUncheckedCreateWithoutTioAparenteCirculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutTioAparenteCirculoInput
    upsert?: PessoaUpsertWithoutTioAparenteCirculoInput
    disconnect?: PessoaWhereInput | boolean
    delete?: PessoaWhereInput | boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutTioAparenteCirculoInput, PessoaUpdateWithoutTioAparenteCirculoInput>, PessoaUncheckedUpdateWithoutTioAparenteCirculoInput>
  }

  export type PessoaUpdateOneWithoutTioSecretoCirculoNestedInput = {
    create?: XOR<PessoaCreateWithoutTioSecretoCirculoInput, PessoaUncheckedCreateWithoutTioSecretoCirculoInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutTioSecretoCirculoInput
    upsert?: PessoaUpsertWithoutTioSecretoCirculoInput
    disconnect?: PessoaWhereInput | boolean
    delete?: PessoaWhereInput | boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutTioSecretoCirculoInput, PessoaUpdateWithoutTioSecretoCirculoInput>, PessoaUncheckedUpdateWithoutTioSecretoCirculoInput>
  }

  export type EncontreiroUpdateManyWithoutCirculoNestedInput = {
    create?: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput> | EncontreiroCreateWithoutCirculoInput[] | EncontreiroUncheckedCreateWithoutCirculoInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutCirculoInput | EncontreiroCreateOrConnectWithoutCirculoInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutCirculoInput | EncontreiroUpsertWithWhereUniqueWithoutCirculoInput[]
    createMany?: EncontreiroCreateManyCirculoInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutCirculoInput | EncontreiroUpdateWithWhereUniqueWithoutCirculoInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutCirculoInput | EncontreiroUpdateManyWithWhereWithoutCirculoInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput = {
    create?: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput> | EncontreiroCreateWithoutCirculoInput[] | EncontreiroUncheckedCreateWithoutCirculoInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutCirculoInput | EncontreiroCreateOrConnectWithoutCirculoInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutCirculoInput | EncontreiroUpsertWithWhereUniqueWithoutCirculoInput[]
    createMany?: EncontreiroCreateManyCirculoInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutCirculoInput | EncontreiroUpdateWithWhereUniqueWithoutCirculoInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutCirculoInput | EncontreiroUpdateManyWithWhereWithoutCirculoInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EncontristaCreateNestedManyWithoutEnderecoEncontroInput = {
    create?: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput> | EncontristaCreateWithoutEnderecoEncontroInput[] | EncontristaUncheckedCreateWithoutEnderecoEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutEnderecoEncontroInput | EncontristaCreateOrConnectWithoutEnderecoEncontroInput[]
    createMany?: EncontristaCreateManyEnderecoEncontroInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type LocalCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput> | LocalCreateWithoutEnderecoInput[] | LocalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: LocalCreateOrConnectWithoutEnderecoInput | LocalCreateOrConnectWithoutEnderecoInput[]
    createMany?: LocalCreateManyEnderecoInputEnvelope
    connect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
  }

  export type PessoaCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput> | PessoaCreateWithoutEnderecoInput[] | PessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput | PessoaCreateOrConnectWithoutEnderecoInput[]
    createMany?: PessoaCreateManyEnderecoInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutEnderecoEncontroInput = {
    create?: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput> | EncontristaCreateWithoutEnderecoEncontroInput[] | EncontristaUncheckedCreateWithoutEnderecoEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutEnderecoEncontroInput | EncontristaCreateOrConnectWithoutEnderecoEncontroInput[]
    createMany?: EncontristaCreateManyEnderecoEncontroInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type LocalUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput> | LocalCreateWithoutEnderecoInput[] | LocalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: LocalCreateOrConnectWithoutEnderecoInput | LocalCreateOrConnectWithoutEnderecoInput[]
    createMany?: LocalCreateManyEnderecoInputEnvelope
    connect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
  }

  export type PessoaUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput> | PessoaCreateWithoutEnderecoInput[] | PessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput | PessoaCreateOrConnectWithoutEnderecoInput[]
    createMany?: PessoaCreateManyEnderecoInputEnvelope
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
  }

  export type EncontristaUpdateManyWithoutEnderecoEncontroNestedInput = {
    create?: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput> | EncontristaCreateWithoutEnderecoEncontroInput[] | EncontristaUncheckedCreateWithoutEnderecoEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutEnderecoEncontroInput | EncontristaCreateOrConnectWithoutEnderecoEncontroInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutEnderecoEncontroInput | EncontristaUpsertWithWhereUniqueWithoutEnderecoEncontroInput[]
    createMany?: EncontristaCreateManyEnderecoEncontroInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutEnderecoEncontroInput | EncontristaUpdateWithWhereUniqueWithoutEnderecoEncontroInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutEnderecoEncontroInput | EncontristaUpdateManyWithWhereWithoutEnderecoEncontroInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type LocalUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput> | LocalCreateWithoutEnderecoInput[] | LocalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: LocalCreateOrConnectWithoutEnderecoInput | LocalCreateOrConnectWithoutEnderecoInput[]
    upsert?: LocalUpsertWithWhereUniqueWithoutEnderecoInput | LocalUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: LocalCreateManyEnderecoInputEnvelope
    set?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    disconnect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    delete?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    connect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    update?: LocalUpdateWithWhereUniqueWithoutEnderecoInput | LocalUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: LocalUpdateManyWithWhereWithoutEnderecoInput | LocalUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: LocalScalarWhereInput | LocalScalarWhereInput[]
  }

  export type PessoaUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput> | PessoaCreateWithoutEnderecoInput[] | PessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput | PessoaCreateOrConnectWithoutEnderecoInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutEnderecoInput | PessoaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: PessoaCreateManyEnderecoInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutEnderecoInput | PessoaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutEnderecoInput | PessoaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutEnderecoEncontroNestedInput = {
    create?: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput> | EncontristaCreateWithoutEnderecoEncontroInput[] | EncontristaUncheckedCreateWithoutEnderecoEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutEnderecoEncontroInput | EncontristaCreateOrConnectWithoutEnderecoEncontroInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutEnderecoEncontroInput | EncontristaUpsertWithWhereUniqueWithoutEnderecoEncontroInput[]
    createMany?: EncontristaCreateManyEnderecoEncontroInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutEnderecoEncontroInput | EncontristaUpdateWithWhereUniqueWithoutEnderecoEncontroInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutEnderecoEncontroInput | EncontristaUpdateManyWithWhereWithoutEnderecoEncontroInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type LocalUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput> | LocalCreateWithoutEnderecoInput[] | LocalUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: LocalCreateOrConnectWithoutEnderecoInput | LocalCreateOrConnectWithoutEnderecoInput[]
    upsert?: LocalUpsertWithWhereUniqueWithoutEnderecoInput | LocalUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: LocalCreateManyEnderecoInputEnvelope
    set?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    disconnect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    delete?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    connect?: LocalWhereUniqueInput | LocalWhereUniqueInput[]
    update?: LocalUpdateWithWhereUniqueWithoutEnderecoInput | LocalUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: LocalUpdateManyWithWhereWithoutEnderecoInput | LocalUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: LocalScalarWhereInput | LocalScalarWhereInput[]
  }

  export type PessoaUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput> | PessoaCreateWithoutEnderecoInput[] | PessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: PessoaCreateOrConnectWithoutEnderecoInput | PessoaCreateOrConnectWithoutEnderecoInput[]
    upsert?: PessoaUpsertWithWhereUniqueWithoutEnderecoInput | PessoaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: PessoaCreateManyEnderecoInputEnvelope
    set?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    disconnect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    delete?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    connect?: PessoaWhereUniqueInput | PessoaWhereUniqueInput[]
    update?: PessoaUpdateWithWhereUniqueWithoutEnderecoInput | PessoaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: PessoaUpdateManyWithWhereWithoutEnderecoInput | PessoaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
  }

  export type EncontroCreateNestedManyWithoutLocalInput = {
    create?: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput> | EncontroCreateWithoutLocalInput[] | EncontroUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EncontroCreateOrConnectWithoutLocalInput | EncontroCreateOrConnectWithoutLocalInput[]
    createMany?: EncontroCreateManyLocalInputEnvelope
    connect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
  }

  export type EnderecoCreateNestedOneWithoutLocalInput = {
    create?: XOR<EnderecoCreateWithoutLocalInput, EnderecoUncheckedCreateWithoutLocalInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutLocalInput
    connect?: EnderecoWhereUniqueInput
  }

  export type EncontroUncheckedCreateNestedManyWithoutLocalInput = {
    create?: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput> | EncontroCreateWithoutLocalInput[] | EncontroUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EncontroCreateOrConnectWithoutLocalInput | EncontroCreateOrConnectWithoutLocalInput[]
    createMany?: EncontroCreateManyLocalInputEnvelope
    connect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
  }

  export type EncontroUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput> | EncontroCreateWithoutLocalInput[] | EncontroUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EncontroCreateOrConnectWithoutLocalInput | EncontroCreateOrConnectWithoutLocalInput[]
    upsert?: EncontroUpsertWithWhereUniqueWithoutLocalInput | EncontroUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EncontroCreateManyLocalInputEnvelope
    set?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    disconnect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    delete?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    connect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    update?: EncontroUpdateWithWhereUniqueWithoutLocalInput | EncontroUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EncontroUpdateManyWithWhereWithoutLocalInput | EncontroUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EncontroScalarWhereInput | EncontroScalarWhereInput[]
  }

  export type EnderecoUpdateOneRequiredWithoutLocalNestedInput = {
    create?: XOR<EnderecoCreateWithoutLocalInput, EnderecoUncheckedCreateWithoutLocalInput>
    connectOrCreate?: EnderecoCreateOrConnectWithoutLocalInput
    upsert?: EnderecoUpsertWithoutLocalInput
    connect?: EnderecoWhereUniqueInput
    update?: XOR<XOR<EnderecoUpdateToOneWithWhereWithoutLocalInput, EnderecoUpdateWithoutLocalInput>, EnderecoUncheckedUpdateWithoutLocalInput>
  }

  export type EncontroUncheckedUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput> | EncontroCreateWithoutLocalInput[] | EncontroUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EncontroCreateOrConnectWithoutLocalInput | EncontroCreateOrConnectWithoutLocalInput[]
    upsert?: EncontroUpsertWithWhereUniqueWithoutLocalInput | EncontroUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EncontroCreateManyLocalInputEnvelope
    set?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    disconnect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    delete?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    connect?: EncontroWhereUniqueInput | EncontroWhereUniqueInput[]
    update?: EncontroUpdateWithWhereUniqueWithoutLocalInput | EncontroUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EncontroUpdateManyWithWhereWithoutLocalInput | EncontroUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EncontroScalarWhereInput | EncontroScalarWhereInput[]
  }

  export type CarroEncontroCreateNestedManyWithoutCarroInput = {
    create?: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput> | CarroEncontroCreateWithoutCarroInput[] | CarroEncontroUncheckedCreateWithoutCarroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutCarroInput | CarroEncontroCreateOrConnectWithoutCarroInput[]
    createMany?: CarroEncontroCreateManyCarroInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type PessoaCreateNestedOneWithoutPessoaCaronaInput = {
    create?: XOR<PessoaCreateWithoutPessoaCaronaInput, PessoaUncheckedCreateWithoutPessoaCaronaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaCaronaInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaCreateNestedOneWithoutPessoaMotoristaInput = {
    create?: XOR<PessoaCreateWithoutPessoaMotoristaInput, PessoaUncheckedCreateWithoutPessoaMotoristaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaMotoristaInput
    connect?: PessoaWhereUniqueInput
  }

  export type CarroEncontroUncheckedCreateNestedManyWithoutCarroInput = {
    create?: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput> | CarroEncontroCreateWithoutCarroInput[] | CarroEncontroUncheckedCreateWithoutCarroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutCarroInput | CarroEncontroCreateOrConnectWithoutCarroInput[]
    createMany?: CarroEncontroCreateManyCarroInputEnvelope
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
  }

  export type CarroEncontroUpdateManyWithoutCarroNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput> | CarroEncontroCreateWithoutCarroInput[] | CarroEncontroUncheckedCreateWithoutCarroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutCarroInput | CarroEncontroCreateOrConnectWithoutCarroInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutCarroInput | CarroEncontroUpsertWithWhereUniqueWithoutCarroInput[]
    createMany?: CarroEncontroCreateManyCarroInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutCarroInput | CarroEncontroUpdateWithWhereUniqueWithoutCarroInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutCarroInput | CarroEncontroUpdateManyWithWhereWithoutCarroInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type PessoaUpdateOneWithoutPessoaCaronaNestedInput = {
    create?: XOR<PessoaCreateWithoutPessoaCaronaInput, PessoaUncheckedCreateWithoutPessoaCaronaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaCaronaInput
    upsert?: PessoaUpsertWithoutPessoaCaronaInput
    disconnect?: PessoaWhereInput | boolean
    delete?: PessoaWhereInput | boolean
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutPessoaCaronaInput, PessoaUpdateWithoutPessoaCaronaInput>, PessoaUncheckedUpdateWithoutPessoaCaronaInput>
  }

  export type PessoaUpdateOneRequiredWithoutPessoaMotoristaNestedInput = {
    create?: XOR<PessoaCreateWithoutPessoaMotoristaInput, PessoaUncheckedCreateWithoutPessoaMotoristaInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutPessoaMotoristaInput
    upsert?: PessoaUpsertWithoutPessoaMotoristaInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutPessoaMotoristaInput, PessoaUpdateWithoutPessoaMotoristaInput>, PessoaUncheckedUpdateWithoutPessoaMotoristaInput>
  }

  export type CarroEncontroUncheckedUpdateManyWithoutCarroNestedInput = {
    create?: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput> | CarroEncontroCreateWithoutCarroInput[] | CarroEncontroUncheckedCreateWithoutCarroInput[]
    connectOrCreate?: CarroEncontroCreateOrConnectWithoutCarroInput | CarroEncontroCreateOrConnectWithoutCarroInput[]
    upsert?: CarroEncontroUpsertWithWhereUniqueWithoutCarroInput | CarroEncontroUpsertWithWhereUniqueWithoutCarroInput[]
    createMany?: CarroEncontroCreateManyCarroInputEnvelope
    set?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    disconnect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    delete?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    connect?: CarroEncontroWhereUniqueInput | CarroEncontroWhereUniqueInput[]
    update?: CarroEncontroUpdateWithWhereUniqueWithoutCarroInput | CarroEncontroUpdateWithWhereUniqueWithoutCarroInput[]
    updateMany?: CarroEncontroUpdateManyWithWhereWithoutCarroInput | CarroEncontroUpdateManyWithWhereWithoutCarroInput[]
    deleteMany?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
  }

  export type EncontreiroCreateNestedOneWithoutResponsavelCarroExternaInput = {
    create?: XOR<EncontreiroCreateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedCreateWithoutResponsavelCarroExternaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutResponsavelCarroExternaInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type CarroCreateNestedOneWithoutCarroEncontroInput = {
    create?: XOR<CarroCreateWithoutCarroEncontroInput, CarroUncheckedCreateWithoutCarroEncontroInput>
    connectOrCreate?: CarroCreateOrConnectWithoutCarroEncontroInput
    connect?: CarroWhereUniqueInput
  }

  export type EncontroCreateNestedOneWithoutCarroEncontroInput = {
    create?: XOR<EncontroCreateWithoutCarroEncontroInput, EncontroUncheckedCreateWithoutCarroEncontroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutCarroEncontroInput
    connect?: EncontroWhereUniqueInput
  }

  export type EncontristaCreateNestedManyWithoutCarroEncontroInput = {
    create?: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput> | EncontristaCreateWithoutCarroEncontroInput[] | EncontristaUncheckedCreateWithoutCarroEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutCarroEncontroInput | EncontristaCreateOrConnectWithoutCarroEncontroInput[]
    createMany?: EncontristaCreateManyCarroEncontroInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutCarroEncontroInput = {
    create?: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput> | EncontristaCreateWithoutCarroEncontroInput[] | EncontristaUncheckedCreateWithoutCarroEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutCarroEncontroInput | EncontristaCreateOrConnectWithoutCarroEncontroInput[]
    createMany?: EncontristaCreateManyCarroEncontroInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontreiroUpdateOneWithoutResponsavelCarroExternaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedCreateWithoutResponsavelCarroExternaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutResponsavelCarroExternaInput
    upsert?: EncontreiroUpsertWithoutResponsavelCarroExternaInput
    disconnect?: EncontreiroWhereInput | boolean
    delete?: EncontreiroWhereInput | boolean
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutResponsavelCarroExternaInput, EncontreiroUpdateWithoutResponsavelCarroExternaInput>, EncontreiroUncheckedUpdateWithoutResponsavelCarroExternaInput>
  }

  export type CarroUpdateOneRequiredWithoutCarroEncontroNestedInput = {
    create?: XOR<CarroCreateWithoutCarroEncontroInput, CarroUncheckedCreateWithoutCarroEncontroInput>
    connectOrCreate?: CarroCreateOrConnectWithoutCarroEncontroInput
    upsert?: CarroUpsertWithoutCarroEncontroInput
    connect?: CarroWhereUniqueInput
    update?: XOR<XOR<CarroUpdateToOneWithWhereWithoutCarroEncontroInput, CarroUpdateWithoutCarroEncontroInput>, CarroUncheckedUpdateWithoutCarroEncontroInput>
  }

  export type EncontroUpdateOneRequiredWithoutCarroEncontroNestedInput = {
    create?: XOR<EncontroCreateWithoutCarroEncontroInput, EncontroUncheckedCreateWithoutCarroEncontroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutCarroEncontroInput
    upsert?: EncontroUpsertWithoutCarroEncontroInput
    connect?: EncontroWhereUniqueInput
    update?: XOR<XOR<EncontroUpdateToOneWithWhereWithoutCarroEncontroInput, EncontroUpdateWithoutCarroEncontroInput>, EncontroUncheckedUpdateWithoutCarroEncontroInput>
  }

  export type EncontristaUpdateManyWithoutCarroEncontroNestedInput = {
    create?: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput> | EncontristaCreateWithoutCarroEncontroInput[] | EncontristaUncheckedCreateWithoutCarroEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutCarroEncontroInput | EncontristaCreateOrConnectWithoutCarroEncontroInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutCarroEncontroInput | EncontristaUpsertWithWhereUniqueWithoutCarroEncontroInput[]
    createMany?: EncontristaCreateManyCarroEncontroInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutCarroEncontroInput | EncontristaUpdateWithWhereUniqueWithoutCarroEncontroInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutCarroEncontroInput | EncontristaUpdateManyWithWhereWithoutCarroEncontroInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutCarroEncontroNestedInput = {
    create?: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput> | EncontristaCreateWithoutCarroEncontroInput[] | EncontristaUncheckedCreateWithoutCarroEncontroInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutCarroEncontroInput | EncontristaCreateOrConnectWithoutCarroEncontroInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutCarroEncontroInput | EncontristaUpsertWithWhereUniqueWithoutCarroEncontroInput[]
    createMany?: EncontristaCreateManyCarroEncontroInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutCarroEncontroInput | EncontristaUpdateWithWhereUniqueWithoutCarroEncontroInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutCarroEncontroInput | EncontristaUpdateManyWithWhereWithoutCarroEncontroInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaCreateNestedOneWithoutResponsavelExternaInput = {
    create?: XOR<EncontristaCreateWithoutResponsavelExternaInput, EncontristaUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutResponsavelExternaInput
    connect?: EncontristaWhereUniqueInput
  }

  export type EncontroCreateNestedOneWithoutResponsavelExternaInput = {
    create?: XOR<EncontroCreateWithoutResponsavelExternaInput, EncontroUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutResponsavelExternaInput
    connect?: EncontroWhereUniqueInput
  }

  export type EncontreiroCreateNestedOneWithoutResponsavelExternaInput = {
    create?: XOR<EncontreiroCreateWithoutResponsavelExternaInput, EncontreiroUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutResponsavelExternaInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type EncontristaUpdateOneRequiredWithoutResponsavelExternaNestedInput = {
    create?: XOR<EncontristaCreateWithoutResponsavelExternaInput, EncontristaUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontristaCreateOrConnectWithoutResponsavelExternaInput
    upsert?: EncontristaUpsertWithoutResponsavelExternaInput
    connect?: EncontristaWhereUniqueInput
    update?: XOR<XOR<EncontristaUpdateToOneWithWhereWithoutResponsavelExternaInput, EncontristaUpdateWithoutResponsavelExternaInput>, EncontristaUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type EncontroUpdateOneRequiredWithoutResponsavelExternaNestedInput = {
    create?: XOR<EncontroCreateWithoutResponsavelExternaInput, EncontroUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutResponsavelExternaInput
    upsert?: EncontroUpsertWithoutResponsavelExternaInput
    connect?: EncontroWhereUniqueInput
    update?: XOR<XOR<EncontroUpdateToOneWithWhereWithoutResponsavelExternaInput, EncontroUpdateWithoutResponsavelExternaInput>, EncontroUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type EncontreiroUpdateOneRequiredWithoutResponsavelExternaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutResponsavelExternaInput, EncontreiroUncheckedCreateWithoutResponsavelExternaInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutResponsavelExternaInput
    upsert?: EncontreiroUpsertWithoutResponsavelExternaInput
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutResponsavelExternaInput, EncontreiroUpdateWithoutResponsavelExternaInput>, EncontreiroUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type PessoaCreateNestedOneWithoutCartasDigitaisInput = {
    create?: XOR<PessoaCreateWithoutCartasDigitaisInput, PessoaUncheckedCreateWithoutCartasDigitaisInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutCartasDigitaisInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutCartasDigitaisNestedInput = {
    create?: XOR<PessoaCreateWithoutCartasDigitaisInput, PessoaUncheckedCreateWithoutCartasDigitaisInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutCartasDigitaisInput
    upsert?: PessoaUpsertWithoutCartasDigitaisInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutCartasDigitaisInput, PessoaUpdateWithoutCartasDigitaisInput>, PessoaUncheckedUpdateWithoutCartasDigitaisInput>
  }

  export type EncontreiroCreateNestedOneWithoutListaPreferenciasInput = {
    create?: XOR<EncontreiroCreateWithoutListaPreferenciasInput, EncontreiroUncheckedCreateWithoutListaPreferenciasInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutListaPreferenciasInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type DomainEquipesCreateNestedOneWithoutListaPreferenciaInput = {
    create?: XOR<DomainEquipesCreateWithoutListaPreferenciaInput, DomainEquipesUncheckedCreateWithoutListaPreferenciaInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutListaPreferenciaInput
    connect?: DomainEquipesWhereUniqueInput
  }

  export type EncontreiroUpdateOneRequiredWithoutListaPreferenciasNestedInput = {
    create?: XOR<EncontreiroCreateWithoutListaPreferenciasInput, EncontreiroUncheckedCreateWithoutListaPreferenciasInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutListaPreferenciasInput
    upsert?: EncontreiroUpsertWithoutListaPreferenciasInput
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutListaPreferenciasInput, EncontreiroUpdateWithoutListaPreferenciasInput>, EncontreiroUncheckedUpdateWithoutListaPreferenciasInput>
  }

  export type DomainEquipesUpdateOneRequiredWithoutListaPreferenciaNestedInput = {
    create?: XOR<DomainEquipesCreateWithoutListaPreferenciaInput, DomainEquipesUncheckedCreateWithoutListaPreferenciaInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutListaPreferenciaInput
    upsert?: DomainEquipesUpsertWithoutListaPreferenciaInput
    connect?: DomainEquipesWhereUniqueInput
    update?: XOR<XOR<DomainEquipesUpdateToOneWithWhereWithoutListaPreferenciaInput, DomainEquipesUpdateWithoutListaPreferenciaInput>, DomainEquipesUncheckedUpdateWithoutListaPreferenciaInput>
  }

  export type EncontroCreateNestedOneWithoutEquipeEncontroInput = {
    create?: XOR<EncontroCreateWithoutEquipeEncontroInput, EncontroUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutEquipeEncontroInput
    connect?: EncontroWhereUniqueInput
  }

  export type DomainEquipesCreateNestedOneWithoutEquipeEncontroInput = {
    create?: XOR<DomainEquipesCreateWithoutEquipeEncontroInput, DomainEquipesUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutEquipeEncontroInput
    connect?: DomainEquipesWhereUniqueInput
  }

  export type EncontreiroCreateNestedOneWithoutEquipeEncontroInput = {
    create?: XOR<EncontreiroCreateWithoutEquipeEncontroInput, EncontreiroUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEquipeEncontroInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type EncontroUpdateOneRequiredWithoutEquipeEncontroNestedInput = {
    create?: XOR<EncontroCreateWithoutEquipeEncontroInput, EncontroUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: EncontroCreateOrConnectWithoutEquipeEncontroInput
    upsert?: EncontroUpsertWithoutEquipeEncontroInput
    connect?: EncontroWhereUniqueInput
    update?: XOR<XOR<EncontroUpdateToOneWithWhereWithoutEquipeEncontroInput, EncontroUpdateWithoutEquipeEncontroInput>, EncontroUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type DomainEquipesUpdateOneRequiredWithoutEquipeEncontroNestedInput = {
    create?: XOR<DomainEquipesCreateWithoutEquipeEncontroInput, DomainEquipesUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutEquipeEncontroInput
    upsert?: DomainEquipesUpsertWithoutEquipeEncontroInput
    connect?: DomainEquipesWhereUniqueInput
    update?: XOR<XOR<DomainEquipesUpdateToOneWithWhereWithoutEquipeEncontroInput, DomainEquipesUpdateWithoutEquipeEncontroInput>, DomainEquipesUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type EncontreiroUpdateOneRequiredWithoutEquipeEncontroNestedInput = {
    create?: XOR<EncontreiroCreateWithoutEquipeEncontroInput, EncontreiroUncheckedCreateWithoutEquipeEncontroInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEquipeEncontroInput
    upsert?: EncontreiroUpsertWithoutEquipeEncontroInput
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutEquipeEncontroInput, EncontreiroUpdateWithoutEquipeEncontroInput>, EncontreiroUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type EncontreiroCreateNestedOneWithoutEquipeMontagemInput = {
    create?: XOR<EncontreiroCreateWithoutEquipeMontagemInput, EncontreiroUncheckedCreateWithoutEquipeMontagemInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEquipeMontagemInput
    connect?: EncontreiroWhereUniqueInput
  }

  export type DomainEquipesCreateNestedOneWithoutEquipeMontagemInput = {
    create?: XOR<DomainEquipesCreateWithoutEquipeMontagemInput, DomainEquipesUncheckedCreateWithoutEquipeMontagemInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutEquipeMontagemInput
    connect?: DomainEquipesWhereUniqueInput
  }

  export type EncontreiroUpdateOneRequiredWithoutEquipeMontagemNestedInput = {
    create?: XOR<EncontreiroCreateWithoutEquipeMontagemInput, EncontreiroUncheckedCreateWithoutEquipeMontagemInput>
    connectOrCreate?: EncontreiroCreateOrConnectWithoutEquipeMontagemInput
    upsert?: EncontreiroUpsertWithoutEquipeMontagemInput
    connect?: EncontreiroWhereUniqueInput
    update?: XOR<XOR<EncontreiroUpdateToOneWithWhereWithoutEquipeMontagemInput, EncontreiroUpdateWithoutEquipeMontagemInput>, EncontreiroUncheckedUpdateWithoutEquipeMontagemInput>
  }

  export type DomainEquipesUpdateOneRequiredWithoutEquipeMontagemNestedInput = {
    create?: XOR<DomainEquipesCreateWithoutEquipeMontagemInput, DomainEquipesUncheckedCreateWithoutEquipeMontagemInput>
    connectOrCreate?: DomainEquipesCreateOrConnectWithoutEquipeMontagemInput
    upsert?: DomainEquipesUpsertWithoutEquipeMontagemInput
    connect?: DomainEquipesWhereUniqueInput
    update?: XOR<XOR<DomainEquipesUpdateToOneWithWhereWithoutEquipeMontagemInput, DomainEquipesUpdateWithoutEquipeMontagemInput>, DomainEquipesUncheckedUpdateWithoutEquipeMontagemInput>
  }

  export type EncontristaCreateNestedManyWithoutStatusInput = {
    create?: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput> | EncontristaCreateWithoutStatusInput[] | EncontristaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusInput | EncontristaCreateOrConnectWithoutStatusInput[]
    createMany?: EncontristaCreateManyStatusInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput> | EncontristaCreateWithoutStatusInput[] | EncontristaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusInput | EncontristaCreateOrConnectWithoutStatusInput[]
    createMany?: EncontristaCreateManyStatusInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUpdateManyWithoutStatusNestedInput = {
    create?: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput> | EncontristaCreateWithoutStatusInput[] | EncontristaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusInput | EncontristaCreateOrConnectWithoutStatusInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutStatusInput | EncontristaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: EncontristaCreateManyStatusInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutStatusInput | EncontristaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutStatusInput | EncontristaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput> | EncontristaCreateWithoutStatusInput[] | EncontristaUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusInput | EncontristaCreateOrConnectWithoutStatusInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutStatusInput | EncontristaUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: EncontristaCreateManyStatusInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutStatusInput | EncontristaUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutStatusInput | EncontristaUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaCreateNestedManyWithoutReligiaoInput = {
    create?: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput> | EncontristaCreateWithoutReligiaoInput[] | EncontristaUncheckedCreateWithoutReligiaoInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutReligiaoInput | EncontristaCreateOrConnectWithoutReligiaoInput[]
    createMany?: EncontristaCreateManyReligiaoInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutReligiaoInput = {
    create?: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput> | EncontristaCreateWithoutReligiaoInput[] | EncontristaUncheckedCreateWithoutReligiaoInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutReligiaoInput | EncontristaCreateOrConnectWithoutReligiaoInput[]
    createMany?: EncontristaCreateManyReligiaoInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUpdateManyWithoutReligiaoNestedInput = {
    create?: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput> | EncontristaCreateWithoutReligiaoInput[] | EncontristaUncheckedCreateWithoutReligiaoInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutReligiaoInput | EncontristaCreateOrConnectWithoutReligiaoInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutReligiaoInput | EncontristaUpsertWithWhereUniqueWithoutReligiaoInput[]
    createMany?: EncontristaCreateManyReligiaoInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutReligiaoInput | EncontristaUpdateWithWhereUniqueWithoutReligiaoInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutReligiaoInput | EncontristaUpdateManyWithWhereWithoutReligiaoInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutReligiaoNestedInput = {
    create?: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput> | EncontristaCreateWithoutReligiaoInput[] | EncontristaUncheckedCreateWithoutReligiaoInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutReligiaoInput | EncontristaCreateOrConnectWithoutReligiaoInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutReligiaoInput | EncontristaUpsertWithWhereUniqueWithoutReligiaoInput[]
    createMany?: EncontristaCreateManyReligiaoInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutReligiaoInput | EncontristaUpdateWithWhereUniqueWithoutReligiaoInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutReligiaoInput | EncontristaUpdateManyWithWhereWithoutReligiaoInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaCreateNestedManyWithoutMoraComInput = {
    create?: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput> | EncontristaCreateWithoutMoraComInput[] | EncontristaUncheckedCreateWithoutMoraComInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutMoraComInput | EncontristaCreateOrConnectWithoutMoraComInput[]
    createMany?: EncontristaCreateManyMoraComInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutMoraComInput = {
    create?: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput> | EncontristaCreateWithoutMoraComInput[] | EncontristaUncheckedCreateWithoutMoraComInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutMoraComInput | EncontristaCreateOrConnectWithoutMoraComInput[]
    createMany?: EncontristaCreateManyMoraComInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUpdateManyWithoutMoraComNestedInput = {
    create?: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput> | EncontristaCreateWithoutMoraComInput[] | EncontristaUncheckedCreateWithoutMoraComInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutMoraComInput | EncontristaCreateOrConnectWithoutMoraComInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutMoraComInput | EncontristaUpsertWithWhereUniqueWithoutMoraComInput[]
    createMany?: EncontristaCreateManyMoraComInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutMoraComInput | EncontristaUpdateWithWhereUniqueWithoutMoraComInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutMoraComInput | EncontristaUpdateManyWithWhereWithoutMoraComInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutMoraComNestedInput = {
    create?: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput> | EncontristaCreateWithoutMoraComInput[] | EncontristaUncheckedCreateWithoutMoraComInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutMoraComInput | EncontristaCreateOrConnectWithoutMoraComInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutMoraComInput | EncontristaUpsertWithWhereUniqueWithoutMoraComInput[]
    createMany?: EncontristaCreateManyMoraComInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutMoraComInput | EncontristaUpdateWithWhereUniqueWithoutMoraComInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutMoraComInput | EncontristaUpdateManyWithWhereWithoutMoraComInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaCreateNestedManyWithoutStatusPaisInput = {
    create?: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput> | EncontristaCreateWithoutStatusPaisInput[] | EncontristaUncheckedCreateWithoutStatusPaisInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusPaisInput | EncontristaCreateOrConnectWithoutStatusPaisInput[]
    createMany?: EncontristaCreateManyStatusPaisInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUncheckedCreateNestedManyWithoutStatusPaisInput = {
    create?: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput> | EncontristaCreateWithoutStatusPaisInput[] | EncontristaUncheckedCreateWithoutStatusPaisInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusPaisInput | EncontristaCreateOrConnectWithoutStatusPaisInput[]
    createMany?: EncontristaCreateManyStatusPaisInputEnvelope
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
  }

  export type EncontristaUpdateManyWithoutStatusPaisNestedInput = {
    create?: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput> | EncontristaCreateWithoutStatusPaisInput[] | EncontristaUncheckedCreateWithoutStatusPaisInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusPaisInput | EncontristaCreateOrConnectWithoutStatusPaisInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutStatusPaisInput | EncontristaUpsertWithWhereUniqueWithoutStatusPaisInput[]
    createMany?: EncontristaCreateManyStatusPaisInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutStatusPaisInput | EncontristaUpdateWithWhereUniqueWithoutStatusPaisInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutStatusPaisInput | EncontristaUpdateManyWithWhereWithoutStatusPaisInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontristaUncheckedUpdateManyWithoutStatusPaisNestedInput = {
    create?: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput> | EncontristaCreateWithoutStatusPaisInput[] | EncontristaUncheckedCreateWithoutStatusPaisInput[]
    connectOrCreate?: EncontristaCreateOrConnectWithoutStatusPaisInput | EncontristaCreateOrConnectWithoutStatusPaisInput[]
    upsert?: EncontristaUpsertWithWhereUniqueWithoutStatusPaisInput | EncontristaUpsertWithWhereUniqueWithoutStatusPaisInput[]
    createMany?: EncontristaCreateManyStatusPaisInputEnvelope
    set?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    disconnect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    delete?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    connect?: EncontristaWhereUniqueInput | EncontristaWhereUniqueInput[]
    update?: EncontristaUpdateWithWhereUniqueWithoutStatusPaisInput | EncontristaUpdateWithWhereUniqueWithoutStatusPaisInput[]
    updateMany?: EncontristaUpdateManyWithWhereWithoutStatusPaisInput | EncontristaUpdateManyWithWhereWithoutStatusPaisInput[]
    deleteMany?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
  }

  export type EncontreiroCreateNestedManyWithoutTamanhoCamisaInput = {
    create?: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput> | EncontreiroCreateWithoutTamanhoCamisaInput[] | EncontreiroUncheckedCreateWithoutTamanhoCamisaInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutTamanhoCamisaInput | EncontreiroCreateOrConnectWithoutTamanhoCamisaInput[]
    createMany?: EncontreiroCreateManyTamanhoCamisaInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EncontreiroUncheckedCreateNestedManyWithoutTamanhoCamisaInput = {
    create?: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput> | EncontreiroCreateWithoutTamanhoCamisaInput[] | EncontreiroUncheckedCreateWithoutTamanhoCamisaInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutTamanhoCamisaInput | EncontreiroCreateOrConnectWithoutTamanhoCamisaInput[]
    createMany?: EncontreiroCreateManyTamanhoCamisaInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EnumValue_TamanhoCamisaFieldUpdateOperationsInput = {
    set?: $Enums.Value_TamanhoCamisa
  }

  export type EncontreiroUpdateManyWithoutTamanhoCamisaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput> | EncontreiroCreateWithoutTamanhoCamisaInput[] | EncontreiroUncheckedCreateWithoutTamanhoCamisaInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutTamanhoCamisaInput | EncontreiroCreateOrConnectWithoutTamanhoCamisaInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutTamanhoCamisaInput | EncontreiroUpsertWithWhereUniqueWithoutTamanhoCamisaInput[]
    createMany?: EncontreiroCreateManyTamanhoCamisaInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutTamanhoCamisaInput | EncontreiroUpdateWithWhereUniqueWithoutTamanhoCamisaInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutTamanhoCamisaInput | EncontreiroUpdateManyWithWhereWithoutTamanhoCamisaInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EncontreiroUncheckedUpdateManyWithoutTamanhoCamisaNestedInput = {
    create?: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput> | EncontreiroCreateWithoutTamanhoCamisaInput[] | EncontreiroUncheckedCreateWithoutTamanhoCamisaInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutTamanhoCamisaInput | EncontreiroCreateOrConnectWithoutTamanhoCamisaInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutTamanhoCamisaInput | EncontreiroUpsertWithWhereUniqueWithoutTamanhoCamisaInput[]
    createMany?: EncontreiroCreateManyTamanhoCamisaInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutTamanhoCamisaInput | EncontreiroUpdateWithWhereUniqueWithoutTamanhoCamisaInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutTamanhoCamisaInput | EncontreiroUpdateManyWithWhereWithoutTamanhoCamisaInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type CirculoCreateNestedManyWithoutCorCirculoInput = {
    create?: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput> | CirculoCreateWithoutCorCirculoInput[] | CirculoUncheckedCreateWithoutCorCirculoInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutCorCirculoInput | CirculoCreateOrConnectWithoutCorCirculoInput[]
    createMany?: CirculoCreateManyCorCirculoInputEnvelope
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
  }

  export type CirculoUncheckedCreateNestedManyWithoutCorCirculoInput = {
    create?: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput> | CirculoCreateWithoutCorCirculoInput[] | CirculoUncheckedCreateWithoutCorCirculoInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutCorCirculoInput | CirculoCreateOrConnectWithoutCorCirculoInput[]
    createMany?: CirculoCreateManyCorCirculoInputEnvelope
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
  }

  export type CirculoUpdateManyWithoutCorCirculoNestedInput = {
    create?: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput> | CirculoCreateWithoutCorCirculoInput[] | CirculoUncheckedCreateWithoutCorCirculoInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutCorCirculoInput | CirculoCreateOrConnectWithoutCorCirculoInput[]
    upsert?: CirculoUpsertWithWhereUniqueWithoutCorCirculoInput | CirculoUpsertWithWhereUniqueWithoutCorCirculoInput[]
    createMany?: CirculoCreateManyCorCirculoInputEnvelope
    set?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    disconnect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    delete?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    update?: CirculoUpdateWithWhereUniqueWithoutCorCirculoInput | CirculoUpdateWithWhereUniqueWithoutCorCirculoInput[]
    updateMany?: CirculoUpdateManyWithWhereWithoutCorCirculoInput | CirculoUpdateManyWithWhereWithoutCorCirculoInput[]
    deleteMany?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
  }

  export type CirculoUncheckedUpdateManyWithoutCorCirculoNestedInput = {
    create?: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput> | CirculoCreateWithoutCorCirculoInput[] | CirculoUncheckedCreateWithoutCorCirculoInput[]
    connectOrCreate?: CirculoCreateOrConnectWithoutCorCirculoInput | CirculoCreateOrConnectWithoutCorCirculoInput[]
    upsert?: CirculoUpsertWithWhereUniqueWithoutCorCirculoInput | CirculoUpsertWithWhereUniqueWithoutCorCirculoInput[]
    createMany?: CirculoCreateManyCorCirculoInputEnvelope
    set?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    disconnect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    delete?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    connect?: CirculoWhereUniqueInput | CirculoWhereUniqueInput[]
    update?: CirculoUpdateWithWhereUniqueWithoutCorCirculoInput | CirculoUpdateWithWhereUniqueWithoutCorCirculoInput[]
    updateMany?: CirculoUpdateManyWithWhereWithoutCorCirculoInput | CirculoUpdateManyWithWhereWithoutCorCirculoInput[]
    deleteMany?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
  }

  export type EncontreiroCreateNestedManyWithoutDisponibilidadeInput = {
    create?: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput> | EncontreiroCreateWithoutDisponibilidadeInput[] | EncontreiroUncheckedCreateWithoutDisponibilidadeInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutDisponibilidadeInput | EncontreiroCreateOrConnectWithoutDisponibilidadeInput[]
    createMany?: EncontreiroCreateManyDisponibilidadeInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EncontreiroUncheckedCreateNestedManyWithoutDisponibilidadeInput = {
    create?: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput> | EncontreiroCreateWithoutDisponibilidadeInput[] | EncontreiroUncheckedCreateWithoutDisponibilidadeInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutDisponibilidadeInput | EncontreiroCreateOrConnectWithoutDisponibilidadeInput[]
    createMany?: EncontreiroCreateManyDisponibilidadeInputEnvelope
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
  }

  export type EnumValue_DisponibilidadeFieldUpdateOperationsInput = {
    set?: $Enums.Value_Disponibilidade
  }

  export type EncontreiroUpdateManyWithoutDisponibilidadeNestedInput = {
    create?: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput> | EncontreiroCreateWithoutDisponibilidadeInput[] | EncontreiroUncheckedCreateWithoutDisponibilidadeInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutDisponibilidadeInput | EncontreiroCreateOrConnectWithoutDisponibilidadeInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutDisponibilidadeInput | EncontreiroUpsertWithWhereUniqueWithoutDisponibilidadeInput[]
    createMany?: EncontreiroCreateManyDisponibilidadeInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutDisponibilidadeInput | EncontreiroUpdateWithWhereUniqueWithoutDisponibilidadeInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutDisponibilidadeInput | EncontreiroUpdateManyWithWhereWithoutDisponibilidadeInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EncontreiroUncheckedUpdateManyWithoutDisponibilidadeNestedInput = {
    create?: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput> | EncontreiroCreateWithoutDisponibilidadeInput[] | EncontreiroUncheckedCreateWithoutDisponibilidadeInput[]
    connectOrCreate?: EncontreiroCreateOrConnectWithoutDisponibilidadeInput | EncontreiroCreateOrConnectWithoutDisponibilidadeInput[]
    upsert?: EncontreiroUpsertWithWhereUniqueWithoutDisponibilidadeInput | EncontreiroUpsertWithWhereUniqueWithoutDisponibilidadeInput[]
    createMany?: EncontreiroCreateManyDisponibilidadeInputEnvelope
    set?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    disconnect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    delete?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    connect?: EncontreiroWhereUniqueInput | EncontreiroWhereUniqueInput[]
    update?: EncontreiroUpdateWithWhereUniqueWithoutDisponibilidadeInput | EncontreiroUpdateWithWhereUniqueWithoutDisponibilidadeInput[]
    updateMany?: EncontreiroUpdateManyWithWhereWithoutDisponibilidadeInput | EncontreiroUpdateManyWithWhereWithoutDisponibilidadeInput[]
    deleteMany?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
  }

  export type EquipeEncontroCreateNestedManyWithoutEquipeInput = {
    create?: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput> | EquipeEncontroCreateWithoutEquipeInput[] | EquipeEncontroUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEquipeInput | EquipeEncontroCreateOrConnectWithoutEquipeInput[]
    createMany?: EquipeEncontroCreateManyEquipeInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type EquipeMontagemCreateNestedManyWithoutEquipeInput = {
    create?: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput> | EquipeMontagemCreateWithoutEquipeInput[] | EquipeMontagemUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEquipeInput | EquipeMontagemCreateOrConnectWithoutEquipeInput[]
    createMany?: EquipeMontagemCreateManyEquipeInputEnvelope
    connect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
  }

  export type ListaPreferenciaCreateNestedManyWithoutEquipeInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput> | ListaPreferenciaCreateWithoutEquipeInput[] | ListaPreferenciaUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEquipeInput | ListaPreferenciaCreateOrConnectWithoutEquipeInput[]
    createMany?: ListaPreferenciaCreateManyEquipeInputEnvelope
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
  }

  export type EquipeEncontroUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput> | EquipeEncontroCreateWithoutEquipeInput[] | EquipeEncontroUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEquipeInput | EquipeEncontroCreateOrConnectWithoutEquipeInput[]
    createMany?: EquipeEncontroCreateManyEquipeInputEnvelope
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
  }

  export type EquipeMontagemUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput> | EquipeMontagemCreateWithoutEquipeInput[] | EquipeMontagemUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEquipeInput | EquipeMontagemCreateOrConnectWithoutEquipeInput[]
    createMany?: EquipeMontagemCreateManyEquipeInputEnvelope
    connect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
  }

  export type ListaPreferenciaUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput> | ListaPreferenciaCreateWithoutEquipeInput[] | ListaPreferenciaUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEquipeInput | ListaPreferenciaCreateOrConnectWithoutEquipeInput[]
    createMany?: ListaPreferenciaCreateManyEquipeInputEnvelope
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
  }

  export type EquipeEncontroUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput> | EquipeEncontroCreateWithoutEquipeInput[] | EquipeEncontroUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEquipeInput | EquipeEncontroCreateOrConnectWithoutEquipeInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEquipeInput | EquipeEncontroUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: EquipeEncontroCreateManyEquipeInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEquipeInput | EquipeEncontroUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEquipeInput | EquipeEncontroUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type EquipeMontagemUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput> | EquipeMontagemCreateWithoutEquipeInput[] | EquipeMontagemUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEquipeInput | EquipeMontagemCreateOrConnectWithoutEquipeInput[]
    upsert?: EquipeMontagemUpsertWithWhereUniqueWithoutEquipeInput | EquipeMontagemUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: EquipeMontagemCreateManyEquipeInputEnvelope
    set?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    disconnect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    delete?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    connect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    update?: EquipeMontagemUpdateWithWhereUniqueWithoutEquipeInput | EquipeMontagemUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: EquipeMontagemUpdateManyWithWhereWithoutEquipeInput | EquipeMontagemUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: EquipeMontagemScalarWhereInput | EquipeMontagemScalarWhereInput[]
  }

  export type ListaPreferenciaUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput> | ListaPreferenciaCreateWithoutEquipeInput[] | ListaPreferenciaUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEquipeInput | ListaPreferenciaCreateOrConnectWithoutEquipeInput[]
    upsert?: ListaPreferenciaUpsertWithWhereUniqueWithoutEquipeInput | ListaPreferenciaUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: ListaPreferenciaCreateManyEquipeInputEnvelope
    set?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    disconnect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    delete?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    update?: ListaPreferenciaUpdateWithWhereUniqueWithoutEquipeInput | ListaPreferenciaUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: ListaPreferenciaUpdateManyWithWhereWithoutEquipeInput | ListaPreferenciaUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput> | EquipeEncontroCreateWithoutEquipeInput[] | EquipeEncontroUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeEncontroCreateOrConnectWithoutEquipeInput | EquipeEncontroCreateOrConnectWithoutEquipeInput[]
    upsert?: EquipeEncontroUpsertWithWhereUniqueWithoutEquipeInput | EquipeEncontroUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: EquipeEncontroCreateManyEquipeInputEnvelope
    set?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    disconnect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    delete?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    connect?: EquipeEncontroWhereUniqueInput | EquipeEncontroWhereUniqueInput[]
    update?: EquipeEncontroUpdateWithWhereUniqueWithoutEquipeInput | EquipeEncontroUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: EquipeEncontroUpdateManyWithWhereWithoutEquipeInput | EquipeEncontroUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
  }

  export type EquipeMontagemUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput> | EquipeMontagemCreateWithoutEquipeInput[] | EquipeMontagemUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: EquipeMontagemCreateOrConnectWithoutEquipeInput | EquipeMontagemCreateOrConnectWithoutEquipeInput[]
    upsert?: EquipeMontagemUpsertWithWhereUniqueWithoutEquipeInput | EquipeMontagemUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: EquipeMontagemCreateManyEquipeInputEnvelope
    set?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    disconnect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    delete?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    connect?: EquipeMontagemWhereUniqueInput | EquipeMontagemWhereUniqueInput[]
    update?: EquipeMontagemUpdateWithWhereUniqueWithoutEquipeInput | EquipeMontagemUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: EquipeMontagemUpdateManyWithWhereWithoutEquipeInput | EquipeMontagemUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: EquipeMontagemScalarWhereInput | EquipeMontagemScalarWhereInput[]
  }

  export type ListaPreferenciaUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput> | ListaPreferenciaCreateWithoutEquipeInput[] | ListaPreferenciaUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: ListaPreferenciaCreateOrConnectWithoutEquipeInput | ListaPreferenciaCreateOrConnectWithoutEquipeInput[]
    upsert?: ListaPreferenciaUpsertWithWhereUniqueWithoutEquipeInput | ListaPreferenciaUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: ListaPreferenciaCreateManyEquipeInputEnvelope
    set?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    disconnect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    delete?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    connect?: ListaPreferenciaWhereUniqueInput | ListaPreferenciaWhereUniqueInput[]
    update?: ListaPreferenciaUpdateWithWhereUniqueWithoutEquipeInput | ListaPreferenciaUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: ListaPreferenciaUpdateManyWithWhereWithoutEquipeInput | ListaPreferenciaUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
  }

  export type PessoaCreateNestedOneWithoutAccountsInput = {
    create?: XOR<PessoaCreateWithoutAccountsInput, PessoaUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutAccountsInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<PessoaCreateWithoutAccountsInput, PessoaUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutAccountsInput
    upsert?: PessoaUpsertWithoutAccountsInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutAccountsInput, PessoaUpdateWithoutAccountsInput>, PessoaUncheckedUpdateWithoutAccountsInput>
  }

  export type PessoaCreateNestedOneWithoutSessionsInput = {
    create?: XOR<PessoaCreateWithoutSessionsInput, PessoaUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutSessionsInput
    connect?: PessoaWhereUniqueInput
  }

  export type PessoaUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<PessoaCreateWithoutSessionsInput, PessoaUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: PessoaCreateOrConnectWithoutSessionsInput
    upsert?: PessoaUpsertWithoutSessionsInput
    connect?: PessoaWhereUniqueInput
    update?: XOR<XOR<PessoaUpdateToOneWithWhereWithoutSessionsInput, PessoaUpdateWithoutSessionsInput>, PessoaUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumValue_StatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Status | EnumValue_StatusFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusFilter<$PrismaModel> | $Enums.Value_Status
  }

  export type NestedEnumValue_ReligiaoFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Religiao | EnumValue_ReligiaoFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_ReligiaoFilter<$PrismaModel> | $Enums.Value_Religiao
  }

  export type NestedEnumValue_MoraComFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_MoraCom | EnumValue_MoraComFieldRefInput<$PrismaModel>
    in?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_MoraComFilter<$PrismaModel> | $Enums.Value_MoraCom
  }

  export type NestedEnumValue_StatusPaisFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_StatusPais | EnumValue_StatusPaisFieldRefInput<$PrismaModel>
    in?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusPaisFilter<$PrismaModel> | $Enums.Value_StatusPais
  }

  export type NestedEnumValue_StatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Status | EnumValue_StatusFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Status[] | ListEnumValue_StatusFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusWithAggregatesFilter<$PrismaModel> | $Enums.Value_Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_StatusFilter<$PrismaModel>
    _max?: NestedEnumValue_StatusFilter<$PrismaModel>
  }

  export type NestedEnumValue_ReligiaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Religiao | EnumValue_ReligiaoFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Religiao[] | ListEnumValue_ReligiaoFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_ReligiaoWithAggregatesFilter<$PrismaModel> | $Enums.Value_Religiao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_ReligiaoFilter<$PrismaModel>
    _max?: NestedEnumValue_ReligiaoFilter<$PrismaModel>
  }

  export type NestedEnumValue_MoraComWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_MoraCom | EnumValue_MoraComFieldRefInput<$PrismaModel>
    in?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_MoraCom[] | ListEnumValue_MoraComFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_MoraComWithAggregatesFilter<$PrismaModel> | $Enums.Value_MoraCom
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_MoraComFilter<$PrismaModel>
    _max?: NestedEnumValue_MoraComFilter<$PrismaModel>
  }

  export type NestedEnumValue_StatusPaisWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_StatusPais | EnumValue_StatusPaisFieldRefInput<$PrismaModel>
    in?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_StatusPais[] | ListEnumValue_StatusPaisFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_StatusPaisWithAggregatesFilter<$PrismaModel> | $Enums.Value_StatusPais
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_StatusPaisFilter<$PrismaModel>
    _max?: NestedEnumValue_StatusPaisFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa | null
  }

  export type NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel> | $Enums.Value_Disponibilidade | null
  }

  export type NestedEnumStatusEncontreiroNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEncontreiro | EnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel> | $Enums.StatusEncontreiro | null
  }

  export type NestedEnumValue_TamanhoCamisaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_TamanhoCamisaNullableWithAggregatesFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel>
    _max?: NestedEnumValue_TamanhoCamisaNullableFilter<$PrismaModel>
  }

  export type NestedEnumValue_DisponibilidadeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumValue_DisponibilidadeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Value_Disponibilidade | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel>
    _max?: NestedEnumValue_DisponibilidadeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusEncontreiroNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusEncontreiro | EnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    in?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StatusEncontreiro[] | ListEnumStatusEncontreiroFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusEncontreiroNullableWithAggregatesFilter<$PrismaModel> | $Enums.StatusEncontreiro | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusEncontreiroNullableFilter<$PrismaModel>
  }

  export type NestedEnumValue_TamanhoCamisaFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa
  }

  export type NestedEnumValue_TamanhoCamisaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_TamanhoCamisa | EnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    in?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_TamanhoCamisa[] | ListEnumValue_TamanhoCamisaFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_TamanhoCamisaWithAggregatesFilter<$PrismaModel> | $Enums.Value_TamanhoCamisa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel>
    _max?: NestedEnumValue_TamanhoCamisaFilter<$PrismaModel>
  }

  export type NestedEnumValue_DisponibilidadeFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel> | $Enums.Value_Disponibilidade
  }

  export type NestedEnumValue_DisponibilidadeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Value_Disponibilidade | EnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    in?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Value_Disponibilidade[] | ListEnumValue_DisponibilidadeFieldRefInput<$PrismaModel>
    not?: NestedEnumValue_DisponibilidadeWithAggregatesFilter<$PrismaModel> | $Enums.Value_Disponibilidade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel>
    _max?: NestedEnumValue_DisponibilidadeFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CarroCreateWithoutPessoaCaronaInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    carroEncontro?: CarroEncontroCreateNestedManyWithoutCarroInput
    pessoaMotorista: PessoaCreateNestedOneWithoutPessoaMotoristaInput
  }

  export type CarroUncheckedCreateWithoutPessoaCaronaInput = {
    id?: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutCarroInput
  }

  export type CarroCreateOrConnectWithoutPessoaCaronaInput = {
    where: CarroWhereUniqueInput
    create: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput>
  }

  export type CarroCreateManyPessoaCaronaInputEnvelope = {
    data: CarroCreateManyPessoaCaronaInput | CarroCreateManyPessoaCaronaInput[]
    skipDuplicates?: boolean
  }

  export type CarroCreateWithoutPessoaMotoristaInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    carroEncontro?: CarroEncontroCreateNestedManyWithoutCarroInput
    pessoaCarona?: PessoaCreateNestedOneWithoutPessoaCaronaInput
  }

  export type CarroUncheckedCreateWithoutPessoaMotoristaInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona?: string | null
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutCarroInput
  }

  export type CarroCreateOrConnectWithoutPessoaMotoristaInput = {
    where: CarroWhereUniqueInput
    create: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput>
  }

  export type CarroCreateManyPessoaMotoristaInputEnvelope = {
    data: CarroCreateManyPessoaMotoristaInput | CarroCreateManyPessoaMotoristaInput[]
    skipDuplicates?: boolean
  }

  export type CartaCreateWithoutPessoaInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    isPrinted?: boolean
  }

  export type CartaUncheckedCreateWithoutPessoaInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    isPrinted?: boolean
  }

  export type CartaCreateOrConnectWithoutPessoaInput = {
    where: CartaWhereUniqueInput
    create: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput>
  }

  export type CartaCreateManyPessoaInputEnvelope = {
    data: CartaCreateManyPessoaInput | CartaCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type CirculoCreateWithoutTioAparenteInput = {
    id?: string
    nome?: string | null
    corCirculo: DomainCorCirculoCreateNestedOneWithoutCirculoInput
    encontro: EncontroCreateNestedOneWithoutCirculoInput
    tioSecreto?: PessoaCreateNestedOneWithoutTioSecretoCirculoInput
    encontreiro?: EncontreiroCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUncheckedCreateWithoutTioAparenteInput = {
    id?: string
    idCorCirculo: number
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutCirculoInput
  }

  export type CirculoCreateOrConnectWithoutTioAparenteInput = {
    where: CirculoWhereUniqueInput
    create: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
  }

  export type CirculoCreateWithoutTioSecretoInput = {
    id?: string
    nome?: string | null
    corCirculo: DomainCorCirculoCreateNestedOneWithoutCirculoInput
    encontro: EncontroCreateNestedOneWithoutCirculoInput
    tioAparente?: PessoaCreateNestedOneWithoutTioAparenteCirculoInput
    encontreiro?: EncontreiroCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUncheckedCreateWithoutTioSecretoInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idEncontro: string
    nome?: string | null
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutCirculoInput
  }

  export type CirculoCreateOrConnectWithoutTioSecretoInput = {
    where: CirculoWhereUniqueInput
    create: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
  }

  export type EncontreiroCreateWithoutPessoaInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutPessoaInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutPessoaInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
  }

  export type EncontristaCreateWithoutPessoaInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutPessoaInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutPessoaInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
  }

  export type EnderecoCreateWithoutPessoaInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaCreateNestedManyWithoutEnderecoEncontroInput
    local?: LocalCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutPessoaInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaUncheckedCreateNestedManyWithoutEnderecoEncontroInput
    local?: LocalUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutPessoaInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
  }

  export type SessionCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessToken?: StringNullableFilter<"Account"> | string | null
    expiresAt?: IntNullableFilter<"Account"> | number | null
    tokenType?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    sessionState?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type CarroUpsertWithWhereUniqueWithoutPessoaCaronaInput = {
    where: CarroWhereUniqueInput
    update: XOR<CarroUpdateWithoutPessoaCaronaInput, CarroUncheckedUpdateWithoutPessoaCaronaInput>
    create: XOR<CarroCreateWithoutPessoaCaronaInput, CarroUncheckedCreateWithoutPessoaCaronaInput>
  }

  export type CarroUpdateWithWhereUniqueWithoutPessoaCaronaInput = {
    where: CarroWhereUniqueInput
    data: XOR<CarroUpdateWithoutPessoaCaronaInput, CarroUncheckedUpdateWithoutPessoaCaronaInput>
  }

  export type CarroUpdateManyWithWhereWithoutPessoaCaronaInput = {
    where: CarroScalarWhereInput
    data: XOR<CarroUpdateManyMutationInput, CarroUncheckedUpdateManyWithoutPessoaCaronaInput>
  }

  export type CarroScalarWhereInput = {
    AND?: CarroScalarWhereInput | CarroScalarWhereInput[]
    OR?: CarroScalarWhereInput[]
    NOT?: CarroScalarWhereInput | CarroScalarWhereInput[]
    id?: StringFilter<"Carro"> | string
    idMotorista?: StringFilter<"Carro"> | string
    modeloCarro?: StringFilter<"Carro"> | string
    placaCarro?: StringFilter<"Carro"> | string
    lugaresCarro?: IntFilter<"Carro"> | number
    observacaoMotorista?: StringFilter<"Carro"> | string
    idCarona?: StringNullableFilter<"Carro"> | string | null
  }

  export type CarroUpsertWithWhereUniqueWithoutPessoaMotoristaInput = {
    where: CarroWhereUniqueInput
    update: XOR<CarroUpdateWithoutPessoaMotoristaInput, CarroUncheckedUpdateWithoutPessoaMotoristaInput>
    create: XOR<CarroCreateWithoutPessoaMotoristaInput, CarroUncheckedCreateWithoutPessoaMotoristaInput>
  }

  export type CarroUpdateWithWhereUniqueWithoutPessoaMotoristaInput = {
    where: CarroWhereUniqueInput
    data: XOR<CarroUpdateWithoutPessoaMotoristaInput, CarroUncheckedUpdateWithoutPessoaMotoristaInput>
  }

  export type CarroUpdateManyWithWhereWithoutPessoaMotoristaInput = {
    where: CarroScalarWhereInput
    data: XOR<CarroUpdateManyMutationInput, CarroUncheckedUpdateManyWithoutPessoaMotoristaInput>
  }

  export type CartaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: CartaWhereUniqueInput
    update: XOR<CartaUpdateWithoutPessoaInput, CartaUncheckedUpdateWithoutPessoaInput>
    create: XOR<CartaCreateWithoutPessoaInput, CartaUncheckedCreateWithoutPessoaInput>
  }

  export type CartaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: CartaWhereUniqueInput
    data: XOR<CartaUpdateWithoutPessoaInput, CartaUncheckedUpdateWithoutPessoaInput>
  }

  export type CartaUpdateManyWithWhereWithoutPessoaInput = {
    where: CartaScalarWhereInput
    data: XOR<CartaUpdateManyMutationInput, CartaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type CartaScalarWhereInput = {
    AND?: CartaScalarWhereInput | CartaScalarWhereInput[]
    OR?: CartaScalarWhereInput[]
    NOT?: CartaScalarWhereInput | CartaScalarWhereInput[]
    id?: StringFilter<"Carta"> | string
    para?: StringFilter<"Carta"> | string
    de?: StringFilter<"Carta"> | string
    conteudo?: StringFilter<"Carta"> | string
    createdAt?: DateTimeFilter<"Carta"> | Date | string
    slugEncontrista?: StringFilter<"Carta"> | string
    isPrinted?: BoolFilter<"Carta"> | boolean
  }

  export type CirculoUpsertWithoutTioAparenteInput = {
    update: XOR<CirculoUpdateWithoutTioAparenteInput, CirculoUncheckedUpdateWithoutTioAparenteInput>
    create: XOR<CirculoCreateWithoutTioAparenteInput, CirculoUncheckedCreateWithoutTioAparenteInput>
    where?: CirculoWhereInput
  }

  export type CirculoUpdateToOneWithWhereWithoutTioAparenteInput = {
    where?: CirculoWhereInput
    data: XOR<CirculoUpdateWithoutTioAparenteInput, CirculoUncheckedUpdateWithoutTioAparenteInput>
  }

  export type CirculoUpdateWithoutTioAparenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    corCirculo?: DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCirculoNestedInput
    tioSecreto?: PessoaUpdateOneWithoutTioSecretoCirculoNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateWithoutTioAparenteInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUpsertWithoutTioSecretoInput = {
    update: XOR<CirculoUpdateWithoutTioSecretoInput, CirculoUncheckedUpdateWithoutTioSecretoInput>
    create: XOR<CirculoCreateWithoutTioSecretoInput, CirculoUncheckedCreateWithoutTioSecretoInput>
    where?: CirculoWhereInput
  }

  export type CirculoUpdateToOneWithWhereWithoutTioSecretoInput = {
    where?: CirculoWhereInput
    data: XOR<CirculoUpdateWithoutTioSecretoInput, CirculoUncheckedUpdateWithoutTioSecretoInput>
  }

  export type CirculoUpdateWithoutTioSecretoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    corCirculo?: DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCirculoNestedInput
    tioAparente?: PessoaUpdateOneWithoutTioAparenteCirculoNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateWithoutTioSecretoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput
  }

  export type EncontreiroUpsertWithoutPessoaInput = {
    update: XOR<EncontreiroUpdateWithoutPessoaInput, EncontreiroUncheckedUpdateWithoutPessoaInput>
    create: XOR<EncontreiroCreateWithoutPessoaInput, EncontreiroUncheckedCreateWithoutPessoaInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutPessoaInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutPessoaInput, EncontreiroUncheckedUpdateWithoutPessoaInput>
  }

  export type EncontreiroUpdateWithoutPessoaInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutPessoaInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontristaUpsertWithoutPessoaInput = {
    update: XOR<EncontristaUpdateWithoutPessoaInput, EncontristaUncheckedUpdateWithoutPessoaInput>
    create: XOR<EncontristaCreateWithoutPessoaInput, EncontristaUncheckedCreateWithoutPessoaInput>
    where?: EncontristaWhereInput
  }

  export type EncontristaUpdateToOneWithWhereWithoutPessoaInput = {
    where?: EncontristaWhereInput
    data: XOR<EncontristaUpdateWithoutPessoaInput, EncontristaUncheckedUpdateWithoutPessoaInput>
  }

  export type EncontristaUpdateWithoutPessoaInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutPessoaInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EnderecoUpsertWithoutPessoaInput = {
    update: XOR<EnderecoUpdateWithoutPessoaInput, EnderecoUncheckedUpdateWithoutPessoaInput>
    create: XOR<EnderecoCreateWithoutPessoaInput, EnderecoUncheckedCreateWithoutPessoaInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutPessoaInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutPessoaInput, EnderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type EnderecoUpdateWithoutPessoaInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUpdateManyWithoutEnderecoEncontroNestedInput
    local?: LocalUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutPessoaInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUncheckedUpdateManyWithoutEnderecoEncontroNestedInput
    local?: LocalUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    sessionToken?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    userId?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type EnderecoCreateWithoutEncontristaInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    local?: LocalCreateNestedManyWithoutEnderecoInput
    pessoa?: PessoaCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutEncontristaInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    local?: LocalUncheckedCreateNestedManyWithoutEnderecoInput
    pessoa?: PessoaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutEncontristaInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutEncontristaInput, EnderecoUncheckedCreateWithoutEncontristaInput>
  }

  export type CarroEncontroCreateWithoutEncontristaInput = {
    numeroCarro: number
    id?: string
    observacao?: string | null
    externa?: EncontreiroCreateNestedOneWithoutResponsavelCarroExternaInput
    carro: CarroCreateNestedOneWithoutCarroEncontroInput
    encontro: EncontroCreateNestedOneWithoutCarroEncontroInput
  }

  export type CarroEncontroUncheckedCreateWithoutEncontristaInput = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
  }

  export type CarroEncontroCreateOrConnectWithoutEncontristaInput = {
    where: CarroEncontroWhereUniqueInput
    create: XOR<CarroEncontroCreateWithoutEncontristaInput, CarroEncontroUncheckedCreateWithoutEncontristaInput>
  }

  export type DomainMoraComCreateWithoutEncontristaInput = {
    id: $Enums.Value_MoraCom
    moraCom: string
  }

  export type DomainMoraComUncheckedCreateWithoutEncontristaInput = {
    id: $Enums.Value_MoraCom
    moraCom: string
  }

  export type DomainMoraComCreateOrConnectWithoutEncontristaInput = {
    where: DomainMoraComWhereUniqueInput
    create: XOR<DomainMoraComCreateWithoutEncontristaInput, DomainMoraComUncheckedCreateWithoutEncontristaInput>
  }

  export type PessoaCreateWithoutEncontristaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutEncontristaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutEncontristaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEncontristaInput, PessoaUncheckedCreateWithoutEncontristaInput>
  }

  export type DomainReligiaoCreateWithoutEncontristaInput = {
    id: $Enums.Value_Religiao
    religiao: string
  }

  export type DomainReligiaoUncheckedCreateWithoutEncontristaInput = {
    id: $Enums.Value_Religiao
    religiao: string
  }

  export type DomainReligiaoCreateOrConnectWithoutEncontristaInput = {
    where: DomainReligiaoWhereUniqueInput
    create: XOR<DomainReligiaoCreateWithoutEncontristaInput, DomainReligiaoUncheckedCreateWithoutEncontristaInput>
  }

  export type DomainStatusPaisCreateWithoutEncontristaInput = {
    id: $Enums.Value_StatusPais
    statusPais: string
  }

  export type DomainStatusPaisUncheckedCreateWithoutEncontristaInput = {
    id: $Enums.Value_StatusPais
    statusPais: string
  }

  export type DomainStatusPaisCreateOrConnectWithoutEncontristaInput = {
    where: DomainStatusPaisWhereUniqueInput
    create: XOR<DomainStatusPaisCreateWithoutEncontristaInput, DomainStatusPaisUncheckedCreateWithoutEncontristaInput>
  }

  export type DomainStatusCreateWithoutEncontristaInput = {
    id: $Enums.Value_Status
    status: string
  }

  export type DomainStatusUncheckedCreateWithoutEncontristaInput = {
    id: $Enums.Value_Status
    status: string
  }

  export type DomainStatusCreateOrConnectWithoutEncontristaInput = {
    where: DomainStatusWhereUniqueInput
    create: XOR<DomainStatusCreateWithoutEncontristaInput, DomainStatusUncheckedCreateWithoutEncontristaInput>
  }

  export type ResponsavelExternaCreateWithoutEncontristaInput = {
    encontro: EncontroCreateNestedOneWithoutResponsavelExternaInput
    externa: EncontreiroCreateNestedOneWithoutResponsavelExternaInput
  }

  export type ResponsavelExternaUncheckedCreateWithoutEncontristaInput = {
    idExterna: string
    idEncontro: string
  }

  export type ResponsavelExternaCreateOrConnectWithoutEncontristaInput = {
    where: ResponsavelExternaWhereUniqueInput
    create: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
  }

  export type EnderecoUpsertWithoutEncontristaInput = {
    update: XOR<EnderecoUpdateWithoutEncontristaInput, EnderecoUncheckedUpdateWithoutEncontristaInput>
    create: XOR<EnderecoCreateWithoutEncontristaInput, EnderecoUncheckedCreateWithoutEncontristaInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutEncontristaInput, EnderecoUncheckedUpdateWithoutEncontristaInput>
  }

  export type EnderecoUpdateWithoutEncontristaInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateManyWithoutEnderecoNestedInput
    pessoa?: PessoaUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutEncontristaInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUncheckedUpdateManyWithoutEnderecoNestedInput
    pessoa?: PessoaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type CarroEncontroUpsertWithoutEncontristaInput = {
    update: XOR<CarroEncontroUpdateWithoutEncontristaInput, CarroEncontroUncheckedUpdateWithoutEncontristaInput>
    create: XOR<CarroEncontroCreateWithoutEncontristaInput, CarroEncontroUncheckedCreateWithoutEncontristaInput>
    where?: CarroEncontroWhereInput
  }

  export type CarroEncontroUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: CarroEncontroWhereInput
    data: XOR<CarroEncontroUpdateWithoutEncontristaInput, CarroEncontroUncheckedUpdateWithoutEncontristaInput>
  }

  export type CarroEncontroUpdateWithoutEncontristaInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    externa?: EncontreiroUpdateOneWithoutResponsavelCarroExternaNestedInput
    carro?: CarroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateWithoutEncontristaInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainMoraComUpsertWithoutEncontristaInput = {
    update: XOR<DomainMoraComUpdateWithoutEncontristaInput, DomainMoraComUncheckedUpdateWithoutEncontristaInput>
    create: XOR<DomainMoraComCreateWithoutEncontristaInput, DomainMoraComUncheckedCreateWithoutEncontristaInput>
    where?: DomainMoraComWhereInput
  }

  export type DomainMoraComUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: DomainMoraComWhereInput
    data: XOR<DomainMoraComUpdateWithoutEncontristaInput, DomainMoraComUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainMoraComUpdateWithoutEncontristaInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
  }

  export type DomainMoraComUncheckedUpdateWithoutEncontristaInput = {
    id?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    moraCom?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaUpsertWithoutEncontristaInput = {
    update: XOR<PessoaUpdateWithoutEncontristaInput, PessoaUncheckedUpdateWithoutEncontristaInput>
    create: XOR<PessoaCreateWithoutEncontristaInput, PessoaUncheckedCreateWithoutEncontristaInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutEncontristaInput, PessoaUncheckedUpdateWithoutEncontristaInput>
  }

  export type PessoaUpdateWithoutEncontristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEncontristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DomainReligiaoUpsertWithoutEncontristaInput = {
    update: XOR<DomainReligiaoUpdateWithoutEncontristaInput, DomainReligiaoUncheckedUpdateWithoutEncontristaInput>
    create: XOR<DomainReligiaoCreateWithoutEncontristaInput, DomainReligiaoUncheckedCreateWithoutEncontristaInput>
    where?: DomainReligiaoWhereInput
  }

  export type DomainReligiaoUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: DomainReligiaoWhereInput
    data: XOR<DomainReligiaoUpdateWithoutEncontristaInput, DomainReligiaoUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainReligiaoUpdateWithoutEncontristaInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainReligiaoUncheckedUpdateWithoutEncontristaInput = {
    id?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    religiao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusPaisUpsertWithoutEncontristaInput = {
    update: XOR<DomainStatusPaisUpdateWithoutEncontristaInput, DomainStatusPaisUncheckedUpdateWithoutEncontristaInput>
    create: XOR<DomainStatusPaisCreateWithoutEncontristaInput, DomainStatusPaisUncheckedCreateWithoutEncontristaInput>
    where?: DomainStatusPaisWhereInput
  }

  export type DomainStatusPaisUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: DomainStatusPaisWhereInput
    data: XOR<DomainStatusPaisUpdateWithoutEncontristaInput, DomainStatusPaisUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainStatusPaisUpdateWithoutEncontristaInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusPaisUncheckedUpdateWithoutEncontristaInput = {
    id?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    statusPais?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusUpsertWithoutEncontristaInput = {
    update: XOR<DomainStatusUpdateWithoutEncontristaInput, DomainStatusUncheckedUpdateWithoutEncontristaInput>
    create: XOR<DomainStatusCreateWithoutEncontristaInput, DomainStatusUncheckedCreateWithoutEncontristaInput>
    where?: DomainStatusWhereInput
  }

  export type DomainStatusUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: DomainStatusWhereInput
    data: XOR<DomainStatusUpdateWithoutEncontristaInput, DomainStatusUncheckedUpdateWithoutEncontristaInput>
  }

  export type DomainStatusUpdateWithoutEncontristaInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
  }

  export type DomainStatusUncheckedUpdateWithoutEncontristaInput = {
    id?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ResponsavelExternaUpsertWithoutEncontristaInput = {
    update: XOR<ResponsavelExternaUpdateWithoutEncontristaInput, ResponsavelExternaUncheckedUpdateWithoutEncontristaInput>
    create: XOR<ResponsavelExternaCreateWithoutEncontristaInput, ResponsavelExternaUncheckedCreateWithoutEncontristaInput>
    where?: ResponsavelExternaWhereInput
  }

  export type ResponsavelExternaUpdateToOneWithWhereWithoutEncontristaInput = {
    where?: ResponsavelExternaWhereInput
    data: XOR<ResponsavelExternaUpdateWithoutEncontristaInput, ResponsavelExternaUncheckedUpdateWithoutEncontristaInput>
  }

  export type ResponsavelExternaUpdateWithoutEncontristaInput = {
    encontro?: EncontroUpdateOneRequiredWithoutResponsavelExternaNestedInput
    externa?: EncontreiroUpdateOneRequiredWithoutResponsavelExternaNestedInput
  }

  export type ResponsavelExternaUncheckedUpdateWithoutEncontristaInput = {
    idExterna?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
  }

  export type CarroEncontroCreateWithoutExternaInput = {
    numeroCarro: number
    id?: string
    observacao?: string | null
    carro: CarroCreateNestedOneWithoutCarroEncontroInput
    encontro: EncontroCreateNestedOneWithoutCarroEncontroInput
    encontrista?: EncontristaCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroUncheckedCreateWithoutExternaInput = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    id?: string
    observacao?: string | null
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroCreateOrConnectWithoutExternaInput = {
    where: CarroEncontroWhereUniqueInput
    create: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput>
  }

  export type CarroEncontroCreateManyExternaInputEnvelope = {
    data: CarroEncontroCreateManyExternaInput | CarroEncontroCreateManyExternaInput[]
    skipDuplicates?: boolean
  }

  export type CirculoCreateWithoutEncontreiroInput = {
    id?: string
    nome?: string | null
    corCirculo: DomainCorCirculoCreateNestedOneWithoutCirculoInput
    encontro: EncontroCreateNestedOneWithoutCirculoInput
    tioAparente?: PessoaCreateNestedOneWithoutTioAparenteCirculoInput
    tioSecreto?: PessoaCreateNestedOneWithoutTioSecretoCirculoInput
  }

  export type CirculoUncheckedCreateWithoutEncontreiroInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
  }

  export type CirculoCreateOrConnectWithoutEncontreiroInput = {
    where: CirculoWhereUniqueInput
    create: XOR<CirculoCreateWithoutEncontreiroInput, CirculoUncheckedCreateWithoutEncontreiroInput>
  }

  export type EncontroCreateWithoutEncontreiroInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutEncontreiroInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutEncontreiroInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutEncontreiroInput, EncontroUncheckedCreateWithoutEncontreiroInput>
  }

  export type PessoaCreateWithoutEncontreiroInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutEncontreiroInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutEncontreiroInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEncontreiroInput, PessoaUncheckedCreateWithoutEncontreiroInput>
  }

  export type DomainTamanhoCamisaCreateWithoutEncontreiroInput = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
  }

  export type DomainTamanhoCamisaUncheckedCreateWithoutEncontreiroInput = {
    id: $Enums.Value_TamanhoCamisa
    tamanhoCamisa: string
  }

  export type DomainTamanhoCamisaCreateOrConnectWithoutEncontreiroInput = {
    where: DomainTamanhoCamisaWhereUniqueInput
    create: XOR<DomainTamanhoCamisaCreateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedCreateWithoutEncontreiroInput>
  }

  export type DomainDisponibilidadeCreateWithoutEncontreiroInput = {
    id: $Enums.Value_Disponibilidade
    order?: number
    disponibilidade: string
    descricao?: string
  }

  export type DomainDisponibilidadeUncheckedCreateWithoutEncontreiroInput = {
    id: $Enums.Value_Disponibilidade
    order?: number
    disponibilidade: string
    descricao?: string
  }

  export type DomainDisponibilidadeCreateOrConnectWithoutEncontreiroInput = {
    where: DomainDisponibilidadeWhereUniqueInput
    create: XOR<DomainDisponibilidadeCreateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedCreateWithoutEncontreiroInput>
  }

  export type EquipeEncontroCreateWithoutEncontreiroInput = {
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro: EncontroCreateNestedOneWithoutEquipeEncontroInput
    equipe: DomainEquipesCreateNestedOneWithoutEquipeEncontroInput
  }

  export type EquipeEncontroUncheckedCreateWithoutEncontreiroInput = {
    idEncontro: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroCreateOrConnectWithoutEncontreiroInput = {
    where: EquipeEncontroWhereUniqueInput
    create: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput>
  }

  export type EquipeEncontroCreateManyEncontreiroInputEnvelope = {
    data: EquipeEncontroCreateManyEncontreiroInput | EquipeEncontroCreateManyEncontreiroInput[]
    skipDuplicates?: boolean
  }

  export type EquipeMontagemCreateWithoutEncontreiroInput = {
    coordenando: boolean
    equipe: DomainEquipesCreateNestedOneWithoutEquipeMontagemInput
  }

  export type EquipeMontagemUncheckedCreateWithoutEncontreiroInput = {
    valueEquipe: string
    coordenando: boolean
  }

  export type EquipeMontagemCreateOrConnectWithoutEncontreiroInput = {
    where: EquipeMontagemWhereUniqueInput
    create: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaCreateWithoutEncontreiroInput = {
    posicao: number
    equipe: DomainEquipesCreateNestedOneWithoutListaPreferenciaInput
  }

  export type ListaPreferenciaUncheckedCreateWithoutEncontreiroInput = {
    posicao: number
    valueEquipe: string
  }

  export type ListaPreferenciaCreateOrConnectWithoutEncontreiroInput = {
    where: ListaPreferenciaWhereUniqueInput
    create: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaCreateManyEncontreiroInputEnvelope = {
    data: ListaPreferenciaCreateManyEncontreiroInput | ListaPreferenciaCreateManyEncontreiroInput[]
    skipDuplicates?: boolean
  }

  export type ResponsavelExternaCreateWithoutExternaInput = {
    encontrista: EncontristaCreateNestedOneWithoutResponsavelExternaInput
    encontro: EncontroCreateNestedOneWithoutResponsavelExternaInput
  }

  export type ResponsavelExternaUncheckedCreateWithoutExternaInput = {
    idEncontrista: string
    idEncontro: string
  }

  export type ResponsavelExternaCreateOrConnectWithoutExternaInput = {
    where: ResponsavelExternaWhereUniqueInput
    create: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput>
  }

  export type ResponsavelExternaCreateManyExternaInputEnvelope = {
    data: ResponsavelExternaCreateManyExternaInput | ResponsavelExternaCreateManyExternaInput[]
    skipDuplicates?: boolean
  }

  export type CarroEncontroUpsertWithWhereUniqueWithoutExternaInput = {
    where: CarroEncontroWhereUniqueInput
    update: XOR<CarroEncontroUpdateWithoutExternaInput, CarroEncontroUncheckedUpdateWithoutExternaInput>
    create: XOR<CarroEncontroCreateWithoutExternaInput, CarroEncontroUncheckedCreateWithoutExternaInput>
  }

  export type CarroEncontroUpdateWithWhereUniqueWithoutExternaInput = {
    where: CarroEncontroWhereUniqueInput
    data: XOR<CarroEncontroUpdateWithoutExternaInput, CarroEncontroUncheckedUpdateWithoutExternaInput>
  }

  export type CarroEncontroUpdateManyWithWhereWithoutExternaInput = {
    where: CarroEncontroScalarWhereInput
    data: XOR<CarroEncontroUpdateManyMutationInput, CarroEncontroUncheckedUpdateManyWithoutExternaInput>
  }

  export type CarroEncontroScalarWhereInput = {
    AND?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
    OR?: CarroEncontroScalarWhereInput[]
    NOT?: CarroEncontroScalarWhereInput | CarroEncontroScalarWhereInput[]
    idCarro?: StringFilter<"CarroEncontro"> | string
    idEncontro?: StringFilter<"CarroEncontro"> | string
    numeroCarro?: IntFilter<"CarroEncontro"> | number
    idExterna?: StringNullableFilter<"CarroEncontro"> | string | null
    id?: StringFilter<"CarroEncontro"> | string
    observacao?: StringNullableFilter<"CarroEncontro"> | string | null
  }

  export type CirculoUpsertWithoutEncontreiroInput = {
    update: XOR<CirculoUpdateWithoutEncontreiroInput, CirculoUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<CirculoCreateWithoutEncontreiroInput, CirculoUncheckedCreateWithoutEncontreiroInput>
    where?: CirculoWhereInput
  }

  export type CirculoUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: CirculoWhereInput
    data: XOR<CirculoUpdateWithoutEncontreiroInput, CirculoUncheckedUpdateWithoutEncontreiroInput>
  }

  export type CirculoUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    corCirculo?: DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCirculoNestedInput
    tioAparente?: PessoaUpdateOneWithoutTioAparenteCirculoNestedInput
    tioSecreto?: PessoaUpdateOneWithoutTioSecretoCirculoNestedInput
  }

  export type CirculoUncheckedUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncontroUpsertWithoutEncontreiroInput = {
    update: XOR<EncontroUpdateWithoutEncontreiroInput, EncontroUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<EncontroCreateWithoutEncontreiroInput, EncontroUncheckedCreateWithoutEncontreiroInput>
    where?: EncontroWhereInput
  }

  export type EncontroUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: EncontroWhereInput
    data: XOR<EncontroUpdateWithoutEncontreiroInput, EncontroUncheckedUpdateWithoutEncontreiroInput>
  }

  export type EncontroUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type PessoaUpsertWithoutEncontreiroInput = {
    update: XOR<PessoaUpdateWithoutEncontreiroInput, PessoaUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<PessoaCreateWithoutEncontreiroInput, PessoaUncheckedCreateWithoutEncontreiroInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutEncontreiroInput, PessoaUncheckedUpdateWithoutEncontreiroInput>
  }

  export type PessoaUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEncontreiroInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DomainTamanhoCamisaUpsertWithoutEncontreiroInput = {
    update: XOR<DomainTamanhoCamisaUpdateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<DomainTamanhoCamisaCreateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedCreateWithoutEncontreiroInput>
    where?: DomainTamanhoCamisaWhereInput
  }

  export type DomainTamanhoCamisaUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: DomainTamanhoCamisaWhereInput
    data: XOR<DomainTamanhoCamisaUpdateWithoutEncontreiroInput, DomainTamanhoCamisaUncheckedUpdateWithoutEncontreiroInput>
  }

  export type DomainTamanhoCamisaUpdateWithoutEncontreiroInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
  }

  export type DomainTamanhoCamisaUncheckedUpdateWithoutEncontreiroInput = {
    id?: EnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa
    tamanhoCamisa?: StringFieldUpdateOperationsInput | string
  }

  export type DomainDisponibilidadeUpsertWithoutEncontreiroInput = {
    update: XOR<DomainDisponibilidadeUpdateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<DomainDisponibilidadeCreateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedCreateWithoutEncontreiroInput>
    where?: DomainDisponibilidadeWhereInput
  }

  export type DomainDisponibilidadeUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: DomainDisponibilidadeWhereInput
    data: XOR<DomainDisponibilidadeUpdateWithoutEncontreiroInput, DomainDisponibilidadeUncheckedUpdateWithoutEncontreiroInput>
  }

  export type DomainDisponibilidadeUpdateWithoutEncontreiroInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type DomainDisponibilidadeUncheckedUpdateWithoutEncontreiroInput = {
    id?: EnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade
    order?: IntFieldUpdateOperationsInput | number
    disponibilidade?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type EquipeEncontroUpsertWithWhereUniqueWithoutEncontreiroInput = {
    where: EquipeEncontroWhereUniqueInput
    update: XOR<EquipeEncontroUpdateWithoutEncontreiroInput, EquipeEncontroUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<EquipeEncontroCreateWithoutEncontreiroInput, EquipeEncontroUncheckedCreateWithoutEncontreiroInput>
  }

  export type EquipeEncontroUpdateWithWhereUniqueWithoutEncontreiroInput = {
    where: EquipeEncontroWhereUniqueInput
    data: XOR<EquipeEncontroUpdateWithoutEncontreiroInput, EquipeEncontroUncheckedUpdateWithoutEncontreiroInput>
  }

  export type EquipeEncontroUpdateManyWithWhereWithoutEncontreiroInput = {
    where: EquipeEncontroScalarWhereInput
    data: XOR<EquipeEncontroUpdateManyMutationInput, EquipeEncontroUncheckedUpdateManyWithoutEncontreiroInput>
  }

  export type EquipeEncontroScalarWhereInput = {
    AND?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
    OR?: EquipeEncontroScalarWhereInput[]
    NOT?: EquipeEncontroScalarWhereInput | EquipeEncontroScalarWhereInput[]
    idPessoa?: StringFilter<"EquipeEncontro"> | string
    idEncontro?: StringFilter<"EquipeEncontro"> | string
    idEquipe?: StringFilter<"EquipeEncontro"> | string
    coordenou?: BoolFilter<"EquipeEncontro"> | boolean
    fichaPreenchida?: BoolFilter<"EquipeEncontro"> | boolean
  }

  export type EquipeMontagemUpsertWithoutEncontreiroInput = {
    update: XOR<EquipeMontagemUpdateWithoutEncontreiroInput, EquipeMontagemUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<EquipeMontagemCreateWithoutEncontreiroInput, EquipeMontagemUncheckedCreateWithoutEncontreiroInput>
    where?: EquipeMontagemWhereInput
  }

  export type EquipeMontagemUpdateToOneWithWhereWithoutEncontreiroInput = {
    where?: EquipeMontagemWhereInput
    data: XOR<EquipeMontagemUpdateWithoutEncontreiroInput, EquipeMontagemUncheckedUpdateWithoutEncontreiroInput>
  }

  export type EquipeMontagemUpdateWithoutEncontreiroInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    equipe?: DomainEquipesUpdateOneRequiredWithoutEquipeMontagemNestedInput
  }

  export type EquipeMontagemUncheckedUpdateWithoutEncontreiroInput = {
    valueEquipe?: StringFieldUpdateOperationsInput | string
    coordenando?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListaPreferenciaUpsertWithWhereUniqueWithoutEncontreiroInput = {
    where: ListaPreferenciaWhereUniqueInput
    update: XOR<ListaPreferenciaUpdateWithoutEncontreiroInput, ListaPreferenciaUncheckedUpdateWithoutEncontreiroInput>
    create: XOR<ListaPreferenciaCreateWithoutEncontreiroInput, ListaPreferenciaUncheckedCreateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaUpdateWithWhereUniqueWithoutEncontreiroInput = {
    where: ListaPreferenciaWhereUniqueInput
    data: XOR<ListaPreferenciaUpdateWithoutEncontreiroInput, ListaPreferenciaUncheckedUpdateWithoutEncontreiroInput>
  }

  export type ListaPreferenciaUpdateManyWithWhereWithoutEncontreiroInput = {
    where: ListaPreferenciaScalarWhereInput
    data: XOR<ListaPreferenciaUpdateManyMutationInput, ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroInput>
  }

  export type ListaPreferenciaScalarWhereInput = {
    AND?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
    OR?: ListaPreferenciaScalarWhereInput[]
    NOT?: ListaPreferenciaScalarWhereInput | ListaPreferenciaScalarWhereInput[]
    idPessoa?: StringFilter<"ListaPreferencia"> | string
    posicao?: IntFilter<"ListaPreferencia"> | number
    valueEquipe?: StringFilter<"ListaPreferencia"> | string
  }

  export type ResponsavelExternaUpsertWithWhereUniqueWithoutExternaInput = {
    where: ResponsavelExternaWhereUniqueInput
    update: XOR<ResponsavelExternaUpdateWithoutExternaInput, ResponsavelExternaUncheckedUpdateWithoutExternaInput>
    create: XOR<ResponsavelExternaCreateWithoutExternaInput, ResponsavelExternaUncheckedCreateWithoutExternaInput>
  }

  export type ResponsavelExternaUpdateWithWhereUniqueWithoutExternaInput = {
    where: ResponsavelExternaWhereUniqueInput
    data: XOR<ResponsavelExternaUpdateWithoutExternaInput, ResponsavelExternaUncheckedUpdateWithoutExternaInput>
  }

  export type ResponsavelExternaUpdateManyWithWhereWithoutExternaInput = {
    where: ResponsavelExternaScalarWhereInput
    data: XOR<ResponsavelExternaUpdateManyMutationInput, ResponsavelExternaUncheckedUpdateManyWithoutExternaInput>
  }

  export type ResponsavelExternaScalarWhereInput = {
    AND?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
    OR?: ResponsavelExternaScalarWhereInput[]
    NOT?: ResponsavelExternaScalarWhereInput | ResponsavelExternaScalarWhereInput[]
    idExterna?: StringFilter<"ResponsavelExterna"> | string
    idEncontrista?: StringFilter<"ResponsavelExterna"> | string
    idEncontro?: StringFilter<"ResponsavelExterna"> | string
  }

  export type CarroEncontroCreateWithoutEncontroInput = {
    numeroCarro: number
    id?: string
    observacao?: string | null
    externa?: EncontreiroCreateNestedOneWithoutResponsavelCarroExternaInput
    carro: CarroCreateNestedOneWithoutCarroEncontroInput
    encontrista?: EncontristaCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroUncheckedCreateWithoutEncontroInput = {
    idCarro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroCreateOrConnectWithoutEncontroInput = {
    where: CarroEncontroWhereUniqueInput
    create: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput>
  }

  export type CarroEncontroCreateManyEncontroInputEnvelope = {
    data: CarroEncontroCreateManyEncontroInput | CarroEncontroCreateManyEncontroInput[]
    skipDuplicates?: boolean
  }

  export type CirculoCreateWithoutEncontroInput = {
    id?: string
    nome?: string | null
    corCirculo: DomainCorCirculoCreateNestedOneWithoutCirculoInput
    tioAparente?: PessoaCreateNestedOneWithoutTioAparenteCirculoInput
    tioSecreto?: PessoaCreateNestedOneWithoutTioSecretoCirculoInput
    encontreiro?: EncontreiroCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUncheckedCreateWithoutEncontroInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idTioSecreto?: string | null
    nome?: string | null
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutCirculoInput
  }

  export type CirculoCreateOrConnectWithoutEncontroInput = {
    where: CirculoWhereUniqueInput
    create: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput>
  }

  export type CirculoCreateManyEncontroInputEnvelope = {
    data: CirculoCreateManyEncontroInput | CirculoCreateManyEncontroInput[]
    skipDuplicates?: boolean
  }

  export type EncontreiroCreateWithoutEncontroInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutEncontroInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutEncontroInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput>
  }

  export type EncontreiroCreateManyEncontroInputEnvelope = {
    data: EncontreiroCreateManyEncontroInput | EncontreiroCreateManyEncontroInput[]
    skipDuplicates?: boolean
  }

  export type LocalCreateWithoutEncontroInput = {
    id?: string
    nomeLocal: string
    numeroLocal: string
    endereco: EnderecoCreateNestedOneWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutEncontroInput = {
    id?: string
    enderecoCep: string
    nomeLocal: string
    numeroLocal: string
  }

  export type LocalCreateOrConnectWithoutEncontroInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutEncontroInput, LocalUncheckedCreateWithoutEncontroInput>
  }

  export type EquipeEncontroCreateWithoutEncontroInput = {
    coordenou?: boolean
    fichaPreenchida?: boolean
    equipe: DomainEquipesCreateNestedOneWithoutEquipeEncontroInput
    encontreiro: EncontreiroCreateNestedOneWithoutEquipeEncontroInput
  }

  export type EquipeEncontroUncheckedCreateWithoutEncontroInput = {
    idPessoa: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroCreateOrConnectWithoutEncontroInput = {
    where: EquipeEncontroWhereUniqueInput
    create: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput>
  }

  export type EquipeEncontroCreateManyEncontroInputEnvelope = {
    data: EquipeEncontroCreateManyEncontroInput | EquipeEncontroCreateManyEncontroInput[]
    skipDuplicates?: boolean
  }

  export type ResponsavelExternaCreateWithoutEncontroInput = {
    encontrista: EncontristaCreateNestedOneWithoutResponsavelExternaInput
    externa: EncontreiroCreateNestedOneWithoutResponsavelExternaInput
  }

  export type ResponsavelExternaUncheckedCreateWithoutEncontroInput = {
    idExterna: string
    idEncontrista: string
  }

  export type ResponsavelExternaCreateOrConnectWithoutEncontroInput = {
    where: ResponsavelExternaWhereUniqueInput
    create: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput>
  }

  export type ResponsavelExternaCreateManyEncontroInputEnvelope = {
    data: ResponsavelExternaCreateManyEncontroInput | ResponsavelExternaCreateManyEncontroInput[]
    skipDuplicates?: boolean
  }

  export type CarroEncontroUpsertWithWhereUniqueWithoutEncontroInput = {
    where: CarroEncontroWhereUniqueInput
    update: XOR<CarroEncontroUpdateWithoutEncontroInput, CarroEncontroUncheckedUpdateWithoutEncontroInput>
    create: XOR<CarroEncontroCreateWithoutEncontroInput, CarroEncontroUncheckedCreateWithoutEncontroInput>
  }

  export type CarroEncontroUpdateWithWhereUniqueWithoutEncontroInput = {
    where: CarroEncontroWhereUniqueInput
    data: XOR<CarroEncontroUpdateWithoutEncontroInput, CarroEncontroUncheckedUpdateWithoutEncontroInput>
  }

  export type CarroEncontroUpdateManyWithWhereWithoutEncontroInput = {
    where: CarroEncontroScalarWhereInput
    data: XOR<CarroEncontroUpdateManyMutationInput, CarroEncontroUncheckedUpdateManyWithoutEncontroInput>
  }

  export type CirculoUpsertWithWhereUniqueWithoutEncontroInput = {
    where: CirculoWhereUniqueInput
    update: XOR<CirculoUpdateWithoutEncontroInput, CirculoUncheckedUpdateWithoutEncontroInput>
    create: XOR<CirculoCreateWithoutEncontroInput, CirculoUncheckedCreateWithoutEncontroInput>
  }

  export type CirculoUpdateWithWhereUniqueWithoutEncontroInput = {
    where: CirculoWhereUniqueInput
    data: XOR<CirculoUpdateWithoutEncontroInput, CirculoUncheckedUpdateWithoutEncontroInput>
  }

  export type CirculoUpdateManyWithWhereWithoutEncontroInput = {
    where: CirculoScalarWhereInput
    data: XOR<CirculoUpdateManyMutationInput, CirculoUncheckedUpdateManyWithoutEncontroInput>
  }

  export type CirculoScalarWhereInput = {
    AND?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
    OR?: CirculoScalarWhereInput[]
    NOT?: CirculoScalarWhereInput | CirculoScalarWhereInput[]
    id?: StringFilter<"Circulo"> | string
    idCorCirculo?: IntFilter<"Circulo"> | number
    idTioAparente?: StringNullableFilter<"Circulo"> | string | null
    idTioSecreto?: StringNullableFilter<"Circulo"> | string | null
    idEncontro?: StringFilter<"Circulo"> | string
    nome?: StringNullableFilter<"Circulo"> | string | null
  }

  export type EncontreiroUpsertWithWhereUniqueWithoutEncontroInput = {
    where: EncontreiroWhereUniqueInput
    update: XOR<EncontreiroUpdateWithoutEncontroInput, EncontreiroUncheckedUpdateWithoutEncontroInput>
    create: XOR<EncontreiroCreateWithoutEncontroInput, EncontreiroUncheckedCreateWithoutEncontroInput>
  }

  export type EncontreiroUpdateWithWhereUniqueWithoutEncontroInput = {
    where: EncontreiroWhereUniqueInput
    data: XOR<EncontreiroUpdateWithoutEncontroInput, EncontreiroUncheckedUpdateWithoutEncontroInput>
  }

  export type EncontreiroUpdateManyWithWhereWithoutEncontroInput = {
    where: EncontreiroScalarWhereInput
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyWithoutEncontroInput>
  }

  export type EncontreiroScalarWhereInput = {
    AND?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
    OR?: EncontreiroScalarWhereInput[]
    NOT?: EncontreiroScalarWhereInput | EncontreiroScalarWhereInput[]
    idPessoa?: StringFilter<"Encontreiro"> | string
    dataNasc?: DateTimeFilter<"Encontreiro"> | Date | string
    instagram?: StringNullableFilter<"Encontreiro"> | string | null
    restricaoAlimentar?: StringNullableFilter<"Encontreiro"> | string | null
    idEncontro?: StringNullableFilter<"Encontreiro"> | string | null
    idCirculo?: StringNullableFilter<"Encontreiro"> | string | null
    idTamanhoCamisa?: EnumValue_TamanhoCamisaNullableFilter<"Encontreiro"> | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: EnumValue_DisponibilidadeNullableFilter<"Encontreiro"> | $Enums.Value_Disponibilidade | null
    obsBanda?: StringNullableFilter<"Encontreiro"> | string | null
    observacoes?: StringNullableFilter<"Encontreiro"> | string | null
    statusMontagem?: EnumStatusEncontreiroNullableFilter<"Encontreiro"> | $Enums.StatusEncontreiro | null
  }

  export type LocalUpsertWithoutEncontroInput = {
    update: XOR<LocalUpdateWithoutEncontroInput, LocalUncheckedUpdateWithoutEncontroInput>
    create: XOR<LocalCreateWithoutEncontroInput, LocalUncheckedCreateWithoutEncontroInput>
    where?: LocalWhereInput
  }

  export type LocalUpdateToOneWithWhereWithoutEncontroInput = {
    where?: LocalWhereInput
    data: XOR<LocalUpdateWithoutEncontroInput, LocalUncheckedUpdateWithoutEncontroInput>
  }

  export type LocalUpdateWithoutEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
    endereco?: EnderecoUpdateOneRequiredWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
  }

  export type EquipeEncontroUpsertWithWhereUniqueWithoutEncontroInput = {
    where: EquipeEncontroWhereUniqueInput
    update: XOR<EquipeEncontroUpdateWithoutEncontroInput, EquipeEncontroUncheckedUpdateWithoutEncontroInput>
    create: XOR<EquipeEncontroCreateWithoutEncontroInput, EquipeEncontroUncheckedCreateWithoutEncontroInput>
  }

  export type EquipeEncontroUpdateWithWhereUniqueWithoutEncontroInput = {
    where: EquipeEncontroWhereUniqueInput
    data: XOR<EquipeEncontroUpdateWithoutEncontroInput, EquipeEncontroUncheckedUpdateWithoutEncontroInput>
  }

  export type EquipeEncontroUpdateManyWithWhereWithoutEncontroInput = {
    where: EquipeEncontroScalarWhereInput
    data: XOR<EquipeEncontroUpdateManyMutationInput, EquipeEncontroUncheckedUpdateManyWithoutEncontroInput>
  }

  export type ResponsavelExternaUpsertWithWhereUniqueWithoutEncontroInput = {
    where: ResponsavelExternaWhereUniqueInput
    update: XOR<ResponsavelExternaUpdateWithoutEncontroInput, ResponsavelExternaUncheckedUpdateWithoutEncontroInput>
    create: XOR<ResponsavelExternaCreateWithoutEncontroInput, ResponsavelExternaUncheckedCreateWithoutEncontroInput>
  }

  export type ResponsavelExternaUpdateWithWhereUniqueWithoutEncontroInput = {
    where: ResponsavelExternaWhereUniqueInput
    data: XOR<ResponsavelExternaUpdateWithoutEncontroInput, ResponsavelExternaUncheckedUpdateWithoutEncontroInput>
  }

  export type ResponsavelExternaUpdateManyWithWhereWithoutEncontroInput = {
    where: ResponsavelExternaScalarWhereInput
    data: XOR<ResponsavelExternaUpdateManyMutationInput, ResponsavelExternaUncheckedUpdateManyWithoutEncontroInput>
  }

  export type DomainCorCirculoCreateWithoutCirculoInput = {
    cor: string
  }

  export type DomainCorCirculoUncheckedCreateWithoutCirculoInput = {
    id?: number
    cor: string
  }

  export type DomainCorCirculoCreateOrConnectWithoutCirculoInput = {
    where: DomainCorCirculoWhereUniqueInput
    create: XOR<DomainCorCirculoCreateWithoutCirculoInput, DomainCorCirculoUncheckedCreateWithoutCirculoInput>
  }

  export type EncontroCreateWithoutCirculoInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutCirculoInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutCirculoInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutCirculoInput, EncontroUncheckedCreateWithoutCirculoInput>
  }

  export type PessoaCreateWithoutTioAparenteCirculoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutTioAparenteCirculoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutTioAparenteCirculoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutTioAparenteCirculoInput, PessoaUncheckedCreateWithoutTioAparenteCirculoInput>
  }

  export type PessoaCreateWithoutTioSecretoCirculoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutTioSecretoCirculoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutTioSecretoCirculoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutTioSecretoCirculoInput, PessoaUncheckedCreateWithoutTioSecretoCirculoInput>
  }

  export type EncontreiroCreateWithoutCirculoInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutCirculoInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutCirculoInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput>
  }

  export type EncontreiroCreateManyCirculoInputEnvelope = {
    data: EncontreiroCreateManyCirculoInput | EncontreiroCreateManyCirculoInput[]
    skipDuplicates?: boolean
  }

  export type DomainCorCirculoUpsertWithoutCirculoInput = {
    update: XOR<DomainCorCirculoUpdateWithoutCirculoInput, DomainCorCirculoUncheckedUpdateWithoutCirculoInput>
    create: XOR<DomainCorCirculoCreateWithoutCirculoInput, DomainCorCirculoUncheckedCreateWithoutCirculoInput>
    where?: DomainCorCirculoWhereInput
  }

  export type DomainCorCirculoUpdateToOneWithWhereWithoutCirculoInput = {
    where?: DomainCorCirculoWhereInput
    data: XOR<DomainCorCirculoUpdateWithoutCirculoInput, DomainCorCirculoUncheckedUpdateWithoutCirculoInput>
  }

  export type DomainCorCirculoUpdateWithoutCirculoInput = {
    cor?: StringFieldUpdateOperationsInput | string
  }

  export type DomainCorCirculoUncheckedUpdateWithoutCirculoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
  }

  export type EncontroUpsertWithoutCirculoInput = {
    update: XOR<EncontroUpdateWithoutCirculoInput, EncontroUncheckedUpdateWithoutCirculoInput>
    create: XOR<EncontroCreateWithoutCirculoInput, EncontroUncheckedCreateWithoutCirculoInput>
    where?: EncontroWhereInput
  }

  export type EncontroUpdateToOneWithWhereWithoutCirculoInput = {
    where?: EncontroWhereInput
    data: XOR<EncontroUpdateWithoutCirculoInput, EncontroUncheckedUpdateWithoutCirculoInput>
  }

  export type EncontroUpdateWithoutCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type PessoaUpsertWithoutTioAparenteCirculoInput = {
    update: XOR<PessoaUpdateWithoutTioAparenteCirculoInput, PessoaUncheckedUpdateWithoutTioAparenteCirculoInput>
    create: XOR<PessoaCreateWithoutTioAparenteCirculoInput, PessoaUncheckedCreateWithoutTioAparenteCirculoInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutTioAparenteCirculoInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutTioAparenteCirculoInput, PessoaUncheckedUpdateWithoutTioAparenteCirculoInput>
  }

  export type PessoaUpdateWithoutTioAparenteCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutTioAparenteCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaUpsertWithoutTioSecretoCirculoInput = {
    update: XOR<PessoaUpdateWithoutTioSecretoCirculoInput, PessoaUncheckedUpdateWithoutTioSecretoCirculoInput>
    create: XOR<PessoaCreateWithoutTioSecretoCirculoInput, PessoaUncheckedCreateWithoutTioSecretoCirculoInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutTioSecretoCirculoInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutTioSecretoCirculoInput, PessoaUncheckedUpdateWithoutTioSecretoCirculoInput>
  }

  export type PessoaUpdateWithoutTioSecretoCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutTioSecretoCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EncontreiroUpsertWithWhereUniqueWithoutCirculoInput = {
    where: EncontreiroWhereUniqueInput
    update: XOR<EncontreiroUpdateWithoutCirculoInput, EncontreiroUncheckedUpdateWithoutCirculoInput>
    create: XOR<EncontreiroCreateWithoutCirculoInput, EncontreiroUncheckedCreateWithoutCirculoInput>
  }

  export type EncontreiroUpdateWithWhereUniqueWithoutCirculoInput = {
    where: EncontreiroWhereUniqueInput
    data: XOR<EncontreiroUpdateWithoutCirculoInput, EncontreiroUncheckedUpdateWithoutCirculoInput>
  }

  export type EncontreiroUpdateManyWithWhereWithoutCirculoInput = {
    where: EncontreiroScalarWhereInput
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyWithoutCirculoInput>
  }

  export type EncontristaCreateWithoutEnderecoEncontroInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutEnderecoEncontroInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutEnderecoEncontroInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput>
  }

  export type EncontristaCreateManyEnderecoEncontroInputEnvelope = {
    data: EncontristaCreateManyEnderecoEncontroInput | EncontristaCreateManyEnderecoEncontroInput[]
    skipDuplicates?: boolean
  }

  export type LocalCreateWithoutEnderecoInput = {
    id?: string
    nomeLocal: string
    numeroLocal: string
    encontro?: EncontroCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutEnderecoInput = {
    id?: string
    nomeLocal: string
    numeroLocal: string
    encontro?: EncontroUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalCreateOrConnectWithoutEnderecoInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput>
  }

  export type LocalCreateManyEnderecoInputEnvelope = {
    data: LocalCreateManyEnderecoInput | LocalCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type PessoaCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutEnderecoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutEnderecoInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type PessoaCreateManyEnderecoInputEnvelope = {
    data: PessoaCreateManyEnderecoInput | PessoaCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type EncontristaUpsertWithWhereUniqueWithoutEnderecoEncontroInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutEnderecoEncontroInput, EncontristaUncheckedUpdateWithoutEnderecoEncontroInput>
    create: XOR<EncontristaCreateWithoutEnderecoEncontroInput, EncontristaUncheckedCreateWithoutEnderecoEncontroInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutEnderecoEncontroInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutEnderecoEncontroInput, EncontristaUncheckedUpdateWithoutEnderecoEncontroInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutEnderecoEncontroInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutEnderecoEncontroInput>
  }

  export type EncontristaScalarWhereInput = {
    AND?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
    OR?: EncontristaScalarWhereInput[]
    NOT?: EncontristaScalarWhereInput | EncontristaScalarWhereInput[]
    idPessoa?: StringFilter<"Encontrista"> | string
    endComplemento?: StringFilter<"Encontrista"> | string
    movimentoAnterior?: StringNullableFilter<"Encontrista"> | string | null
    observacao?: StringNullableFilter<"Encontrista"> | string | null
    nomeContato1?: StringFilter<"Encontrista"> | string
    telContato1?: StringFilter<"Encontrista"> | string
    parentescoContato1?: StringFilter<"Encontrista"> | string
    nomeContato2?: StringNullableFilter<"Encontrista"> | string | null
    telContato2?: StringNullableFilter<"Encontrista"> | string | null
    parentescoContato2?: StringNullableFilter<"Encontrista"> | string | null
    createdAt?: DateTimeFilter<"Encontrista"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontrista"> | Date | string
    indicadoPorApelido?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorEmail?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorNome?: StringNullableFilter<"Encontrista"> | string | null
    indicadoPorTel?: StringNullableFilter<"Encontrista"> | string | null
    isAutofill?: BoolFilter<"Encontrista"> | boolean
    idStatus?: EnumValue_StatusFilter<"Encontrista"> | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFilter<"Encontrista"> | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFilter<"Encontrista"> | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFilter<"Encontrista"> | $Enums.Value_StatusPais
    endNumero?: IntFilter<"Encontrista"> | number
    cartasFisicas?: IntFilter<"Encontrista"> | number
    idCarroEncontro?: StringNullableFilter<"Encontrista"> | string | null
    cepEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endComplementoEncontro?: StringNullableFilter<"Encontrista"> | string | null
    endNumEncontro?: IntNullableFilter<"Encontrista"> | number | null
    obsExternaConhecidos?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaLocalizacao?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaOutros?: StringNullableFilter<"Encontrista"> | string | null
    obsExternaSaude?: StringNullableFilter<"Encontrista"> | string | null
    cartasOk?: BoolFilter<"Encontrista"> | boolean
    generosaOk?: BoolFilter<"Encontrista"> | boolean
    familiaOk?: BoolFilter<"Encontrista"> | boolean
  }

  export type LocalUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: LocalWhereUniqueInput
    update: XOR<LocalUpdateWithoutEnderecoInput, LocalUncheckedUpdateWithoutEnderecoInput>
    create: XOR<LocalCreateWithoutEnderecoInput, LocalUncheckedCreateWithoutEnderecoInput>
  }

  export type LocalUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: LocalWhereUniqueInput
    data: XOR<LocalUpdateWithoutEnderecoInput, LocalUncheckedUpdateWithoutEnderecoInput>
  }

  export type LocalUpdateManyWithWhereWithoutEnderecoInput = {
    where: LocalScalarWhereInput
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type LocalScalarWhereInput = {
    AND?: LocalScalarWhereInput | LocalScalarWhereInput[]
    OR?: LocalScalarWhereInput[]
    NOT?: LocalScalarWhereInput | LocalScalarWhereInput[]
    id?: StringFilter<"Local"> | string
    enderecoCep?: StringFilter<"Local"> | string
    nomeLocal?: StringFilter<"Local"> | string
    numeroLocal?: StringFilter<"Local"> | string
  }

  export type PessoaUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: PessoaWhereUniqueInput
    update: XOR<PessoaUpdateWithoutEnderecoInput, PessoaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<PessoaCreateWithoutEnderecoInput, PessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type PessoaUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: PessoaWhereUniqueInput
    data: XOR<PessoaUpdateWithoutEnderecoInput, PessoaUncheckedUpdateWithoutEnderecoInput>
  }

  export type PessoaUpdateManyWithWhereWithoutEnderecoInput = {
    where: PessoaScalarWhereInput
    data: XOR<PessoaUpdateManyMutationInput, PessoaUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type PessoaScalarWhereInput = {
    AND?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
    OR?: PessoaScalarWhereInput[]
    NOT?: PessoaScalarWhereInput | PessoaScalarWhereInput[]
    id?: StringFilter<"Pessoa"> | string
    nome?: StringFilter<"Pessoa"> | string
    sobrenome?: StringFilter<"Pessoa"> | string
    celular?: StringFilter<"Pessoa"> | string
    telefone?: StringNullableFilter<"Pessoa"> | string | null
    email?: StringFilter<"Pessoa"> | string
    createdAt?: DateTimeFilter<"Pessoa"> | Date | string
    modifiedAt?: DateTimeFilter<"Pessoa"> | Date | string
    enderecoCep?: StringFilter<"Pessoa"> | string
    enderecoNumero?: IntNullableFilter<"Pessoa"> | number | null
    avatarUrl?: StringNullableFilter<"Pessoa"> | string | null
    password?: StringNullableFilter<"Pessoa"> | string | null
    changePassword?: BoolFilter<"Pessoa"> | boolean
    apelido?: StringNullableFilter<"Pessoa"> | string | null
    role?: EnumRoleFilter<"Pessoa"> | $Enums.Role
    slug?: StringFilter<"Pessoa"> | string
  }

  export type EncontroCreateWithoutLocalInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutLocalInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutLocalInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput>
  }

  export type EncontroCreateManyLocalInputEnvelope = {
    data: EncontroCreateManyLocalInput | EncontroCreateManyLocalInput[]
    skipDuplicates?: boolean
  }

  export type EnderecoCreateWithoutLocalInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaCreateNestedManyWithoutEnderecoEncontroInput
    pessoa?: PessoaCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoUncheckedCreateWithoutLocalInput = {
    cep: string
    estado: string
    cidade: string
    bairro: string
    rua: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    Encontrista?: EncontristaUncheckedCreateNestedManyWithoutEnderecoEncontroInput
    pessoa?: PessoaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type EnderecoCreateOrConnectWithoutLocalInput = {
    where: EnderecoWhereUniqueInput
    create: XOR<EnderecoCreateWithoutLocalInput, EnderecoUncheckedCreateWithoutLocalInput>
  }

  export type EncontroUpsertWithWhereUniqueWithoutLocalInput = {
    where: EncontroWhereUniqueInput
    update: XOR<EncontroUpdateWithoutLocalInput, EncontroUncheckedUpdateWithoutLocalInput>
    create: XOR<EncontroCreateWithoutLocalInput, EncontroUncheckedCreateWithoutLocalInput>
  }

  export type EncontroUpdateWithWhereUniqueWithoutLocalInput = {
    where: EncontroWhereUniqueInput
    data: XOR<EncontroUpdateWithoutLocalInput, EncontroUncheckedUpdateWithoutLocalInput>
  }

  export type EncontroUpdateManyWithWhereWithoutLocalInput = {
    where: EncontroScalarWhereInput
    data: XOR<EncontroUpdateManyMutationInput, EncontroUncheckedUpdateManyWithoutLocalInput>
  }

  export type EncontroScalarWhereInput = {
    AND?: EncontroScalarWhereInput | EncontroScalarWhereInput[]
    OR?: EncontroScalarWhereInput[]
    NOT?: EncontroScalarWhereInput | EncontroScalarWhereInput[]
    id?: StringFilter<"Encontro"> | string
    numeroEncontro?: IntFilter<"Encontro"> | number
    idLocal?: StringFilter<"Encontro"> | string
    temaEspiritual?: StringNullableFilter<"Encontro"> | string | null
    temaFantasia?: StringNullableFilter<"Encontro"> | string | null
    numeroCirculos?: IntFilter<"Encontro"> | number
    dataInicio?: DateTimeFilter<"Encontro"> | Date | string
    dataTema?: DateTimeFilter<"Encontro"> | Date | string
    createdAt?: DateTimeFilter<"Encontro"> | Date | string
    modifiedAt?: DateTimeFilter<"Encontro"> | Date | string
    ordemCirculos?: IntFilter<"Encontro"> | number
    isReceivingCartas?: BoolFilter<"Encontro"> | boolean
  }

  export type EnderecoUpsertWithoutLocalInput = {
    update: XOR<EnderecoUpdateWithoutLocalInput, EnderecoUncheckedUpdateWithoutLocalInput>
    create: XOR<EnderecoCreateWithoutLocalInput, EnderecoUncheckedCreateWithoutLocalInput>
    where?: EnderecoWhereInput
  }

  export type EnderecoUpdateToOneWithWhereWithoutLocalInput = {
    where?: EnderecoWhereInput
    data: XOR<EnderecoUpdateWithoutLocalInput, EnderecoUncheckedUpdateWithoutLocalInput>
  }

  export type EnderecoUpdateWithoutLocalInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUpdateManyWithoutEnderecoEncontroNestedInput
    pessoa?: PessoaUpdateManyWithoutEnderecoNestedInput
  }

  export type EnderecoUncheckedUpdateWithoutLocalInput = {
    cep?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    rua?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Encontrista?: EncontristaUncheckedUpdateManyWithoutEnderecoEncontroNestedInput
    pessoa?: PessoaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type CarroEncontroCreateWithoutCarroInput = {
    numeroCarro: number
    id?: string
    observacao?: string | null
    externa?: EncontreiroCreateNestedOneWithoutResponsavelCarroExternaInput
    encontro: EncontroCreateNestedOneWithoutCarroEncontroInput
    encontrista?: EncontristaCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroUncheckedCreateWithoutCarroInput = {
    idEncontro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
    encontrista?: EncontristaUncheckedCreateNestedManyWithoutCarroEncontroInput
  }

  export type CarroEncontroCreateOrConnectWithoutCarroInput = {
    where: CarroEncontroWhereUniqueInput
    create: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput>
  }

  export type CarroEncontroCreateManyCarroInputEnvelope = {
    data: CarroEncontroCreateManyCarroInput | CarroEncontroCreateManyCarroInput[]
    skipDuplicates?: boolean
  }

  export type PessoaCreateWithoutPessoaCaronaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutPessoaCaronaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutPessoaCaronaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutPessoaCaronaInput, PessoaUncheckedCreateWithoutPessoaCaronaInput>
  }

  export type PessoaCreateWithoutPessoaMotoristaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutPessoaMotoristaInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutPessoaMotoristaInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutPessoaMotoristaInput, PessoaUncheckedCreateWithoutPessoaMotoristaInput>
  }

  export type CarroEncontroUpsertWithWhereUniqueWithoutCarroInput = {
    where: CarroEncontroWhereUniqueInput
    update: XOR<CarroEncontroUpdateWithoutCarroInput, CarroEncontroUncheckedUpdateWithoutCarroInput>
    create: XOR<CarroEncontroCreateWithoutCarroInput, CarroEncontroUncheckedCreateWithoutCarroInput>
  }

  export type CarroEncontroUpdateWithWhereUniqueWithoutCarroInput = {
    where: CarroEncontroWhereUniqueInput
    data: XOR<CarroEncontroUpdateWithoutCarroInput, CarroEncontroUncheckedUpdateWithoutCarroInput>
  }

  export type CarroEncontroUpdateManyWithWhereWithoutCarroInput = {
    where: CarroEncontroScalarWhereInput
    data: XOR<CarroEncontroUpdateManyMutationInput, CarroEncontroUncheckedUpdateManyWithoutCarroInput>
  }

  export type PessoaUpsertWithoutPessoaCaronaInput = {
    update: XOR<PessoaUpdateWithoutPessoaCaronaInput, PessoaUncheckedUpdateWithoutPessoaCaronaInput>
    create: XOR<PessoaCreateWithoutPessoaCaronaInput, PessoaUncheckedCreateWithoutPessoaCaronaInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutPessoaCaronaInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutPessoaCaronaInput, PessoaUncheckedUpdateWithoutPessoaCaronaInput>
  }

  export type PessoaUpdateWithoutPessoaCaronaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutPessoaCaronaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaUpsertWithoutPessoaMotoristaInput = {
    update: XOR<PessoaUpdateWithoutPessoaMotoristaInput, PessoaUncheckedUpdateWithoutPessoaMotoristaInput>
    create: XOR<PessoaCreateWithoutPessoaMotoristaInput, PessoaUncheckedCreateWithoutPessoaMotoristaInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutPessoaMotoristaInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutPessoaMotoristaInput, PessoaUncheckedUpdateWithoutPessoaMotoristaInput>
  }

  export type PessoaUpdateWithoutPessoaMotoristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutPessoaMotoristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EncontreiroCreateWithoutResponsavelCarroExternaInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutResponsavelCarroExternaInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutResponsavelCarroExternaInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedCreateWithoutResponsavelCarroExternaInput>
  }

  export type CarroCreateWithoutCarroEncontroInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    pessoaCarona?: PessoaCreateNestedOneWithoutPessoaCaronaInput
    pessoaMotorista: PessoaCreateNestedOneWithoutPessoaMotoristaInput
  }

  export type CarroUncheckedCreateWithoutCarroEncontroInput = {
    id?: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona?: string | null
  }

  export type CarroCreateOrConnectWithoutCarroEncontroInput = {
    where: CarroWhereUniqueInput
    create: XOR<CarroCreateWithoutCarroEncontroInput, CarroUncheckedCreateWithoutCarroEncontroInput>
  }

  export type EncontroCreateWithoutCarroEncontroInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutCarroEncontroInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutCarroEncontroInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutCarroEncontroInput, EncontroUncheckedCreateWithoutCarroEncontroInput>
  }

  export type EncontristaCreateWithoutCarroEncontroInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutCarroEncontroInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutCarroEncontroInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput>
  }

  export type EncontristaCreateManyCarroEncontroInputEnvelope = {
    data: EncontristaCreateManyCarroEncontroInput | EncontristaCreateManyCarroEncontroInput[]
    skipDuplicates?: boolean
  }

  export type EncontreiroUpsertWithoutResponsavelCarroExternaInput = {
    update: XOR<EncontreiroUpdateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedUpdateWithoutResponsavelCarroExternaInput>
    create: XOR<EncontreiroCreateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedCreateWithoutResponsavelCarroExternaInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutResponsavelCarroExternaInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutResponsavelCarroExternaInput, EncontreiroUncheckedUpdateWithoutResponsavelCarroExternaInput>
  }

  export type EncontreiroUpdateWithoutResponsavelCarroExternaInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutResponsavelCarroExternaInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type CarroUpsertWithoutCarroEncontroInput = {
    update: XOR<CarroUpdateWithoutCarroEncontroInput, CarroUncheckedUpdateWithoutCarroEncontroInput>
    create: XOR<CarroCreateWithoutCarroEncontroInput, CarroUncheckedCreateWithoutCarroEncontroInput>
    where?: CarroWhereInput
  }

  export type CarroUpdateToOneWithWhereWithoutCarroEncontroInput = {
    where?: CarroWhereInput
    data: XOR<CarroUpdateWithoutCarroEncontroInput, CarroUncheckedUpdateWithoutCarroEncontroInput>
  }

  export type CarroUpdateWithoutCarroEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    pessoaCarona?: PessoaUpdateOneWithoutPessoaCaronaNestedInput
    pessoaMotorista?: PessoaUpdateOneRequiredWithoutPessoaMotoristaNestedInput
  }

  export type CarroUncheckedUpdateWithoutCarroEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    idMotorista?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    idCarona?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncontroUpsertWithoutCarroEncontroInput = {
    update: XOR<EncontroUpdateWithoutCarroEncontroInput, EncontroUncheckedUpdateWithoutCarroEncontroInput>
    create: XOR<EncontroCreateWithoutCarroEncontroInput, EncontroUncheckedCreateWithoutCarroEncontroInput>
    where?: EncontroWhereInput
  }

  export type EncontroUpdateToOneWithWhereWithoutCarroEncontroInput = {
    where?: EncontroWhereInput
    data: XOR<EncontroUpdateWithoutCarroEncontroInput, EncontroUncheckedUpdateWithoutCarroEncontroInput>
  }

  export type EncontroUpdateWithoutCarroEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutCarroEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type EncontristaUpsertWithWhereUniqueWithoutCarroEncontroInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutCarroEncontroInput, EncontristaUncheckedUpdateWithoutCarroEncontroInput>
    create: XOR<EncontristaCreateWithoutCarroEncontroInput, EncontristaUncheckedCreateWithoutCarroEncontroInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutCarroEncontroInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutCarroEncontroInput, EncontristaUncheckedUpdateWithoutCarroEncontroInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutCarroEncontroInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutCarroEncontroInput>
  }

  export type EncontristaCreateWithoutResponsavelExternaInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutResponsavelExternaInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaCreateOrConnectWithoutResponsavelExternaInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutResponsavelExternaInput, EncontristaUncheckedCreateWithoutResponsavelExternaInput>
  }

  export type EncontroCreateWithoutResponsavelExternaInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutResponsavelExternaInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutResponsavelExternaInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutResponsavelExternaInput, EncontroUncheckedCreateWithoutResponsavelExternaInput>
  }

  export type EncontreiroCreateWithoutResponsavelExternaInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
  }

  export type EncontreiroUncheckedCreateWithoutResponsavelExternaInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
  }

  export type EncontreiroCreateOrConnectWithoutResponsavelExternaInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutResponsavelExternaInput, EncontreiroUncheckedCreateWithoutResponsavelExternaInput>
  }

  export type EncontristaUpsertWithoutResponsavelExternaInput = {
    update: XOR<EncontristaUpdateWithoutResponsavelExternaInput, EncontristaUncheckedUpdateWithoutResponsavelExternaInput>
    create: XOR<EncontristaCreateWithoutResponsavelExternaInput, EncontristaUncheckedCreateWithoutResponsavelExternaInput>
    where?: EncontristaWhereInput
  }

  export type EncontristaUpdateToOneWithWhereWithoutResponsavelExternaInput = {
    where?: EncontristaWhereInput
    data: XOR<EncontristaUpdateWithoutResponsavelExternaInput, EncontristaUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type EncontristaUpdateWithoutResponsavelExternaInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutResponsavelExternaInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontroUpsertWithoutResponsavelExternaInput = {
    update: XOR<EncontroUpdateWithoutResponsavelExternaInput, EncontroUncheckedUpdateWithoutResponsavelExternaInput>
    create: XOR<EncontroCreateWithoutResponsavelExternaInput, EncontroUncheckedCreateWithoutResponsavelExternaInput>
    where?: EncontroWhereInput
  }

  export type EncontroUpdateToOneWithWhereWithoutResponsavelExternaInput = {
    where?: EncontroWhereInput
    data: XOR<EncontroUpdateWithoutResponsavelExternaInput, EncontroUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type EncontroUpdateWithoutResponsavelExternaInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutResponsavelExternaInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type EncontreiroUpsertWithoutResponsavelExternaInput = {
    update: XOR<EncontreiroUpdateWithoutResponsavelExternaInput, EncontreiroUncheckedUpdateWithoutResponsavelExternaInput>
    create: XOR<EncontreiroCreateWithoutResponsavelExternaInput, EncontreiroUncheckedCreateWithoutResponsavelExternaInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutResponsavelExternaInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutResponsavelExternaInput, EncontreiroUncheckedUpdateWithoutResponsavelExternaInput>
  }

  export type EncontreiroUpdateWithoutResponsavelExternaInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutResponsavelExternaInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
  }

  export type PessoaCreateWithoutCartasDigitaisInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutCartasDigitaisInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutCartasDigitaisInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutCartasDigitaisInput, PessoaUncheckedCreateWithoutCartasDigitaisInput>
  }

  export type PessoaUpsertWithoutCartasDigitaisInput = {
    update: XOR<PessoaUpdateWithoutCartasDigitaisInput, PessoaUncheckedUpdateWithoutCartasDigitaisInput>
    create: XOR<PessoaCreateWithoutCartasDigitaisInput, PessoaUncheckedCreateWithoutCartasDigitaisInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutCartasDigitaisInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutCartasDigitaisInput, PessoaUncheckedUpdateWithoutCartasDigitaisInput>
  }

  export type PessoaUpdateWithoutCartasDigitaisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutCartasDigitaisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EncontreiroCreateWithoutListaPreferenciasInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutListaPreferenciasInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutListaPreferenciasInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutListaPreferenciasInput, EncontreiroUncheckedCreateWithoutListaPreferenciasInput>
  }

  export type DomainEquipesCreateWithoutListaPreferenciaInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEquipeInput
    EquipeMontagem?: EquipeMontagemCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesUncheckedCreateWithoutListaPreferenciaInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEquipeInput
    EquipeMontagem?: EquipeMontagemUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesCreateOrConnectWithoutListaPreferenciaInput = {
    where: DomainEquipesWhereUniqueInput
    create: XOR<DomainEquipesCreateWithoutListaPreferenciaInput, DomainEquipesUncheckedCreateWithoutListaPreferenciaInput>
  }

  export type EncontreiroUpsertWithoutListaPreferenciasInput = {
    update: XOR<EncontreiroUpdateWithoutListaPreferenciasInput, EncontreiroUncheckedUpdateWithoutListaPreferenciasInput>
    create: XOR<EncontreiroCreateWithoutListaPreferenciasInput, EncontreiroUncheckedCreateWithoutListaPreferenciasInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutListaPreferenciasInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutListaPreferenciasInput, EncontreiroUncheckedUpdateWithoutListaPreferenciasInput>
  }

  export type EncontreiroUpdateWithoutListaPreferenciasInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutListaPreferenciasInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type DomainEquipesUpsertWithoutListaPreferenciaInput = {
    update: XOR<DomainEquipesUpdateWithoutListaPreferenciaInput, DomainEquipesUncheckedUpdateWithoutListaPreferenciaInput>
    create: XOR<DomainEquipesCreateWithoutListaPreferenciaInput, DomainEquipesUncheckedCreateWithoutListaPreferenciaInput>
    where?: DomainEquipesWhereInput
  }

  export type DomainEquipesUpdateToOneWithWhereWithoutListaPreferenciaInput = {
    where?: DomainEquipesWhereInput
    data: XOR<DomainEquipesUpdateWithoutListaPreferenciaInput, DomainEquipesUncheckedUpdateWithoutListaPreferenciaInput>
  }

  export type DomainEquipesUpdateWithoutListaPreferenciaInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEquipeNestedInput
    EquipeMontagem?: EquipeMontagemUpdateManyWithoutEquipeNestedInput
  }

  export type DomainEquipesUncheckedUpdateWithoutListaPreferenciaInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEquipeNestedInput
    EquipeMontagem?: EquipeMontagemUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type EncontroCreateWithoutEquipeEncontroInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroCreateNestedManyWithoutEncontroInput
    circulo?: CirculoCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroCreateNestedManyWithoutEncontroInput
    local: LocalCreateNestedOneWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaCreateNestedManyWithoutEncontroInput
  }

  export type EncontroUncheckedCreateWithoutEquipeEncontroInput = {
    id?: string
    numeroEncontro: number
    idLocal: string
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
    carroEncontro?: CarroEncontroUncheckedCreateNestedManyWithoutEncontroInput
    circulo?: CirculoUncheckedCreateNestedManyWithoutEncontroInput
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutEncontroInput
    ResponsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutEncontroInput
  }

  export type EncontroCreateOrConnectWithoutEquipeEncontroInput = {
    where: EncontroWhereUniqueInput
    create: XOR<EncontroCreateWithoutEquipeEncontroInput, EncontroUncheckedCreateWithoutEquipeEncontroInput>
  }

  export type DomainEquipesCreateWithoutEquipeEncontroInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeMontagem?: EquipeMontagemCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesUncheckedCreateWithoutEquipeEncontroInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeMontagem?: EquipeMontagemUncheckedCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesCreateOrConnectWithoutEquipeEncontroInput = {
    where: DomainEquipesWhereUniqueInput
    create: XOR<DomainEquipesCreateWithoutEquipeEncontroInput, DomainEquipesUncheckedCreateWithoutEquipeEncontroInput>
  }

  export type EncontreiroCreateWithoutEquipeEncontroInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutEquipeEncontroInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutEquipeEncontroInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutEquipeEncontroInput, EncontreiroUncheckedCreateWithoutEquipeEncontroInput>
  }

  export type EncontroUpsertWithoutEquipeEncontroInput = {
    update: XOR<EncontroUpdateWithoutEquipeEncontroInput, EncontroUncheckedUpdateWithoutEquipeEncontroInput>
    create: XOR<EncontroCreateWithoutEquipeEncontroInput, EncontroUncheckedCreateWithoutEquipeEncontroInput>
    where?: EncontroWhereInput
  }

  export type EncontroUpdateToOneWithWhereWithoutEquipeEncontroInput = {
    where?: EncontroWhereInput
    data: XOR<EncontroUpdateWithoutEquipeEncontroInput, EncontroUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type EncontroUpdateWithoutEquipeEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    local?: LocalUpdateOneRequiredWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutEquipeEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    idLocal?: StringFieldUpdateOperationsInput | string
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type DomainEquipesUpsertWithoutEquipeEncontroInput = {
    update: XOR<DomainEquipesUpdateWithoutEquipeEncontroInput, DomainEquipesUncheckedUpdateWithoutEquipeEncontroInput>
    create: XOR<DomainEquipesCreateWithoutEquipeEncontroInput, DomainEquipesUncheckedCreateWithoutEquipeEncontroInput>
    where?: DomainEquipesWhereInput
  }

  export type DomainEquipesUpdateToOneWithWhereWithoutEquipeEncontroInput = {
    where?: DomainEquipesWhereInput
    data: XOR<DomainEquipesUpdateWithoutEquipeEncontroInput, DomainEquipesUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type DomainEquipesUpdateWithoutEquipeEncontroInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeMontagem?: EquipeMontagemUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUpdateManyWithoutEquipeNestedInput
  }

  export type DomainEquipesUncheckedUpdateWithoutEquipeEncontroInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeMontagem?: EquipeMontagemUncheckedUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type EncontreiroUpsertWithoutEquipeEncontroInput = {
    update: XOR<EncontreiroUpdateWithoutEquipeEncontroInput, EncontreiroUncheckedUpdateWithoutEquipeEncontroInput>
    create: XOR<EncontreiroCreateWithoutEquipeEncontroInput, EncontreiroUncheckedCreateWithoutEquipeEncontroInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutEquipeEncontroInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutEquipeEncontroInput, EncontreiroUncheckedUpdateWithoutEquipeEncontroInput>
  }

  export type EncontreiroUpdateWithoutEquipeEncontroInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutEquipeEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroCreateWithoutEquipeMontagemInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutEquipeMontagemInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutEquipeMontagemInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutEquipeMontagemInput, EncontreiroUncheckedCreateWithoutEquipeMontagemInput>
  }

  export type DomainEquipesCreateWithoutEquipeMontagemInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesUncheckedCreateWithoutEquipeMontagemInput = {
    equipeLabel: string
    equipeValue: string
    pastaUrl?: string | null
    EquipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEquipeInput
    ListaPreferencia?: ListaPreferenciaUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type DomainEquipesCreateOrConnectWithoutEquipeMontagemInput = {
    where: DomainEquipesWhereUniqueInput
    create: XOR<DomainEquipesCreateWithoutEquipeMontagemInput, DomainEquipesUncheckedCreateWithoutEquipeMontagemInput>
  }

  export type EncontreiroUpsertWithoutEquipeMontagemInput = {
    update: XOR<EncontreiroUpdateWithoutEquipeMontagemInput, EncontreiroUncheckedUpdateWithoutEquipeMontagemInput>
    create: XOR<EncontreiroCreateWithoutEquipeMontagemInput, EncontreiroUncheckedCreateWithoutEquipeMontagemInput>
    where?: EncontreiroWhereInput
  }

  export type EncontreiroUpdateToOneWithWhereWithoutEquipeMontagemInput = {
    where?: EncontreiroWhereInput
    data: XOR<EncontreiroUpdateWithoutEquipeMontagemInput, EncontreiroUncheckedUpdateWithoutEquipeMontagemInput>
  }

  export type EncontreiroUpdateWithoutEquipeMontagemInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutEquipeMontagemInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type DomainEquipesUpsertWithoutEquipeMontagemInput = {
    update: XOR<DomainEquipesUpdateWithoutEquipeMontagemInput, DomainEquipesUncheckedUpdateWithoutEquipeMontagemInput>
    create: XOR<DomainEquipesCreateWithoutEquipeMontagemInput, DomainEquipesUncheckedCreateWithoutEquipeMontagemInput>
    where?: DomainEquipesWhereInput
  }

  export type DomainEquipesUpdateToOneWithWhereWithoutEquipeMontagemInput = {
    where?: DomainEquipesWhereInput
    data: XOR<DomainEquipesUpdateWithoutEquipeMontagemInput, DomainEquipesUncheckedUpdateWithoutEquipeMontagemInput>
  }

  export type DomainEquipesUpdateWithoutEquipeMontagemInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUpdateManyWithoutEquipeNestedInput
  }

  export type DomainEquipesUncheckedUpdateWithoutEquipeMontagemInput = {
    equipeLabel?: StringFieldUpdateOperationsInput | string
    equipeValue?: StringFieldUpdateOperationsInput | string
    pastaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEquipeNestedInput
    ListaPreferencia?: ListaPreferenciaUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type EncontristaCreateWithoutStatusInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutStatusInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutStatusInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput>
  }

  export type EncontristaCreateManyStatusInputEnvelope = {
    data: EncontristaCreateManyStatusInput | EncontristaCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type EncontristaUpsertWithWhereUniqueWithoutStatusInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutStatusInput, EncontristaUncheckedUpdateWithoutStatusInput>
    create: XOR<EncontristaCreateWithoutStatusInput, EncontristaUncheckedCreateWithoutStatusInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutStatusInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutStatusInput, EncontristaUncheckedUpdateWithoutStatusInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutStatusInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutStatusInput>
  }

  export type EncontristaCreateWithoutReligiaoInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutReligiaoInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutReligiaoInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput>
  }

  export type EncontristaCreateManyReligiaoInputEnvelope = {
    data: EncontristaCreateManyReligiaoInput | EncontristaCreateManyReligiaoInput[]
    skipDuplicates?: boolean
  }

  export type EncontristaUpsertWithWhereUniqueWithoutReligiaoInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutReligiaoInput, EncontristaUncheckedUpdateWithoutReligiaoInput>
    create: XOR<EncontristaCreateWithoutReligiaoInput, EncontristaUncheckedCreateWithoutReligiaoInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutReligiaoInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutReligiaoInput, EncontristaUncheckedUpdateWithoutReligiaoInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutReligiaoInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutReligiaoInput>
  }

  export type EncontristaCreateWithoutMoraComInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    statusPais: DomainStatusPaisCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutMoraComInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutMoraComInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput>
  }

  export type EncontristaCreateManyMoraComInputEnvelope = {
    data: EncontristaCreateManyMoraComInput | EncontristaCreateManyMoraComInput[]
    skipDuplicates?: boolean
  }

  export type EncontristaUpsertWithWhereUniqueWithoutMoraComInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutMoraComInput, EncontristaUncheckedUpdateWithoutMoraComInput>
    create: XOR<EncontristaCreateWithoutMoraComInput, EncontristaUncheckedCreateWithoutMoraComInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutMoraComInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutMoraComInput, EncontristaUncheckedUpdateWithoutMoraComInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutMoraComInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutMoraComInput>
  }

  export type EncontristaCreateWithoutStatusPaisInput = {
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    endNumero: number
    cartasFisicas?: number
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    enderecoEncontro?: EnderecoCreateNestedOneWithoutEncontristaInput
    carroEncontro?: CarroEncontroCreateNestedOneWithoutEncontristaInput
    moraCom: DomainMoraComCreateNestedOneWithoutEncontristaInput
    pessoa: PessoaCreateNestedOneWithoutEncontristaInput
    religiao: DomainReligiaoCreateNestedOneWithoutEncontristaInput
    status: DomainStatusCreateNestedOneWithoutEncontristaInput
    responsavelExterna?: ResponsavelExternaCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaUncheckedCreateWithoutStatusPaisInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedOneWithoutEncontristaInput
  }

  export type EncontristaCreateOrConnectWithoutStatusPaisInput = {
    where: EncontristaWhereUniqueInput
    create: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput>
  }

  export type EncontristaCreateManyStatusPaisInputEnvelope = {
    data: EncontristaCreateManyStatusPaisInput | EncontristaCreateManyStatusPaisInput[]
    skipDuplicates?: boolean
  }

  export type EncontristaUpsertWithWhereUniqueWithoutStatusPaisInput = {
    where: EncontristaWhereUniqueInput
    update: XOR<EncontristaUpdateWithoutStatusPaisInput, EncontristaUncheckedUpdateWithoutStatusPaisInput>
    create: XOR<EncontristaCreateWithoutStatusPaisInput, EncontristaUncheckedCreateWithoutStatusPaisInput>
  }

  export type EncontristaUpdateWithWhereUniqueWithoutStatusPaisInput = {
    where: EncontristaWhereUniqueInput
    data: XOR<EncontristaUpdateWithoutStatusPaisInput, EncontristaUncheckedUpdateWithoutStatusPaisInput>
  }

  export type EncontristaUpdateManyWithWhereWithoutStatusPaisInput = {
    where: EncontristaScalarWhereInput
    data: XOR<EncontristaUpdateManyMutationInput, EncontristaUncheckedUpdateManyWithoutStatusPaisInput>
  }

  export type EncontreiroCreateWithoutTamanhoCamisaInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    disponibilidade?: DomainDisponibilidadeCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutTamanhoCamisaInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutTamanhoCamisaInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput>
  }

  export type EncontreiroCreateManyTamanhoCamisaInputEnvelope = {
    data: EncontreiroCreateManyTamanhoCamisaInput | EncontreiroCreateManyTamanhoCamisaInput[]
    skipDuplicates?: boolean
  }

  export type EncontreiroUpsertWithWhereUniqueWithoutTamanhoCamisaInput = {
    where: EncontreiroWhereUniqueInput
    update: XOR<EncontreiroUpdateWithoutTamanhoCamisaInput, EncontreiroUncheckedUpdateWithoutTamanhoCamisaInput>
    create: XOR<EncontreiroCreateWithoutTamanhoCamisaInput, EncontreiroUncheckedCreateWithoutTamanhoCamisaInput>
  }

  export type EncontreiroUpdateWithWhereUniqueWithoutTamanhoCamisaInput = {
    where: EncontreiroWhereUniqueInput
    data: XOR<EncontreiroUpdateWithoutTamanhoCamisaInput, EncontreiroUncheckedUpdateWithoutTamanhoCamisaInput>
  }

  export type EncontreiroUpdateManyWithWhereWithoutTamanhoCamisaInput = {
    where: EncontreiroScalarWhereInput
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyWithoutTamanhoCamisaInput>
  }

  export type CirculoCreateWithoutCorCirculoInput = {
    id?: string
    nome?: string | null
    encontro: EncontroCreateNestedOneWithoutCirculoInput
    tioAparente?: PessoaCreateNestedOneWithoutTioAparenteCirculoInput
    tioSecreto?: PessoaCreateNestedOneWithoutTioSecretoCirculoInput
    encontreiro?: EncontreiroCreateNestedManyWithoutCirculoInput
  }

  export type CirculoUncheckedCreateWithoutCorCirculoInput = {
    id?: string
    idTioAparente?: string | null
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
    encontreiro?: EncontreiroUncheckedCreateNestedManyWithoutCirculoInput
  }

  export type CirculoCreateOrConnectWithoutCorCirculoInput = {
    where: CirculoWhereUniqueInput
    create: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput>
  }

  export type CirculoCreateManyCorCirculoInputEnvelope = {
    data: CirculoCreateManyCorCirculoInput | CirculoCreateManyCorCirculoInput[]
    skipDuplicates?: boolean
  }

  export type CirculoUpsertWithWhereUniqueWithoutCorCirculoInput = {
    where: CirculoWhereUniqueInput
    update: XOR<CirculoUpdateWithoutCorCirculoInput, CirculoUncheckedUpdateWithoutCorCirculoInput>
    create: XOR<CirculoCreateWithoutCorCirculoInput, CirculoUncheckedCreateWithoutCorCirculoInput>
  }

  export type CirculoUpdateWithWhereUniqueWithoutCorCirculoInput = {
    where: CirculoWhereUniqueInput
    data: XOR<CirculoUpdateWithoutCorCirculoInput, CirculoUncheckedUpdateWithoutCorCirculoInput>
  }

  export type CirculoUpdateManyWithWhereWithoutCorCirculoInput = {
    where: CirculoScalarWhereInput
    data: XOR<CirculoUpdateManyMutationInput, CirculoUncheckedUpdateManyWithoutCorCirculoInput>
  }

  export type EncontreiroCreateWithoutDisponibilidadeInput = {
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroCreateNestedManyWithoutExternaInput
    circulo?: CirculoCreateNestedOneWithoutEncontreiroInput
    encontro?: EncontroCreateNestedOneWithoutEncontreiroInput
    pessoa: PessoaCreateNestedOneWithoutEncontreiroInput
    tamanhoCamisa?: DomainTamanhoCamisaCreateNestedOneWithoutEncontreiroInput
    equipeEncontro?: EquipeEncontroCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroUncheckedCreateWithoutDisponibilidadeInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedCreateNestedManyWithoutExternaInput
    equipeEncontro?: EquipeEncontroUncheckedCreateNestedManyWithoutEncontreiroInput
    equipeMontagem?: EquipeMontagemUncheckedCreateNestedOneWithoutEncontreiroInput
    listaPreferencias?: ListaPreferenciaUncheckedCreateNestedManyWithoutEncontreiroInput
    responsavelExterna?: ResponsavelExternaUncheckedCreateNestedManyWithoutExternaInput
  }

  export type EncontreiroCreateOrConnectWithoutDisponibilidadeInput = {
    where: EncontreiroWhereUniqueInput
    create: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput>
  }

  export type EncontreiroCreateManyDisponibilidadeInputEnvelope = {
    data: EncontreiroCreateManyDisponibilidadeInput | EncontreiroCreateManyDisponibilidadeInput[]
    skipDuplicates?: boolean
  }

  export type EncontreiroUpsertWithWhereUniqueWithoutDisponibilidadeInput = {
    where: EncontreiroWhereUniqueInput
    update: XOR<EncontreiroUpdateWithoutDisponibilidadeInput, EncontreiroUncheckedUpdateWithoutDisponibilidadeInput>
    create: XOR<EncontreiroCreateWithoutDisponibilidadeInput, EncontreiroUncheckedCreateWithoutDisponibilidadeInput>
  }

  export type EncontreiroUpdateWithWhereUniqueWithoutDisponibilidadeInput = {
    where: EncontreiroWhereUniqueInput
    data: XOR<EncontreiroUpdateWithoutDisponibilidadeInput, EncontreiroUncheckedUpdateWithoutDisponibilidadeInput>
  }

  export type EncontreiroUpdateManyWithWhereWithoutDisponibilidadeInput = {
    where: EncontreiroScalarWhereInput
    data: XOR<EncontreiroUpdateManyMutationInput, EncontreiroUncheckedUpdateManyWithoutDisponibilidadeInput>
  }

  export type EquipeEncontroCreateWithoutEquipeInput = {
    coordenou?: boolean
    fichaPreenchida?: boolean
    encontro: EncontroCreateNestedOneWithoutEquipeEncontroInput
    encontreiro: EncontreiroCreateNestedOneWithoutEquipeEncontroInput
  }

  export type EquipeEncontroUncheckedCreateWithoutEquipeInput = {
    idPessoa: string
    idEncontro: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeEncontroCreateOrConnectWithoutEquipeInput = {
    where: EquipeEncontroWhereUniqueInput
    create: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput>
  }

  export type EquipeEncontroCreateManyEquipeInputEnvelope = {
    data: EquipeEncontroCreateManyEquipeInput | EquipeEncontroCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type EquipeMontagemCreateWithoutEquipeInput = {
    coordenando: boolean
    encontreiro: EncontreiroCreateNestedOneWithoutEquipeMontagemInput
  }

  export type EquipeMontagemUncheckedCreateWithoutEquipeInput = {
    coordenando: boolean
    idEncontreiro: string
  }

  export type EquipeMontagemCreateOrConnectWithoutEquipeInput = {
    where: EquipeMontagemWhereUniqueInput
    create: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput>
  }

  export type EquipeMontagemCreateManyEquipeInputEnvelope = {
    data: EquipeMontagemCreateManyEquipeInput | EquipeMontagemCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type ListaPreferenciaCreateWithoutEquipeInput = {
    posicao: number
    encontreiro: EncontreiroCreateNestedOneWithoutListaPreferenciasInput
  }

  export type ListaPreferenciaUncheckedCreateWithoutEquipeInput = {
    idPessoa: string
    posicao: number
  }

  export type ListaPreferenciaCreateOrConnectWithoutEquipeInput = {
    where: ListaPreferenciaWhereUniqueInput
    create: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput>
  }

  export type ListaPreferenciaCreateManyEquipeInputEnvelope = {
    data: ListaPreferenciaCreateManyEquipeInput | ListaPreferenciaCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type EquipeEncontroUpsertWithWhereUniqueWithoutEquipeInput = {
    where: EquipeEncontroWhereUniqueInput
    update: XOR<EquipeEncontroUpdateWithoutEquipeInput, EquipeEncontroUncheckedUpdateWithoutEquipeInput>
    create: XOR<EquipeEncontroCreateWithoutEquipeInput, EquipeEncontroUncheckedCreateWithoutEquipeInput>
  }

  export type EquipeEncontroUpdateWithWhereUniqueWithoutEquipeInput = {
    where: EquipeEncontroWhereUniqueInput
    data: XOR<EquipeEncontroUpdateWithoutEquipeInput, EquipeEncontroUncheckedUpdateWithoutEquipeInput>
  }

  export type EquipeEncontroUpdateManyWithWhereWithoutEquipeInput = {
    where: EquipeEncontroScalarWhereInput
    data: XOR<EquipeEncontroUpdateManyMutationInput, EquipeEncontroUncheckedUpdateManyWithoutEquipeInput>
  }

  export type EquipeMontagemUpsertWithWhereUniqueWithoutEquipeInput = {
    where: EquipeMontagemWhereUniqueInput
    update: XOR<EquipeMontagemUpdateWithoutEquipeInput, EquipeMontagemUncheckedUpdateWithoutEquipeInput>
    create: XOR<EquipeMontagemCreateWithoutEquipeInput, EquipeMontagemUncheckedCreateWithoutEquipeInput>
  }

  export type EquipeMontagemUpdateWithWhereUniqueWithoutEquipeInput = {
    where: EquipeMontagemWhereUniqueInput
    data: XOR<EquipeMontagemUpdateWithoutEquipeInput, EquipeMontagemUncheckedUpdateWithoutEquipeInput>
  }

  export type EquipeMontagemUpdateManyWithWhereWithoutEquipeInput = {
    where: EquipeMontagemScalarWhereInput
    data: XOR<EquipeMontagemUpdateManyMutationInput, EquipeMontagemUncheckedUpdateManyWithoutEquipeInput>
  }

  export type EquipeMontagemScalarWhereInput = {
    AND?: EquipeMontagemScalarWhereInput | EquipeMontagemScalarWhereInput[]
    OR?: EquipeMontagemScalarWhereInput[]
    NOT?: EquipeMontagemScalarWhereInput | EquipeMontagemScalarWhereInput[]
    valueEquipe?: StringFilter<"EquipeMontagem"> | string
    coordenando?: BoolFilter<"EquipeMontagem"> | boolean
    idEncontreiro?: StringFilter<"EquipeMontagem"> | string
  }

  export type ListaPreferenciaUpsertWithWhereUniqueWithoutEquipeInput = {
    where: ListaPreferenciaWhereUniqueInput
    update: XOR<ListaPreferenciaUpdateWithoutEquipeInput, ListaPreferenciaUncheckedUpdateWithoutEquipeInput>
    create: XOR<ListaPreferenciaCreateWithoutEquipeInput, ListaPreferenciaUncheckedCreateWithoutEquipeInput>
  }

  export type ListaPreferenciaUpdateWithWhereUniqueWithoutEquipeInput = {
    where: ListaPreferenciaWhereUniqueInput
    data: XOR<ListaPreferenciaUpdateWithoutEquipeInput, ListaPreferenciaUncheckedUpdateWithoutEquipeInput>
  }

  export type ListaPreferenciaUpdateManyWithWhereWithoutEquipeInput = {
    where: ListaPreferenciaScalarWhereInput
    data: XOR<ListaPreferenciaUpdateManyMutationInput, ListaPreferenciaUncheckedUpdateManyWithoutEquipeInput>
  }

  export type PessoaCreateWithoutAccountsInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type PessoaUncheckedCreateWithoutAccountsInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type PessoaCreateOrConnectWithoutAccountsInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutAccountsInput, PessoaUncheckedCreateWithoutAccountsInput>
  }

  export type PessoaUpsertWithoutAccountsInput = {
    update: XOR<PessoaUpdateWithoutAccountsInput, PessoaUncheckedUpdateWithoutAccountsInput>
    create: XOR<PessoaCreateWithoutAccountsInput, PessoaUncheckedCreateWithoutAccountsInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutAccountsInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutAccountsInput, PessoaUncheckedUpdateWithoutAccountsInput>
  }

  export type PessoaUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaCreateWithoutSessionsInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaCreateNestedOneWithoutPessoaInput
    endereco: EnderecoCreateNestedOneWithoutPessoaInput
  }

  export type PessoaUncheckedCreateWithoutSessionsInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoCep: string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pessoaCarona?: CarroUncheckedCreateNestedManyWithoutPessoaCaronaInput
    pessoaMotorista?: CarroUncheckedCreateNestedManyWithoutPessoaMotoristaInput
    cartasDigitais?: CartaUncheckedCreateNestedManyWithoutPessoaInput
    tioAparenteCirculo?: CirculoUncheckedCreateNestedOneWithoutTioAparenteInput
    tioSecretoCirculo?: CirculoUncheckedCreateNestedOneWithoutTioSecretoInput
    encontreiro?: EncontreiroUncheckedCreateNestedOneWithoutPessoaInput
    encontrista?: EncontristaUncheckedCreateNestedOneWithoutPessoaInput
  }

  export type PessoaCreateOrConnectWithoutSessionsInput = {
    where: PessoaWhereUniqueInput
    create: XOR<PessoaCreateWithoutSessionsInput, PessoaUncheckedCreateWithoutSessionsInput>
  }

  export type PessoaUpsertWithoutSessionsInput = {
    update: XOR<PessoaUpdateWithoutSessionsInput, PessoaUncheckedUpdateWithoutSessionsInput>
    create: XOR<PessoaCreateWithoutSessionsInput, PessoaUncheckedCreateWithoutSessionsInput>
    where?: PessoaWhereInput
  }

  export type PessoaUpdateToOneWithWhereWithoutSessionsInput = {
    where?: PessoaWhereInput
    data: XOR<PessoaUpdateWithoutSessionsInput, PessoaUncheckedUpdateWithoutSessionsInput>
  }

  export type PessoaUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    endereco?: EnderecoUpdateOneRequiredWithoutPessoaNestedInput
  }

  export type PessoaUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoCep?: StringFieldUpdateOperationsInput | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
  }

  export type AccountCreateManyUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refreshToken?: string | null
    accessToken?: string | null
    expiresAt?: number | null
    tokenType?: string | null
    scope?: string | null
    idToken?: string | null
    sessionState?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarroCreateManyPessoaCaronaInput = {
    id?: string
    idMotorista: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
  }

  export type CarroCreateManyPessoaMotoristaInput = {
    id?: string
    modeloCarro: string
    placaCarro: string
    lugaresCarro: number
    observacaoMotorista: string
    idCarona?: string | null
  }

  export type CartaCreateManyPessoaInput = {
    id?: string
    para: string
    de: string
    conteudo: string
    createdAt?: Date | string
    isPrinted?: boolean
  }

  export type SessionCreateManyUserInput = {
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableIntFieldUpdateOperationsInput | number | null
    tokenType?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionState?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarroUpdateWithoutPessoaCaronaInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    carroEncontro?: CarroEncontroUpdateManyWithoutCarroNestedInput
    pessoaMotorista?: PessoaUpdateOneRequiredWithoutPessoaMotoristaNestedInput
  }

  export type CarroUncheckedUpdateWithoutPessoaCaronaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idMotorista?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutCarroNestedInput
  }

  export type CarroUncheckedUpdateManyWithoutPessoaCaronaInput = {
    id?: StringFieldUpdateOperationsInput | string
    idMotorista?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
  }

  export type CarroUpdateWithoutPessoaMotoristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    carroEncontro?: CarroEncontroUpdateManyWithoutCarroNestedInput
    pessoaCarona?: PessoaUpdateOneWithoutPessoaCaronaNestedInput
  }

  export type CarroUncheckedUpdateWithoutPessoaMotoristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    idCarona?: NullableStringFieldUpdateOperationsInput | string | null
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutCarroNestedInput
  }

  export type CarroUncheckedUpdateManyWithoutPessoaMotoristaInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloCarro?: StringFieldUpdateOperationsInput | string
    placaCarro?: StringFieldUpdateOperationsInput | string
    lugaresCarro?: IntFieldUpdateOperationsInput | number
    observacaoMotorista?: StringFieldUpdateOperationsInput | string
    idCarona?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CartaUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartaUncheckedUpdateWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartaUncheckedUpdateManyWithoutPessoaInput = {
    id?: StringFieldUpdateOperationsInput | string
    para?: StringFieldUpdateOperationsInput | string
    de?: StringFieldUpdateOperationsInput | string
    conteudo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPrinted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarroEncontroCreateManyExternaInput = {
    idCarro: string
    idEncontro: string
    numeroCarro: number
    id?: string
    observacao?: string | null
  }

  export type EquipeEncontroCreateManyEncontreiroInput = {
    idEncontro: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type ListaPreferenciaCreateManyEncontreiroInput = {
    posicao: number
    valueEquipe: string
  }

  export type ResponsavelExternaCreateManyExternaInput = {
    idEncontrista: string
    idEncontro: string
  }

  export type CarroEncontroUpdateWithoutExternaInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    carro?: CarroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontrista?: EncontristaUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateWithoutExternaInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    encontrista?: EncontristaUncheckedUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateManyWithoutExternaInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipeEncontroUpdateWithoutEncontreiroInput = {
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
    encontro?: EncontroUpdateOneRequiredWithoutEquipeEncontroNestedInput
    equipe?: DomainEquipesUpdateOneRequiredWithoutEquipeEncontroNestedInput
  }

  export type EquipeEncontroUncheckedUpdateWithoutEncontreiroInput = {
    idEncontro?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEncontreiroInput = {
    idEncontro?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ListaPreferenciaUpdateWithoutEncontreiroInput = {
    posicao?: IntFieldUpdateOperationsInput | number
    equipe?: DomainEquipesUpdateOneRequiredWithoutListaPreferenciaNestedInput
  }

  export type ListaPreferenciaUncheckedUpdateWithoutEncontreiroInput = {
    posicao?: IntFieldUpdateOperationsInput | number
    valueEquipe?: StringFieldUpdateOperationsInput | string
  }

  export type ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroInput = {
    posicao?: IntFieldUpdateOperationsInput | number
    valueEquipe?: StringFieldUpdateOperationsInput | string
  }

  export type ResponsavelExternaUpdateWithoutExternaInput = {
    encontrista?: EncontristaUpdateOneRequiredWithoutResponsavelExternaNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutResponsavelExternaNestedInput
  }

  export type ResponsavelExternaUncheckedUpdateWithoutExternaInput = {
    idEncontrista?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
  }

  export type ResponsavelExternaUncheckedUpdateManyWithoutExternaInput = {
    idEncontrista?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
  }

  export type CarroEncontroCreateManyEncontroInput = {
    idCarro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
  }

  export type CirculoCreateManyEncontroInput = {
    id?: string
    idCorCirculo: number
    idTioAparente?: string | null
    idTioSecreto?: string | null
    nome?: string | null
  }

  export type EncontreiroCreateManyEncontroInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
  }

  export type EquipeEncontroCreateManyEncontroInput = {
    idPessoa: string
    idEquipe: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type ResponsavelExternaCreateManyEncontroInput = {
    idExterna: string
    idEncontrista: string
  }

  export type CarroEncontroUpdateWithoutEncontroInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    externa?: EncontreiroUpdateOneWithoutResponsavelCarroExternaNestedInput
    carro?: CarroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontrista?: EncontristaUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateWithoutEncontroInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    encontrista?: EncontristaUncheckedUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateManyWithoutEncontroInput = {
    idCarro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CirculoUpdateWithoutEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    corCirculo?: DomainCorCirculoUpdateOneRequiredWithoutCirculoNestedInput
    tioAparente?: PessoaUpdateOneWithoutTioAparenteCirculoNestedInput
    tioSecreto?: PessoaUpdateOneWithoutTioSecretoCirculoNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateWithoutEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateManyWithoutEncontroInput = {
    id?: StringFieldUpdateOperationsInput | string
    idCorCirculo?: IntFieldUpdateOperationsInput | number
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncontreiroUpdateWithoutEncontroInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateManyWithoutEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type EquipeEncontroUpdateWithoutEncontroInput = {
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
    equipe?: DomainEquipesUpdateOneRequiredWithoutEquipeEncontroNestedInput
    encontreiro?: EncontreiroUpdateOneRequiredWithoutEquipeEncontroNestedInput
  }

  export type EquipeEncontroUncheckedUpdateWithoutEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEquipe?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResponsavelExternaUpdateWithoutEncontroInput = {
    encontrista?: EncontristaUpdateOneRequiredWithoutResponsavelExternaNestedInput
    externa?: EncontreiroUpdateOneRequiredWithoutResponsavelExternaNestedInput
  }

  export type ResponsavelExternaUncheckedUpdateWithoutEncontroInput = {
    idExterna?: StringFieldUpdateOperationsInput | string
    idEncontrista?: StringFieldUpdateOperationsInput | string
  }

  export type ResponsavelExternaUncheckedUpdateManyWithoutEncontroInput = {
    idExterna?: StringFieldUpdateOperationsInput | string
    idEncontrista?: StringFieldUpdateOperationsInput | string
  }

  export type EncontreiroCreateManyCirculoInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroUpdateWithoutCirculoInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutCirculoInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateManyWithoutCirculoInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type EncontristaCreateManyEnderecoEncontroInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type LocalCreateManyEnderecoInput = {
    id?: string
    nomeLocal: string
    numeroLocal: string
  }

  export type PessoaCreateManyEnderecoInput = {
    id?: string
    nome: string
    sobrenome: string
    celular: string
    telefone?: string | null
    email: string
    createdAt?: Date | string
    modifiedAt?: Date | string
    enderecoNumero?: number | null
    avatarUrl?: string | null
    password?: string | null
    changePassword?: boolean
    apelido?: string | null
    role?: $Enums.Role
    slug: string
  }

  export type EncontristaUpdateWithoutEnderecoEncontroInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutEnderecoEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutEnderecoEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocalUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
    encontro?: EncontroUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
    encontro?: EncontroUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateManyWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeLocal?: StringFieldUpdateOperationsInput | string
    numeroLocal?: StringFieldUpdateOperationsInput | string
  }

  export type PessoaUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pessoaCarona?: CarroUncheckedUpdateManyWithoutPessoaCaronaNestedInput
    pessoaMotorista?: CarroUncheckedUpdateManyWithoutPessoaMotoristaNestedInput
    cartasDigitais?: CartaUncheckedUpdateManyWithoutPessoaNestedInput
    tioAparenteCirculo?: CirculoUncheckedUpdateOneWithoutTioAparenteNestedInput
    tioSecretoCirculo?: CirculoUncheckedUpdateOneWithoutTioSecretoNestedInput
    encontreiro?: EncontreiroUncheckedUpdateOneWithoutPessoaNestedInput
    encontrista?: EncontristaUncheckedUpdateOneWithoutPessoaNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PessoaUncheckedUpdateManyWithoutEnderecoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    celular?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoNumero?: NullableIntFieldUpdateOperationsInput | number | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    changePassword?: BoolFieldUpdateOperationsInput | boolean
    apelido?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type EncontroCreateManyLocalInput = {
    id?: string
    numeroEncontro: number
    temaEspiritual?: string | null
    temaFantasia?: string | null
    numeroCirculos: number
    dataInicio: Date | string
    dataTema: Date | string
    createdAt?: Date | string
    modifiedAt?: Date | string
    ordemCirculos?: number
    isReceivingCartas?: boolean
  }

  export type EncontroUpdateWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
    carroEncontro?: CarroEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    circulo?: CirculoUncheckedUpdateManyWithoutEncontroNestedInput
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutEncontroNestedInput
    EquipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontroNestedInput
    ResponsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutEncontroNestedInput
  }

  export type EncontroUncheckedUpdateManyWithoutLocalInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEncontro?: IntFieldUpdateOperationsInput | number
    temaEspiritual?: NullableStringFieldUpdateOperationsInput | string | null
    temaFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    numeroCirculos?: IntFieldUpdateOperationsInput | number
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTema?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ordemCirculos?: IntFieldUpdateOperationsInput | number
    isReceivingCartas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CarroEncontroCreateManyCarroInput = {
    idEncontro: string
    numeroCarro: number
    idExterna?: string | null
    id?: string
    observacao?: string | null
  }

  export type CarroEncontroUpdateWithoutCarroInput = {
    numeroCarro?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    externa?: EncontreiroUpdateOneWithoutResponsavelCarroExternaNestedInput
    encontro?: EncontroUpdateOneRequiredWithoutCarroEncontroNestedInput
    encontrista?: EncontristaUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateWithoutCarroInput = {
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    encontrista?: EncontristaUncheckedUpdateManyWithoutCarroEncontroNestedInput
  }

  export type CarroEncontroUncheckedUpdateManyWithoutCarroInput = {
    idEncontro?: StringFieldUpdateOperationsInput | string
    numeroCarro?: IntFieldUpdateOperationsInput | number
    idExterna?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncontristaCreateManyCarroEncontroInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateWithoutCarroEncontroInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutCarroEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutCarroEncontroInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontristaCreateManyStatusInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateWithoutStatusInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutStatusInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutStatusInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontristaCreateManyReligiaoInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idMoracom: $Enums.Value_MoraCom
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateWithoutReligiaoInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutReligiaoInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutReligiaoInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontristaCreateManyMoraComInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idStatusPais: $Enums.Value_StatusPais
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateWithoutMoraComInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    statusPais?: DomainStatusPaisUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutMoraComInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutMoraComInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idStatusPais?: EnumValue_StatusPaisFieldUpdateOperationsInput | $Enums.Value_StatusPais
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontristaCreateManyStatusPaisInput = {
    idPessoa: string
    endComplemento: string
    movimentoAnterior?: string | null
    observacao?: string | null
    nomeContato1: string
    telContato1: string
    parentescoContato1: string
    nomeContato2?: string | null
    telContato2?: string | null
    parentescoContato2?: string | null
    createdAt?: Date | string
    modifiedAt?: Date | string
    indicadoPorApelido?: string | null
    indicadoPorEmail?: string | null
    indicadoPorNome?: string | null
    indicadoPorTel?: string | null
    isAutofill: boolean
    idStatus: $Enums.Value_Status
    idReligiao: $Enums.Value_Religiao
    idMoracom: $Enums.Value_MoraCom
    endNumero: number
    cartasFisicas?: number
    idCarroEncontro?: string | null
    cepEncontro?: string | null
    endComplementoEncontro?: string | null
    endNumEncontro?: number | null
    obsExternaConhecidos?: string | null
    obsExternaLocalizacao?: string | null
    obsExternaOutros?: string | null
    obsExternaSaude?: string | null
    cartasOk?: boolean
    generosaOk?: boolean
    familiaOk?: boolean
  }

  export type EncontristaUpdateWithoutStatusPaisInput = {
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    enderecoEncontro?: EnderecoUpdateOneWithoutEncontristaNestedInput
    carroEncontro?: CarroEncontroUpdateOneWithoutEncontristaNestedInput
    moraCom?: DomainMoraComUpdateOneRequiredWithoutEncontristaNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontristaNestedInput
    religiao?: DomainReligiaoUpdateOneRequiredWithoutEncontristaNestedInput
    status?: DomainStatusUpdateOneRequiredWithoutEncontristaNestedInput
    responsavelExterna?: ResponsavelExternaUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateWithoutStatusPaisInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
    responsavelExterna?: ResponsavelExternaUncheckedUpdateOneWithoutEncontristaNestedInput
  }

  export type EncontristaUncheckedUpdateManyWithoutStatusPaisInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    endComplemento?: StringFieldUpdateOperationsInput | string
    movimentoAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    nomeContato1?: StringFieldUpdateOperationsInput | string
    telContato1?: StringFieldUpdateOperationsInput | string
    parentescoContato1?: StringFieldUpdateOperationsInput | string
    nomeContato2?: NullableStringFieldUpdateOperationsInput | string | null
    telContato2?: NullableStringFieldUpdateOperationsInput | string | null
    parentescoContato2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicadoPorApelido?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorEmail?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorNome?: NullableStringFieldUpdateOperationsInput | string | null
    indicadoPorTel?: NullableStringFieldUpdateOperationsInput | string | null
    isAutofill?: BoolFieldUpdateOperationsInput | boolean
    idStatus?: EnumValue_StatusFieldUpdateOperationsInput | $Enums.Value_Status
    idReligiao?: EnumValue_ReligiaoFieldUpdateOperationsInput | $Enums.Value_Religiao
    idMoracom?: EnumValue_MoraComFieldUpdateOperationsInput | $Enums.Value_MoraCom
    endNumero?: IntFieldUpdateOperationsInput | number
    cartasFisicas?: IntFieldUpdateOperationsInput | number
    idCarroEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    cepEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endComplementoEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    endNumEncontro?: NullableIntFieldUpdateOperationsInput | number | null
    obsExternaConhecidos?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaLocalizacao?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaOutros?: NullableStringFieldUpdateOperationsInput | string | null
    obsExternaSaude?: NullableStringFieldUpdateOperationsInput | string | null
    cartasOk?: BoolFieldUpdateOperationsInput | boolean
    generosaOk?: BoolFieldUpdateOperationsInput | boolean
    familiaOk?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncontreiroCreateManyTamanhoCamisaInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idDisponibilidade?: $Enums.Value_Disponibilidade | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroUpdateWithoutTamanhoCamisaInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    disponibilidade?: DomainDisponibilidadeUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutTamanhoCamisaInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateManyWithoutTamanhoCamisaInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idDisponibilidade?: NullableEnumValue_DisponibilidadeFieldUpdateOperationsInput | $Enums.Value_Disponibilidade | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type CirculoCreateManyCorCirculoInput = {
    id?: string
    idTioAparente?: string | null
    idTioSecreto?: string | null
    idEncontro: string
    nome?: string | null
  }

  export type CirculoUpdateWithoutCorCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontro?: EncontroUpdateOneRequiredWithoutCirculoNestedInput
    tioAparente?: PessoaUpdateOneWithoutTioAparenteCirculoNestedInput
    tioSecreto?: PessoaUpdateOneWithoutTioSecretoCirculoNestedInput
    encontreiro?: EncontreiroUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateWithoutCorCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    encontreiro?: EncontreiroUncheckedUpdateManyWithoutCirculoNestedInput
  }

  export type CirculoUncheckedUpdateManyWithoutCorCirculoInput = {
    id?: StringFieldUpdateOperationsInput | string
    idTioAparente?: NullableStringFieldUpdateOperationsInput | string | null
    idTioSecreto?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: StringFieldUpdateOperationsInput | string
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EncontreiroCreateManyDisponibilidadeInput = {
    idPessoa: string
    dataNasc: Date | string
    instagram?: string | null
    restricaoAlimentar?: string | null
    idEncontro?: string | null
    idCirculo?: string | null
    idTamanhoCamisa?: $Enums.Value_TamanhoCamisa | null
    obsBanda?: string | null
    observacoes?: string | null
    statusMontagem?: $Enums.StatusEncontreiro | null
  }

  export type EncontreiroUpdateWithoutDisponibilidadeInput = {
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUpdateManyWithoutExternaNestedInput
    circulo?: CirculoUpdateOneWithoutEncontreiroNestedInput
    encontro?: EncontroUpdateOneWithoutEncontreiroNestedInput
    pessoa?: PessoaUpdateOneRequiredWithoutEncontreiroNestedInput
    tamanhoCamisa?: DomainTamanhoCamisaUpdateOneWithoutEncontreiroNestedInput
    equipeEncontro?: EquipeEncontroUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateWithoutDisponibilidadeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
    responsavelCarroExterna?: CarroEncontroUncheckedUpdateManyWithoutExternaNestedInput
    equipeEncontro?: EquipeEncontroUncheckedUpdateManyWithoutEncontreiroNestedInput
    equipeMontagem?: EquipeMontagemUncheckedUpdateOneWithoutEncontreiroNestedInput
    listaPreferencias?: ListaPreferenciaUncheckedUpdateManyWithoutEncontreiroNestedInput
    responsavelExterna?: ResponsavelExternaUncheckedUpdateManyWithoutExternaNestedInput
  }

  export type EncontreiroUncheckedUpdateManyWithoutDisponibilidadeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    dataNasc?: DateTimeFieldUpdateOperationsInput | Date | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    restricaoAlimentar?: NullableStringFieldUpdateOperationsInput | string | null
    idEncontro?: NullableStringFieldUpdateOperationsInput | string | null
    idCirculo?: NullableStringFieldUpdateOperationsInput | string | null
    idTamanhoCamisa?: NullableEnumValue_TamanhoCamisaFieldUpdateOperationsInput | $Enums.Value_TamanhoCamisa | null
    obsBanda?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    statusMontagem?: NullableEnumStatusEncontreiroFieldUpdateOperationsInput | $Enums.StatusEncontreiro | null
  }

  export type EquipeEncontroCreateManyEquipeInput = {
    idPessoa: string
    idEncontro: string
    coordenou?: boolean
    fichaPreenchida?: boolean
  }

  export type EquipeMontagemCreateManyEquipeInput = {
    coordenando: boolean
    idEncontreiro: string
  }

  export type ListaPreferenciaCreateManyEquipeInput = {
    idPessoa: string
    posicao: number
  }

  export type EquipeEncontroUpdateWithoutEquipeInput = {
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
    encontro?: EncontroUpdateOneRequiredWithoutEquipeEncontroNestedInput
    encontreiro?: EncontreiroUpdateOneRequiredWithoutEquipeEncontroNestedInput
  }

  export type EquipeEncontroUncheckedUpdateWithoutEquipeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeEncontroUncheckedUpdateManyWithoutEquipeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    idEncontro?: StringFieldUpdateOperationsInput | string
    coordenou?: BoolFieldUpdateOperationsInput | boolean
    fichaPreenchida?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipeMontagemUpdateWithoutEquipeInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    encontreiro?: EncontreiroUpdateOneRequiredWithoutEquipeMontagemNestedInput
  }

  export type EquipeMontagemUncheckedUpdateWithoutEquipeInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    idEncontreiro?: StringFieldUpdateOperationsInput | string
  }

  export type EquipeMontagemUncheckedUpdateManyWithoutEquipeInput = {
    coordenando?: BoolFieldUpdateOperationsInput | boolean
    idEncontreiro?: StringFieldUpdateOperationsInput | string
  }

  export type ListaPreferenciaUpdateWithoutEquipeInput = {
    posicao?: IntFieldUpdateOperationsInput | number
    encontreiro?: EncontreiroUpdateOneRequiredWithoutListaPreferenciasNestedInput
  }

  export type ListaPreferenciaUncheckedUpdateWithoutEquipeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    posicao?: IntFieldUpdateOperationsInput | number
  }

  export type ListaPreferenciaUncheckedUpdateManyWithoutEquipeInput = {
    idPessoa?: StringFieldUpdateOperationsInput | string
    posicao?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}